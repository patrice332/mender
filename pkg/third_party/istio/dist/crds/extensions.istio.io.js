// generated by cdk8s
import { ApiObject } from 'cdk8s';
/**
 *
 *
 * @schema WasmPlugin
 */
export class WasmPlugin extends ApiObject {
    /**
     * Returns the apiVersion and kind for "WasmPlugin"
     */
    static GVK = {
        apiVersion: 'extensions.istio.io/v1alpha1',
        kind: 'WasmPlugin',
    };
    /**
     * Renders a Kubernetes manifest for "WasmPlugin".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...WasmPlugin.GVK,
            ...toJson_WasmPluginProps(props),
        };
    }
    /**
     * Defines a "WasmPlugin" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...WasmPlugin.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...WasmPlugin.GVK,
            ...toJson_WasmPluginProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'WasmPluginProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_WasmPluginSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'WasmPluginSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failStrategy': obj.failStrategy,
        'imagePullPolicy': obj.imagePullPolicy,
        'imagePullSecret': obj.imagePullSecret,
        'match': obj.match?.map(y => toJson_WasmPluginSpecMatch(y)),
        'phase': obj.phase,
        'pluginConfig': obj.pluginConfig,
        'pluginName': obj.pluginName,
        'priority': obj.priority,
        'selector': toJson_WasmPluginSpecSelector(obj.selector),
        'sha256': obj.sha256,
        'targetRef': toJson_WasmPluginSpecTargetRef(obj.targetRef),
        'targetRefs': obj.targetRefs?.map(y => toJson_WasmPluginSpecTargetRefs(y)),
        'type': obj.type,
        'url': obj.url,
        'verificationKey': obj.verificationKey,
        'vmConfig': toJson_WasmPluginSpecVmConfig(obj.vmConfig),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Specifies the failure behavior for the plugin due to fatal errors.
 *
 * Valid Options: FAIL_CLOSE, FAIL_OPEN, FAIL_RELOAD
 *
 * @schema WasmPluginSpecFailStrategy
 */
export var WasmPluginSpecFailStrategy;
(function (WasmPluginSpecFailStrategy) {
    /** FAIL_CLOSE */
    WasmPluginSpecFailStrategy["FAIL_UNDERSCORE_CLOSE"] = "FAIL_CLOSE";
    /** FAIL_OPEN */
    WasmPluginSpecFailStrategy["FAIL_UNDERSCORE_OPEN"] = "FAIL_OPEN";
    /** FAIL_RELOAD */
    WasmPluginSpecFailStrategy["FAIL_UNDERSCORE_RELOAD"] = "FAIL_RELOAD";
})(WasmPluginSpecFailStrategy || (WasmPluginSpecFailStrategy = {}));
/**
 * The pull behaviour to be applied when fetching Wasm module by either OCI image or `http/https`.
 *
 * Valid Options: IfNotPresent, Always
 *
 * @schema WasmPluginSpecImagePullPolicy
 */
export var WasmPluginSpecImagePullPolicy;
(function (WasmPluginSpecImagePullPolicy) {
    /** UNSPECIFIED_POLICY */
    WasmPluginSpecImagePullPolicy["UNSPECIFIED_UNDERSCORE_POLICY"] = "UNSPECIFIED_POLICY";
    /** IfNotPresent */
    WasmPluginSpecImagePullPolicy["IF_NOT_PRESENT"] = "IfNotPresent";
    /** Always */
    WasmPluginSpecImagePullPolicy["ALWAYS"] = "Always";
})(WasmPluginSpecImagePullPolicy || (WasmPluginSpecImagePullPolicy = {}));
/**
 * Converts an object of type 'WasmPluginSpecMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecMatch(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'mode': obj.mode,
        'ports': obj.ports?.map(y => toJson_WasmPluginSpecMatchPorts(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Determines where in the filter chain this `WasmPlugin` is to be injected.
 *
 * Valid Options: AUTHN, AUTHZ, STATS
 *
 * @schema WasmPluginSpecPhase
 */
export var WasmPluginSpecPhase;
(function (WasmPluginSpecPhase) {
    /** UNSPECIFIED_PHASE */
    WasmPluginSpecPhase["UNSPECIFIED_UNDERSCORE_PHASE"] = "UNSPECIFIED_PHASE";
    /** AUTHN */
    WasmPluginSpecPhase["AUTHN"] = "AUTHN";
    /** AUTHZ */
    WasmPluginSpecPhase["AUTHZ"] = "AUTHZ";
    /** STATS */
    WasmPluginSpecPhase["STATS"] = "STATS";
})(WasmPluginSpecPhase || (WasmPluginSpecPhase = {}));
/**
 * Converts an object of type 'WasmPluginSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecSelector(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'WasmPluginSpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecTargetRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'WasmPluginSpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecTargetRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Specifies the type of Wasm Extension to be used.
 *
 * Valid Options: HTTP, NETWORK
 *
 * @schema WasmPluginSpecType
 */
export var WasmPluginSpecType;
(function (WasmPluginSpecType) {
    /** UNSPECIFIED_PLUGIN_TYPE */
    WasmPluginSpecType["UNSPECIFIED_UNDERSCORE_PLUGIN_UNDERSCORE_TYPE"] = "UNSPECIFIED_PLUGIN_TYPE";
    /** HTTP */
    WasmPluginSpecType["HTTP"] = "HTTP";
    /** NETWORK */
    WasmPluginSpecType["NETWORK"] = "NETWORK";
})(WasmPluginSpecType || (WasmPluginSpecType = {}));
/**
 * Converts an object of type 'WasmPluginSpecVmConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecVmConfig(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_WasmPluginSpecVmConfigEnv(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Criteria for selecting traffic by their direction.
 *
 * Valid Options: CLIENT, SERVER, CLIENT_AND_SERVER
 *
 * @schema WasmPluginSpecMatchMode
 */
export var WasmPluginSpecMatchMode;
(function (WasmPluginSpecMatchMode) {
    /** UNDEFINED */
    WasmPluginSpecMatchMode["UNDEFINED"] = "UNDEFINED";
    /** CLIENT */
    WasmPluginSpecMatchMode["CLIENT"] = "CLIENT";
    /** SERVER */
    WasmPluginSpecMatchMode["SERVER"] = "SERVER";
    /** CLIENT_AND_SERVER */
    WasmPluginSpecMatchMode["CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER"] = "CLIENT_AND_SERVER";
})(WasmPluginSpecMatchMode || (WasmPluginSpecMatchMode = {}));
/**
 * Converts an object of type 'WasmPluginSpecMatchPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecMatchPorts(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'number': obj.number,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'WasmPluginSpecVmConfigEnv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WasmPluginSpecVmConfigEnv(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
        'valueFrom': obj.valueFrom,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Source for the environment variable's value.
 *
 * Valid Options: INLINE, HOST
 *
 * @schema WasmPluginSpecVmConfigEnvValueFrom
 */
export var WasmPluginSpecVmConfigEnvValueFrom;
(function (WasmPluginSpecVmConfigEnvValueFrom) {
    /** INLINE */
    WasmPluginSpecVmConfigEnvValueFrom["INLINE"] = "INLINE";
    /** HOST */
    WasmPluginSpecVmConfigEnvValueFrom["HOST"] = "HOST";
})(WasmPluginSpecVmConfigEnvValueFrom || (WasmPluginSpecVmConfigEnvValueFrom = {}));
