// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema DestinationRule
 */
export class DestinationRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DestinationRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'DestinationRule',
  }

  /**
   * Renders a Kubernetes manifest for "DestinationRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DestinationRuleProps = {}): any {
    return {
      ...DestinationRule.GVK,
      ...toJson_DestinationRuleProps(props),
    };
  }

  /**
   * Defines a "DestinationRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DestinationRuleProps = {}) {
    super(scope, id, {
      ...DestinationRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DestinationRule.GVK,
      ...toJson_DestinationRuleProps(resolved),
    };
  }
}

/**
 * @schema DestinationRule
 */
export interface DestinationRuleProps {
  /**
   * @schema DestinationRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRule#spec
   */
  readonly spec?: DestinationRuleSpec;

}

/**
 * Converts an object of type 'DestinationRuleProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleProps(obj: DestinationRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DestinationRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleSpec
 */
export interface DestinationRuleSpec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleSpec#host
   */
  readonly host: string;

  /**
   * One or more named sets that represent individual versions of a service.
   *
   * @schema DestinationRuleSpec#subsets
   */
  readonly subsets?: DestinationRuleSpecSubsets[];

  /**
   * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
   *
   * @schema DestinationRuleSpec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
   *
   * @schema DestinationRuleSpec#workloadSelector
   */
  readonly workloadSelector?: DestinationRuleSpecWorkloadSelector;

}

/**
 * Converts an object of type 'DestinationRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpec(obj: DestinationRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'host': obj.host,
    'subsets': obj.subsets?.map(y => toJson_DestinationRuleSpecSubsets(y)),
    'trafficPolicy': toJson_DestinationRuleSpecTrafficPolicy(obj.trafficPolicy),
    'workloadSelector': toJson_DestinationRuleSpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsets
 */
export interface DestinationRuleSpecSubsets {
  /**
   * Labels apply a filter over the endpoints of a service in the service registry.
   *
   * @schema DestinationRuleSpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleSpecSubsets#name
   */
  readonly name: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleSpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecSubsetsTrafficPolicy;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsets(obj: DestinationRuleSpecSubsets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'trafficPolicy': toJson_DestinationRuleSpecSubsetsTrafficPolicy(obj.trafficPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
 *
 * @schema DestinationRuleSpecTrafficPolicy
 */
export interface DestinationRuleSpecTrafficPolicy {
  /**
   * @schema DestinationRuleSpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecTrafficPolicyPortLevelSettings[];

  /**
   * The upstream PROXY protocol settings.
   *
   * @schema DestinationRuleSpecTrafficPolicy#proxyProtocol
   */
  readonly proxyProtocol?: DestinationRuleSpecTrafficPolicyProxyProtocol;

  /**
   * Specifies a limit on concurrent retries in relation to the number of active requests.
   *
   * @schema DestinationRuleSpecTrafficPolicy#retryBudget
   */
  readonly retryBudget?: DestinationRuleSpecTrafficPolicyRetryBudget;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleSpecTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleSpecTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicy(obj: DestinationRuleSpecTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettings(y)),
    'proxyProtocol': toJson_DestinationRuleSpecTrafficPolicyProxyProtocol(obj.proxyProtocol),
    'retryBudget': toJson_DestinationRuleSpecTrafficPolicyRetryBudget(obj.retryBudget),
    'tls': toJson_DestinationRuleSpecTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleSpecTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
 *
 * @schema DestinationRuleSpecWorkloadSelector
 */
export interface DestinationRuleSpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema DestinationRuleSpecWorkloadSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DestinationRuleSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecWorkloadSelector(obj: DestinationRuleSpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicy
 */
export interface DestinationRuleSpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * The upstream PROXY protocol settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#proxyProtocol
   */
  readonly proxyProtocol?: DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol;

  /**
   * Specifies a limit on concurrent retries in relation to the number of active requests.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#retryBudget
   */
  readonly retryBudget?: DestinationRuleSpecSubsetsTrafficPolicyRetryBudget;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleSpecSubsetsTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicy(obj: DestinationRuleSpecSubsetsTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(y)),
    'proxyProtocol': toJson_DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol(obj.proxyProtocol),
    'retryBudget': toJson_DestinationRuleSpecSubsetsTrafficPolicyRetryBudget(obj.retryBudget),
    'tls': toJson_DestinationRuleSpecSubsetsTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleSpecSubsetsTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPool(obj: DestinationRuleSpecTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleSpecTrafficPolicyLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancer(obj: DestinationRuleSpecTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyOutlierDetection(obj: DestinationRuleSpecTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettings(obj: DestinationRuleSpecTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The upstream PROXY protocol settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyProxyProtocol
 */
export interface DestinationRuleSpecTrafficPolicyProxyProtocol {
  /**
   * The PROXY protocol version to use.
   *
   * Valid Options: V1, V2
   *
   * @schema DestinationRuleSpecTrafficPolicyProxyProtocol#version
   */
  readonly version?: DestinationRuleSpecTrafficPolicyProxyProtocolVersion;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyProxyProtocol(obj: DestinationRuleSpecTrafficPolicyProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a limit on concurrent retries in relation to the number of active requests.
 *
 * @schema DestinationRuleSpecTrafficPolicyRetryBudget
 */
export interface DestinationRuleSpecTrafficPolicyRetryBudget {
  /**
   * Specifies the minimum retry concurrency allowed for the retry budget.
   *
   * @schema DestinationRuleSpecTrafficPolicyRetryBudget#minRetryConcurrency
   */
  readonly minRetryConcurrency?: number;

  /**
   * Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests.
   *
   * @schema DestinationRuleSpecTrafficPolicyRetryBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyRetryBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyRetryBudget(obj: DestinationRuleSpecTrafficPolicyRetryBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minRetryConcurrency': obj.minRetryConcurrency,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyTls
 */
export interface DestinationRuleSpecTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyTls(obj: DestinationRuleSpecTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleSpecTrafficPolicyTunnel
 */
export interface DestinationRuleSpecTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyTunnel(obj: DestinationRuleSpecTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(obj: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The upstream PROXY protocol settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol {
  /**
   * The PROXY protocol version to use.
   *
   * Valid Options: V1, V2
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol#version
   */
  readonly version?: DestinationRuleSpecSubsetsTrafficPolicyProxyProtocolVersion;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol(obj: DestinationRuleSpecSubsetsTrafficPolicyProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a limit on concurrent retries in relation to the number of active requests.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyRetryBudget
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyRetryBudget {
  /**
   * Specifies the minimum retry concurrency allowed for the retry budget.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyRetryBudget#minRetryConcurrency
   */
  readonly minRetryConcurrency?: number;

  /**
   * Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyRetryBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyRetryBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyRetryBudget(obj: DestinationRuleSpecSubsetsTrafficPolicyRetryBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minRetryConcurrency': obj.minRetryConcurrency,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyTls(obj: DestinationRuleSpecSubsetsTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyTunnel(obj: DestinationRuleSpecSubsetsTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolHttp(obj: DestinationRuleSpecTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcp(obj: DestinationRuleSpecTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerWarmup
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerWarmup(obj: DestinationRuleSpecTrafficPolicyLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The PROXY protocol version to use.
 *
 * Valid Options: V1, V2
 *
 * @schema DestinationRuleSpecTrafficPolicyProxyProtocolVersion
 */
export enum DestinationRuleSpecTrafficPolicyProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleSpecTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The PROXY protocol version to use.
 *
 * Valid Options: V1, V2
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyProxyProtocolVersion
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema DestinationRuleV1Alpha3
 */
export class DestinationRuleV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DestinationRuleV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'DestinationRule',
  }

  /**
   * Renders a Kubernetes manifest for "DestinationRuleV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DestinationRuleV1Alpha3Props = {}): any {
    return {
      ...DestinationRuleV1Alpha3.GVK,
      ...toJson_DestinationRuleV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "DestinationRuleV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DestinationRuleV1Alpha3Props = {}) {
    super(scope, id, {
      ...DestinationRuleV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DestinationRuleV1Alpha3.GVK,
      ...toJson_DestinationRuleV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema DestinationRuleV1Alpha3
 */
export interface DestinationRuleV1Alpha3Props {
  /**
   * @schema DestinationRuleV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRuleV1Alpha3#spec
   */
  readonly spec?: DestinationRuleV1Alpha3Spec;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3Props(obj: DestinationRuleV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DestinationRuleV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleV1Alpha3Spec
 */
export interface DestinationRuleV1Alpha3Spec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleV1Alpha3Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleV1Alpha3Spec#host
   */
  readonly host: string;

  /**
   * One or more named sets that represent individual versions of a service.
   *
   * @schema DestinationRuleV1Alpha3Spec#subsets
   */
  readonly subsets?: DestinationRuleV1Alpha3SpecSubsets[];

  /**
   * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
   *
   * @schema DestinationRuleV1Alpha3Spec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleV1Alpha3SpecTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
   *
   * @schema DestinationRuleV1Alpha3Spec#workloadSelector
   */
  readonly workloadSelector?: DestinationRuleV1Alpha3SpecWorkloadSelector;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3Spec(obj: DestinationRuleV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'host': obj.host,
    'subsets': obj.subsets?.map(y => toJson_DestinationRuleV1Alpha3SpecSubsets(y)),
    'trafficPolicy': toJson_DestinationRuleV1Alpha3SpecTrafficPolicy(obj.trafficPolicy),
    'workloadSelector': toJson_DestinationRuleV1Alpha3SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsets
 */
export interface DestinationRuleV1Alpha3SpecSubsets {
  /**
   * Labels apply a filter over the endpoints of a service in the service registry.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsets#name
   */
  readonly name: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsets(obj: DestinationRuleV1Alpha3SpecSubsets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'trafficPolicy': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy(obj.trafficPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicy
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicy {
  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings[];

  /**
   * The upstream PROXY protocol settings.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#proxyProtocol
   */
  readonly proxyProtocol?: DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol;

  /**
   * Specifies a limit on concurrent retries in relation to the number of active requests.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#retryBudget
   */
  readonly retryBudget?: DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleV1Alpha3SpecTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleV1Alpha3SpecTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicy(obj: DestinationRuleV1Alpha3SpecTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings(y)),
    'proxyProtocol': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol(obj.proxyProtocol),
    'retryBudget': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget(obj.retryBudget),
    'tls': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
 *
 * @schema DestinationRuleV1Alpha3SpecWorkloadSelector
 */
export interface DestinationRuleV1Alpha3SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema DestinationRuleV1Alpha3SpecWorkloadSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecWorkloadSelector(obj: DestinationRuleV1Alpha3SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * The upstream PROXY protocol settings.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#proxyProtocol
   */
  readonly proxyProtocol?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol;

  /**
   * Specifies a limit on concurrent retries in relation to the number of active requests.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#retryBudget
   */
  readonly retryBudget?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings(y)),
    'proxyProtocol': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol(obj.proxyProtocol),
    'retryBudget': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget(obj.retryBudget),
    'tls': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool(obj: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection(obj: DestinationRuleV1Alpha3SpecTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The upstream PROXY protocol settings.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol {
  /**
   * The PROXY protocol version to use.
   *
   * Valid Options: V1, V2
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol#version
   */
  readonly version?: DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocolVersion;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol(obj: DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a limit on concurrent retries in relation to the number of active requests.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget {
  /**
   * Specifies the minimum retry concurrency allowed for the retry budget.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget#minRetryConcurrency
   */
  readonly minRetryConcurrency?: number;

  /**
   * Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget(obj: DestinationRuleV1Alpha3SpecTrafficPolicyRetryBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minRetryConcurrency': obj.minRetryConcurrency,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleV1Alpha3SpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyTls(obj: DestinationRuleV1Alpha3SpecTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTunnel
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyTunnel(obj: DestinationRuleV1Alpha3SpecTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The upstream PROXY protocol settings.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol {
  /**
   * The PROXY protocol version to use.
   *
   * Valid Options: V1, V2
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol#version
   */
  readonly version?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocolVersion;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a limit on concurrent retries in relation to the number of active requests.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget {
  /**
   * Specifies the minimum retry concurrency allowed for the retry budget.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget#minRetryConcurrency
   */
  readonly minRetryConcurrency?: number;

  /**
   * Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyRetryBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minRetryConcurrency': obj.minRetryConcurrency,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp(obj: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp(obj: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The PROXY protocol version to use.
 *
 * Valid Options: V1, V2
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocolVersion
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyTlsMode
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The PROXY protocol version to use.
 *
 * Valid Options: V1, V2
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocolVersion
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Alpha3SpecTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Alpha3SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Alpha3SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Alpha3SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema DestinationRuleV1Beta1
 */
export class DestinationRuleV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DestinationRuleV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'DestinationRule',
  }

  /**
   * Renders a Kubernetes manifest for "DestinationRuleV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DestinationRuleV1Beta1Props = {}): any {
    return {
      ...DestinationRuleV1Beta1.GVK,
      ...toJson_DestinationRuleV1Beta1Props(props),
    };
  }

  /**
   * Defines a "DestinationRuleV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DestinationRuleV1Beta1Props = {}) {
    super(scope, id, {
      ...DestinationRuleV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...DestinationRuleV1Beta1.GVK,
      ...toJson_DestinationRuleV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema DestinationRuleV1Beta1
 */
export interface DestinationRuleV1Beta1Props {
  /**
   * @schema DestinationRuleV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRuleV1Beta1#spec
   */
  readonly spec?: DestinationRuleV1Beta1Spec;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1Props(obj: DestinationRuleV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DestinationRuleV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleV1Beta1Spec
 */
export interface DestinationRuleV1Beta1Spec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleV1Beta1Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleV1Beta1Spec#host
   */
  readonly host: string;

  /**
   * One or more named sets that represent individual versions of a service.
   *
   * @schema DestinationRuleV1Beta1Spec#subsets
   */
  readonly subsets?: DestinationRuleV1Beta1SpecSubsets[];

  /**
   * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
   *
   * @schema DestinationRuleV1Beta1Spec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleV1Beta1SpecTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
   *
   * @schema DestinationRuleV1Beta1Spec#workloadSelector
   */
  readonly workloadSelector?: DestinationRuleV1Beta1SpecWorkloadSelector;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1Spec(obj: DestinationRuleV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'host': obj.host,
    'subsets': obj.subsets?.map(y => toJson_DestinationRuleV1Beta1SpecSubsets(y)),
    'trafficPolicy': toJson_DestinationRuleV1Beta1SpecTrafficPolicy(obj.trafficPolicy),
    'workloadSelector': toJson_DestinationRuleV1Beta1SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsets
 */
export interface DestinationRuleV1Beta1SpecSubsets {
  /**
   * Labels apply a filter over the endpoints of a service in the service registry.
   *
   * @schema DestinationRuleV1Beta1SpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleV1Beta1SpecSubsets#name
   */
  readonly name: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleV1Beta1SpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicy;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsets(obj: DestinationRuleV1Beta1SpecSubsets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'trafficPolicy': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicy(obj.trafficPolicy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicy
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicy {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings[];

  /**
   * The upstream PROXY protocol settings.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#proxyProtocol
   */
  readonly proxyProtocol?: DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol;

  /**
   * Specifies a limit on concurrent retries in relation to the number of active requests.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#retryBudget
   */
  readonly retryBudget?: DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleV1Beta1SpecTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicy(obj: DestinationRuleV1Beta1SpecTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings(y)),
    'proxyProtocol': toJson_DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol(obj.proxyProtocol),
    'retryBudget': toJson_DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget(obj.retryBudget),
    'tls': toJson_DestinationRuleV1Beta1SpecTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleV1Beta1SpecTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.
 *
 * @schema DestinationRuleV1Beta1SpecWorkloadSelector
 */
export interface DestinationRuleV1Beta1SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema DestinationRuleV1Beta1SpecWorkloadSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecWorkloadSelector(obj: DestinationRuleV1Beta1SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * The upstream PROXY protocol settings.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#proxyProtocol
   */
  readonly proxyProtocol?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol;

  /**
   * Specifies a limit on concurrent retries in relation to the number of active requests.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#retryBudget
   */
  readonly retryBudget?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls;

  /**
   * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicy#tunnel
   */
  readonly tunnel?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicy(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection(obj.outlierDetection),
    'portLevelSettings': obj.portLevelSettings?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings(y)),
    'proxyProtocol': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol(obj.proxyProtocol),
    'retryBudget': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget(obj.retryBudget),
    'tls': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls(obj.tls),
    'tunnel': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel(obj.tunnel),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection(obj: DestinationRuleV1Beta1SpecTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The upstream PROXY protocol settings.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol {
  /**
   * The PROXY protocol version to use.
   *
   * Valid Options: V1, V2
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol#version
   */
  readonly version?: DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocolVersion;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol(obj: DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a limit on concurrent retries in relation to the number of active requests.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget {
  /**
   * Specifies the minimum retry concurrency allowed for the retry budget.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget#minRetryConcurrency
   */
  readonly minRetryConcurrency?: number;

  /**
   * Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget(obj: DestinationRuleV1Beta1SpecTrafficPolicyRetryBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minRetryConcurrency': obj.minRetryConcurrency,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyTls(obj: DestinationRuleV1Beta1SpecTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyTunnel(obj: DestinationRuleV1Beta1SpecTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * Specifies the number of a port on the destination service on which this policy is being applied.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionPool': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj.connectionPool),
    'loadBalancer': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj.loadBalancer),
    'outlierDetection': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj.outlierDetection),
    'port': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort(obj.port),
    'tls': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The upstream PROXY protocol settings.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol {
  /**
   * The PROXY protocol version to use.
   *
   * Valid Options: V1, V2
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol#version
   */
  readonly version?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocolVersion;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocol | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies a limit on concurrent retries in relation to the number of active requests.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget {
  /**
   * Specifies the minimum retry concurrency allowed for the retry budget.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget#minRetryConcurrency
   */
  readonly minRetryConcurrency?: number;

  /**
   * Specifies the limit on concurrent retries as a percentage of the sum of active requests and active pending requests.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyRetryBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minRetryConcurrency': obj.minRetryConcurrency,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel {
  /**
   * Specifies which protocol to use for tunneling the downstream connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel#protocol
   */
  readonly protocol?: string;

  /**
   * Specifies a host to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel#targetHost
   */
  readonly targetHost: string;

  /**
   * Specifies a port to which the downstream connection is tunneled.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel#targetPort
   */
  readonly targetPort: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTunnel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
    'targetHost': obj.targetHost,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The PROXY protocol version to use.
 *
 * Valid Options: V1, V2
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocolVersion
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyTlsMode
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj.http),
    'tcp': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   *
   *
   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;

  /**
   * Represents the warmup configuration of Service.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmup
   */
  readonly warmup?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup;

  /**
   * Deprecated: use `warmup` instead.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#warmupDurationSecs
   */
  readonly warmupDurationSecs?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consistentHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj.consistentHash),
    'localityLbSetting': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj.localityLbSetting),
    'simple': obj.simple,
    'warmup': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj.warmup),
    'warmupDurationSecs': obj.warmupDurationSecs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5XxErrors?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * The number of consecutive locally originated failures before ejection occurs.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveLocalOriginFailures
   */
  readonly consecutiveLocalOriginFailures?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * Outlier detection will be enabled as long as the associated load balancing pool has at least `minHealthPercent` hosts in healthy mode.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

  /**
   * Determines whether to distinguish local origin failures from external errors.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#splitExternalLocalOriginErrors
   */
  readonly splitExternalLocalOriginErrors?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseEjectionTime': obj.baseEjectionTime,
    'consecutive5xxErrors': obj.consecutive5XxErrors,
    'consecutiveErrors': obj.consecutiveErrors,
    'consecutiveGatewayErrors': obj.consecutiveGatewayErrors,
    'consecutiveLocalOriginFailures': obj.consecutiveLocalOriginFailures,
    'interval': obj.interval,
    'maxEjectionPercent': obj.maxEjectionPercent,
    'minHealthPercent': obj.minHealthPercent,
    'splitExternalLocalOriginErrors': obj.splitExternalLocalOriginErrors,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the number of a port on the destination service on which this policy is being applied.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented server certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * The name of the secret that holds the TLS certs for the client including the CA certificates.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#insecureSkipVerify
   */
  readonly insecureSkipVerify?: boolean;

  /**
   * Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'clientCertificate': obj.clientCertificate,
    'credentialName': obj.credentialName,
    'insecureSkipVerify': obj.insecureSkipVerify,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'sni': obj.sni,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The PROXY protocol version to use.
 *
 * Valid Options: V1, V2
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocolVersion
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyProxyProtocolVersion {
  /** V1 */
  V1 = "V1",
  /** V2 */
  V2 = "V2",
}

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * The Maglev load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#maglev
   */
  readonly maglev?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev;

  /**
   * Deprecated.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#ringHash
   */
  readonly ringHash?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpCookie': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj.httpCookie),
    'httpHeaderName': obj.httpHeaderName,
    'httpQueryParameterName': obj.httpQueryParameterName,
    'maglev': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj.maglev),
    'minimumRingSize': obj.minimumRingSize,
    'ringHash': toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj.ringHash),
    'useSourceIp': obj.useSourceIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * Enable locality load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only one of distribute, failover or failoverPriority can be set.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

  /**
   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failoverPriority
   */
  readonly failoverPriority?: string[];

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distribute': obj.distribute?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(y)),
    'enabled': obj.enabled,
    'failover': obj.failover?.map(y => toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(y)),
    'failoverPriority': obj.failoverPriority?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** LEAST_CONN */
  LEAST_UNDERSCORE_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** ROUND_ROBIN */
  ROUND_UNDERSCORE_ROBIN = "ROUND_ROBIN",
  /** LEAST_REQUEST */
  LEAST_UNDERSCORE_REQUEST = "LEAST_REQUEST",
}

/**
 * Represents the warmup configuration of Service.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup {
  /**
   * This parameter controls the speed of traffic increase over the warmup duration.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#aggression
   */
  readonly aggression?: number;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#duration
   */
  readonly duration: string;

  /**
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup#minimumPercent
   */
  readonly minimumPercent?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerWarmup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggression': obj.aggression,
    'duration': obj.duration,
    'minimumPercent': obj.minimumPercent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Maglev load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev {
  /**
   * The table size for Maglev hashing.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev#tableSize
   */
  readonly tableSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashMaglev | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'tableSize': obj.tableSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The ring/modulo hash load balancer implements consistent hashing to backend hosts.
 *
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash {
  /**
   * The minimum number of virtual nodes to use for the hash ring.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashRingHash | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumRingSize': obj.minimumRingSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': ((obj.to) === undefined) ? undefined : (Object.entries(obj.to).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
   *
   * @schema DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Converts an object of type 'DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover(obj: DestinationRuleV1Beta1SpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'from': obj.from,
    'to': obj.to,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema EnvoyFilter
 */
export class EnvoyFilter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EnvoyFilter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'EnvoyFilter',
  }

  /**
   * Renders a Kubernetes manifest for "EnvoyFilter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvoyFilterProps = {}): any {
    return {
      ...EnvoyFilter.GVK,
      ...toJson_EnvoyFilterProps(props),
    };
  }

  /**
   * Defines a "EnvoyFilter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvoyFilterProps = {}) {
    super(scope, id, {
      ...EnvoyFilter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...EnvoyFilter.GVK,
      ...toJson_EnvoyFilterProps(resolved),
    };
  }
}

/**
 * @schema EnvoyFilter
 */
export interface EnvoyFilterProps {
  /**
   * @schema EnvoyFilter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
   *
   * @schema EnvoyFilter#spec
   */
  readonly spec?: EnvoyFilterSpec;

}

/**
 * Converts an object of type 'EnvoyFilterProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterProps(obj: EnvoyFilterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvoyFilterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
 *
 * @schema EnvoyFilterSpec
 */
export interface EnvoyFilterSpec {
  /**
   * One or more patches with match conditions.
   *
   * @schema EnvoyFilterSpec#configPatches
   */
  readonly configPatches?: EnvoyFilterSpecConfigPatches[];

  /**
   * Priority defines the order in which patch sets are applied within a context.
   *
   * @schema EnvoyFilterSpec#priority
   */
  readonly priority?: number;

  /**
   * Optional.
   *
   * @schema EnvoyFilterSpec#targetRefs
   */
  readonly targetRefs?: EnvoyFilterSpecTargetRefs[];

  /**
   * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
   *
   * @schema EnvoyFilterSpec#workloadSelector
   */
  readonly workloadSelector?: EnvoyFilterSpecWorkloadSelector;

}

/**
 * Converts an object of type 'EnvoyFilterSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpec(obj: EnvoyFilterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configPatches': obj.configPatches?.map(y => toJson_EnvoyFilterSpecConfigPatches(y)),
    'priority': obj.priority,
    'targetRefs': obj.targetRefs?.map(y => toJson_EnvoyFilterSpecTargetRefs(y)),
    'workloadSelector': toJson_EnvoyFilterSpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyFilterSpecConfigPatches
 */
export interface EnvoyFilterSpecConfigPatches {
  /**
   * Specifies where in the Envoy configuration, the patch should be applied.
   *
   * Valid Options: LISTENER, FILTER_CHAIN, NETWORK_FILTER, HTTP_FILTER, ROUTE_CONFIGURATION, VIRTUAL_HOST, HTTP_ROUTE, CLUSTER, EXTENSION_CONFIG, BOOTSTRAP, LISTENER_FILTER
   *
   * @schema EnvoyFilterSpecConfigPatches#applyTo
   */
  readonly applyTo?: EnvoyFilterSpecConfigPatchesApplyTo;

  /**
   * Match on listener/route configuration/cluster.
   *
   * @schema EnvoyFilterSpecConfigPatches#match
   */
  readonly match?: EnvoyFilterSpecConfigPatchesMatch;

  /**
   * The patch to apply along with the operation.
   *
   * @schema EnvoyFilterSpecConfigPatches#patch
   */
  readonly patch?: EnvoyFilterSpecConfigPatchesPatch;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatches(obj: EnvoyFilterSpecConfigPatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyTo': obj.applyTo,
    'match': toJson_EnvoyFilterSpecConfigPatchesMatch(obj.match),
    'patch': toJson_EnvoyFilterSpecConfigPatchesPatch(obj.patch),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvoyFilterSpecTargetRefs
 */
export interface EnvoyFilterSpecTargetRefs {
  /**
   * group is the group of the target resource.
   *
   * @schema EnvoyFilterSpecTargetRefs#group
   */
  readonly group?: string;

  /**
   * kind is kind of the target resource.
   *
   * @schema EnvoyFilterSpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * name is the name of the target resource.
   *
   * @schema EnvoyFilterSpecTargetRefs#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the referent.
   *
   * @schema EnvoyFilterSpecTargetRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecTargetRefs(obj: EnvoyFilterSpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this patch configuration should be applied.
 *
 * @schema EnvoyFilterSpecWorkloadSelector
 */
export interface EnvoyFilterSpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema EnvoyFilterSpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'EnvoyFilterSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecWorkloadSelector(obj: EnvoyFilterSpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies where in the Envoy configuration, the patch should be applied.
 *
 * Valid Options: LISTENER, FILTER_CHAIN, NETWORK_FILTER, HTTP_FILTER, ROUTE_CONFIGURATION, VIRTUAL_HOST, HTTP_ROUTE, CLUSTER, EXTENSION_CONFIG, BOOTSTRAP, LISTENER_FILTER
 *
 * @schema EnvoyFilterSpecConfigPatchesApplyTo
 */
export enum EnvoyFilterSpecConfigPatchesApplyTo {
  /** INVALID */
  INVALID = "INVALID",
  /** LISTENER */
  LISTENER = "LISTENER",
  /** FILTER_CHAIN */
  FILTER_UNDERSCORE_CHAIN = "FILTER_CHAIN",
  /** NETWORK_FILTER */
  NETWORK_UNDERSCORE_FILTER = "NETWORK_FILTER",
  /** HTTP_FILTER */
  HTTP_UNDERSCORE_FILTER = "HTTP_FILTER",
  /** ROUTE_CONFIGURATION */
  ROUTE_UNDERSCORE_CONFIGURATION = "ROUTE_CONFIGURATION",
  /** VIRTUAL_HOST */
  VIRTUAL_UNDERSCORE_HOST = "VIRTUAL_HOST",
  /** HTTP_ROUTE */
  HTTP_UNDERSCORE_ROUTE = "HTTP_ROUTE",
  /** CLUSTER */
  CLUSTER = "CLUSTER",
  /** EXTENSION_CONFIG */
  EXTENSION_UNDERSCORE_CONFIG = "EXTENSION_CONFIG",
  /** BOOTSTRAP */
  BOOTSTRAP = "BOOTSTRAP",
  /** LISTENER_FILTER */
  LISTENER_UNDERSCORE_FILTER = "LISTENER_FILTER",
}

/**
 * Match on listener/route configuration/cluster.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatch
 */
export interface EnvoyFilterSpecConfigPatchesMatch {
  /**
   * Match on envoy cluster attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#cluster
   */
  readonly cluster?: EnvoyFilterSpecConfigPatchesMatchCluster;

  /**
   * The specific config generation context to match on.
   *
   * Valid Options: ANY, SIDECAR_INBOUND, SIDECAR_OUTBOUND, GATEWAY
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#context
   */
  readonly context?: EnvoyFilterSpecConfigPatchesMatchContext;

  /**
   * Match on envoy listener attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#listener
   */
  readonly listener?: EnvoyFilterSpecConfigPatchesMatchListener;

  /**
   * Match on properties associated with a proxy.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#proxy
   */
  readonly proxy?: EnvoyFilterSpecConfigPatchesMatchProxy;

  /**
   * Match on envoy HTTP route configuration attributes.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatch#routeConfiguration
   */
  readonly routeConfiguration?: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatch(obj: EnvoyFilterSpecConfigPatchesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster': toJson_EnvoyFilterSpecConfigPatchesMatchCluster(obj.cluster),
    'context': obj.context,
    'listener': toJson_EnvoyFilterSpecConfigPatchesMatchListener(obj.listener),
    'proxy': toJson_EnvoyFilterSpecConfigPatchesMatchProxy(obj.proxy),
    'routeConfiguration': toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(obj.routeConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The patch to apply along with the operation.
 *
 * @schema EnvoyFilterSpecConfigPatchesPatch
 */
export interface EnvoyFilterSpecConfigPatchesPatch {
  /**
   * Determines the filter insertion order.
   *
   * Valid Options: AUTHN, AUTHZ, STATS
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#filterClass
   */
  readonly filterClass?: EnvoyFilterSpecConfigPatchesPatchFilterClass;

  /**
   * Determines how the patch should be applied.
   *
   * Valid Options: MERGE, ADD, REMOVE, INSERT_BEFORE, INSERT_AFTER, INSERT_FIRST, REPLACE
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#operation
   */
  readonly operation?: EnvoyFilterSpecConfigPatchesPatchOperation;

  /**
   * The JSON config of the object being patched.
   *
   * @schema EnvoyFilterSpecConfigPatchesPatch#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesPatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesPatch(obj: EnvoyFilterSpecConfigPatchesPatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterClass': obj.filterClass,
    'operation': obj.operation,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match on envoy cluster attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchCluster
 */
export interface EnvoyFilterSpecConfigPatchesMatchCluster {
  /**
   * The exact name of the cluster to match.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#name
   */
  readonly name?: string;

  /**
   * The service port for which this cluster was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#portNumber
   */
  readonly portNumber?: number;

  /**
   * The fully qualified service name for this cluster.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#service
   */
  readonly service?: string;

  /**
   * The subset associated with the service.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchCluster#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchCluster' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchCluster(obj: EnvoyFilterSpecConfigPatchesMatchCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'portNumber': obj.portNumber,
    'service': obj.service,
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The specific config generation context to match on.
 *
 * Valid Options: ANY, SIDECAR_INBOUND, SIDECAR_OUTBOUND, GATEWAY
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchContext
 */
export enum EnvoyFilterSpecConfigPatchesMatchContext {
  /** ANY */
  ANY = "ANY",
  /** SIDECAR_INBOUND */
  SIDECAR_UNDERSCORE_INBOUND = "SIDECAR_INBOUND",
  /** SIDECAR_OUTBOUND */
  SIDECAR_UNDERSCORE_OUTBOUND = "SIDECAR_OUTBOUND",
  /** GATEWAY */
  GATEWAY = "GATEWAY",
}

/**
 * Match on envoy listener attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListener
 */
export interface EnvoyFilterSpecConfigPatchesMatchListener {
  /**
   * Match a specific filter chain in a listener.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#filterChain
   */
  readonly filterChain?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain;

  /**
   * Match a specific listener filter.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#listenerFilter
   */
  readonly listenerFilter?: string;

  /**
   * Match a specific listener by its name.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#name
   */
  readonly name?: string;

  /**
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#portName
   */
  readonly portName?: string;

  /**
   * The service port/gateway port to which traffic is being sent/received.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListener#portNumber
   */
  readonly portNumber?: number;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListener' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListener(obj: EnvoyFilterSpecConfigPatchesMatchListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filterChain': toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(obj.filterChain),
    'listenerFilter': obj.listenerFilter,
    'name': obj.name,
    'portName': obj.portName,
    'portNumber': obj.portNumber,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match on properties associated with a proxy.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchProxy
 */
export interface EnvoyFilterSpecConfigPatchesMatchProxy {
  /**
   * Match on the node metadata supplied by a proxy when connecting to istiod.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchProxy#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * A regular expression in golang regex format (RE2) that can be used to select proxies using a specific version of istio proxy.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchProxy#proxyVersion
   */
  readonly proxyVersion?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchProxy(obj: EnvoyFilterSpecConfigPatchesMatchProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'proxyVersion': obj.proxyVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match on envoy HTTP route configuration attributes.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfiguration {
  /**
   * The Istio gateway config's namespace/name for which this route configuration was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#gateway
   */
  readonly gateway?: string;

  /**
   * Route configuration name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#name
   */
  readonly name?: string;

  /**
   * Applicable only for GATEWAY context.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portName
   */
  readonly portName?: string;

  /**
   * The service port number or gateway server port number for which this route configuration was generated.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#portNumber
   */
  readonly portNumber?: number;

  /**
   * Match a specific virtual host in a route configuration and apply the patch to the virtual host.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfiguration#vhost
   */
  readonly vhost?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfiguration' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfiguration(obj: EnvoyFilterSpecConfigPatchesMatchRouteConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gateway': obj.gateway,
    'name': obj.name,
    'portName': obj.portName,
    'portNumber': obj.portNumber,
    'vhost': toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(obj.vhost),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Determines the filter insertion order.
 *
 * Valid Options: AUTHN, AUTHZ, STATS
 *
 * @schema EnvoyFilterSpecConfigPatchesPatchFilterClass
 */
export enum EnvoyFilterSpecConfigPatchesPatchFilterClass {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** AUTHN */
  AUTHN = "AUTHN",
  /** AUTHZ */
  AUTHZ = "AUTHZ",
  /** STATS */
  STATS = "STATS",
}

/**
 * Determines how the patch should be applied.
 *
 * Valid Options: MERGE, ADD, REMOVE, INSERT_BEFORE, INSERT_AFTER, INSERT_FIRST, REPLACE
 *
 * @schema EnvoyFilterSpecConfigPatchesPatchOperation
 */
export enum EnvoyFilterSpecConfigPatchesPatchOperation {
  /** INVALID */
  INVALID = "INVALID",
  /** MERGE */
  MERGE = "MERGE",
  /** ADD */
  ADD = "ADD",
  /** REMOVE */
  REMOVE = "REMOVE",
  /** INSERT_BEFORE */
  INSERT_UNDERSCORE_BEFORE = "INSERT_BEFORE",
  /** INSERT_AFTER */
  INSERT_UNDERSCORE_AFTER = "INSERT_AFTER",
  /** INSERT_FIRST */
  INSERT_UNDERSCORE_FIRST = "INSERT_FIRST",
  /** REPLACE */
  REPLACE = "REPLACE",
}

/**
 * Match a specific filter chain in a listener.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChain {
  /**
   * Applies only to sidecars.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#applicationProtocols
   */
  readonly applicationProtocols?: string;

  /**
   * The destination_port value used by a filter chain's match condition.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#destinationPort
   */
  readonly destinationPort?: number;

  /**
   * The name of a specific filter to apply the patch to.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#filter
   */
  readonly filter?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter;

  /**
   * The name assigned to the filter chain.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#name
   */
  readonly name?: string;

  /**
   * The SNI value used by a filter chain's match condition.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#sni
   */
  readonly sni?: string;

  /**
   * Applies only to `SIDECAR_INBOUND` context.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChain#transportProtocol
   */
  readonly transportProtocol?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChain' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChain(obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChain | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationProtocols': obj.applicationProtocols,
    'destinationPort': obj.destinationPort,
    'filter': toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(obj.filter),
    'name': obj.name,
    'sni': obj.sni,
    'transportProtocol': obj.transportProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match a specific virtual host in a route configuration and apply the patch to the virtual host.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost {
  /**
   * Match a domain name in a virtual host.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#domainName
   */
  readonly domainName?: string;

  /**
   * The VirtualHosts objects generated by Istio are named as host:port, where the host typically corresponds to the VirtualService's host field or the hostname of a service in the registry.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#name
   */
  readonly name?: string;

  /**
   * Match a specific route within the virtual host.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost#route
   */
  readonly route?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost(obj: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainName': obj.domainName,
    'name': obj.name,
    'route': toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(obj.route),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The name of a specific filter to apply the patch to.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter {
  /**
   * The filter name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#name
   */
  readonly name?: string;

  /**
   * The next level filter within this filter to match upon.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter#subFilter
   */
  readonly subFilter?: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter(obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'subFilter': toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(obj.subFilter),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match a specific route within the virtual host.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute
 */
export interface EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute {
  /**
   * Match a route with specific action type.
   *
   * Valid Options: ANY, ROUTE, REDIRECT, DIRECT_RESPONSE
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#action
   */
  readonly action?: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction;

  /**
   * The Route objects generated by default are named as default.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute(obj: EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The next level filter within this filter to match upon.
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter
 */
export interface EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter {
  /**
   * The filter name to match on.
   *
   * @schema EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter(obj: EnvoyFilterSpecConfigPatchesMatchListenerFilterChainFilterSubFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Match a route with specific action type.
 *
 * Valid Options: ANY, ROUTE, REDIRECT, DIRECT_RESPONSE
 *
 * @schema EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction
 */
export enum EnvoyFilterSpecConfigPatchesMatchRouteConfigurationVhostRouteAction {
  /** ANY */
  ANY = "ANY",
  /** ROUTE */
  ROUTE = "ROUTE",
  /** REDIRECT */
  REDIRECT = "REDIRECT",
  /** DIRECT_RESPONSE */
  DIRECT_UNDERSCORE_RESPONSE = "DIRECT_RESPONSE",
}


/**
 *
 *
 * @schema Gateway
 */
export class Gateway extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Gateway"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'Gateway',
  }

  /**
   * Renders a Kubernetes manifest for "Gateway".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayProps = {}): any {
    return {
      ...Gateway.GVK,
      ...toJson_GatewayProps(props),
    };
  }

  /**
   * Defines a "Gateway" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayProps = {}) {
    super(scope, id, {
      ...Gateway.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Gateway.GVK,
      ...toJson_GatewayProps(resolved),
    };
  }
}

/**
 * @schema Gateway
 */
export interface GatewayProps {
  /**
   * @schema Gateway#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
   *
   * @schema Gateway#spec
   */
  readonly spec?: GatewaySpec;

}

/**
 * Converts an object of type 'GatewayProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayProps(obj: GatewayProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewaySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
 *
 * @schema GatewaySpec
 */
export interface GatewaySpec {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
   *
   * @schema GatewaySpec#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * A list of server specifications.
   *
   * @schema GatewaySpec#servers
   */
  readonly servers?: GatewaySpecServers[];

}

/**
 * Converts an object of type 'GatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpec(obj: GatewaySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'servers': obj.servers?.map(y => toJson_GatewaySpecServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GatewaySpecServers
 */
export interface GatewaySpecServers {
  /**
   * The ip or the Unix domain socket to which the listener should be bound to.
   *
   * @schema GatewaySpecServers#bind
   */
  readonly bind?: string;

  /**
   * @schema GatewaySpecServers#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * One or more hosts exposed by this gateway.
   *
   * @schema GatewaySpecServers#hosts
   */
  readonly hosts: string[];

  /**
   * An optional name of the server, when set must be unique across all servers.
   *
   * @schema GatewaySpecServers#name
   */
  readonly name?: string;

  /**
   * The Port on which the proxy should listen for incoming connections.
   *
   * @schema GatewaySpecServers#port
   */
  readonly port: GatewaySpecServersPort;

  /**
   * Set of TLS related options that govern the server's behavior.
   *
   * @schema GatewaySpecServers#tls
   */
  readonly tls?: GatewaySpecServersTls;

}

/**
 * Converts an object of type 'GatewaySpecServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecServers(obj: GatewaySpecServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'defaultEndpoint': obj.defaultEndpoint,
    'hosts': obj.hosts?.map(y => y),
    'name': obj.name,
    'port': toJson_GatewaySpecServersPort(obj.port),
    'tls': toJson_GatewaySpecServersTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Port on which the proxy should listen for incoming connections.
 *
 * @schema GatewaySpecServersPort
 */
export interface GatewaySpecServersPort {
  /**
   * Label assigned to the port.
   *
   * @schema GatewaySpecServersPort#name
   */
  readonly name: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema GatewaySpecServersPort#number
   */
  readonly number: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema GatewaySpecServersPort#protocol
   */
  readonly protocol: string;

  /**
   * @schema GatewaySpecServersPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'GatewaySpecServersPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecServersPort(obj: GatewaySpecServersPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set of TLS related options that govern the server's behavior.
 *
 * @schema GatewaySpecServersTls
 */
export interface GatewaySpecServersTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema GatewaySpecServersTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
   *
   * @schema GatewaySpecServersTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema GatewaySpecServersTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema GatewaySpecServersTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * Same as CredentialName but for multiple certificates.
   *
   * @schema GatewaySpecServersTls#credentialNames
   */
  readonly credentialNames?: string[];

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema GatewaySpecServersTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema GatewaySpecServersTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: GatewaySpecServersTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema GatewaySpecServersTls#minProtocolVersion
   */
  readonly minProtocolVersion?: GatewaySpecServersTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
   *
   * @schema GatewaySpecServersTls#mode
   */
  readonly mode?: GatewaySpecServersTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewaySpecServersTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewaySpecServersTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema GatewaySpecServersTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Only one of `server_certificate`, `private_key` or `credential_name` or `credential_names` or `tls_certificates` should be specified.
   *
   * @schema GatewaySpecServersTls#tlsCertificates
   */
  readonly tlsCertificates?: GatewaySpecServersTlsTlsCertificates[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema GatewaySpecServersTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema GatewaySpecServersTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'GatewaySpecServersTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecServersTls(obj: GatewaySpecServersTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'credentialNames': obj.credentialNames?.map(y => y),
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'tlsCertificates': obj.tlsCertificates?.map(y => toJson_GatewaySpecServersTlsTlsCertificates(y)),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema GatewaySpecServersTlsMaxProtocolVersion
 */
export enum GatewaySpecServersTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema GatewaySpecServersTlsMinProtocolVersion
 */
export enum GatewaySpecServersTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
 *
 * @schema GatewaySpecServersTlsMode
 */
export enum GatewaySpecServersTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * @schema GatewaySpecServersTlsTlsCertificates
 */
export interface GatewaySpecServersTlsTlsCertificates {
  /**
   * @schema GatewaySpecServersTlsTlsCertificates#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewaySpecServersTlsTlsCertificates#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewaySpecServersTlsTlsCertificates#serverCertificate
   */
  readonly serverCertificate?: string;

}

/**
 * Converts an object of type 'GatewaySpecServersTlsTlsCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecServersTlsTlsCertificates(obj: GatewaySpecServersTlsTlsCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema GatewayV1Alpha3
 */
export class GatewayV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'Gateway',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayV1Alpha3Props = {}): any {
    return {
      ...GatewayV1Alpha3.GVK,
      ...toJson_GatewayV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "GatewayV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayV1Alpha3Props = {}) {
    super(scope, id, {
      ...GatewayV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayV1Alpha3.GVK,
      ...toJson_GatewayV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema GatewayV1Alpha3
 */
export interface GatewayV1Alpha3Props {
  /**
   * @schema GatewayV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
   *
   * @schema GatewayV1Alpha3#spec
   */
  readonly spec?: GatewayV1Alpha3Spec;

}

/**
 * Converts an object of type 'GatewayV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Alpha3Props(obj: GatewayV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
 *
 * @schema GatewayV1Alpha3Spec
 */
export interface GatewayV1Alpha3Spec {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
   *
   * @schema GatewayV1Alpha3Spec#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * A list of server specifications.
   *
   * @schema GatewayV1Alpha3Spec#servers
   */
  readonly servers?: GatewayV1Alpha3SpecServers[];

}

/**
 * Converts an object of type 'GatewayV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Alpha3Spec(obj: GatewayV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'servers': obj.servers?.map(y => toJson_GatewayV1Alpha3SpecServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GatewayV1Alpha3SpecServers
 */
export interface GatewayV1Alpha3SpecServers {
  /**
   * The ip or the Unix domain socket to which the listener should be bound to.
   *
   * @schema GatewayV1Alpha3SpecServers#bind
   */
  readonly bind?: string;

  /**
   * @schema GatewayV1Alpha3SpecServers#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * One or more hosts exposed by this gateway.
   *
   * @schema GatewayV1Alpha3SpecServers#hosts
   */
  readonly hosts: string[];

  /**
   * An optional name of the server, when set must be unique across all servers.
   *
   * @schema GatewayV1Alpha3SpecServers#name
   */
  readonly name?: string;

  /**
   * The Port on which the proxy should listen for incoming connections.
   *
   * @schema GatewayV1Alpha3SpecServers#port
   */
  readonly port: GatewayV1Alpha3SpecServersPort;

  /**
   * Set of TLS related options that govern the server's behavior.
   *
   * @schema GatewayV1Alpha3SpecServers#tls
   */
  readonly tls?: GatewayV1Alpha3SpecServersTls;

}

/**
 * Converts an object of type 'GatewayV1Alpha3SpecServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Alpha3SpecServers(obj: GatewayV1Alpha3SpecServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'defaultEndpoint': obj.defaultEndpoint,
    'hosts': obj.hosts?.map(y => y),
    'name': obj.name,
    'port': toJson_GatewayV1Alpha3SpecServersPort(obj.port),
    'tls': toJson_GatewayV1Alpha3SpecServersTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Port on which the proxy should listen for incoming connections.
 *
 * @schema GatewayV1Alpha3SpecServersPort
 */
export interface GatewayV1Alpha3SpecServersPort {
  /**
   * Label assigned to the port.
   *
   * @schema GatewayV1Alpha3SpecServersPort#name
   */
  readonly name: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema GatewayV1Alpha3SpecServersPort#number
   */
  readonly number: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema GatewayV1Alpha3SpecServersPort#protocol
   */
  readonly protocol: string;

  /**
   * @schema GatewayV1Alpha3SpecServersPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'GatewayV1Alpha3SpecServersPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Alpha3SpecServersPort(obj: GatewayV1Alpha3SpecServersPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set of TLS related options that govern the server's behavior.
 *
 * @schema GatewayV1Alpha3SpecServersTls
 */
export interface GatewayV1Alpha3SpecServersTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema GatewayV1Alpha3SpecServersTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
   *
   * @schema GatewayV1Alpha3SpecServersTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema GatewayV1Alpha3SpecServersTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema GatewayV1Alpha3SpecServersTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * Same as CredentialName but for multiple certificates.
   *
   * @schema GatewayV1Alpha3SpecServersTls#credentialNames
   */
  readonly credentialNames?: string[];

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema GatewayV1Alpha3SpecServersTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema GatewayV1Alpha3SpecServersTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: GatewayV1Alpha3SpecServersTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema GatewayV1Alpha3SpecServersTls#minProtocolVersion
   */
  readonly minProtocolVersion?: GatewayV1Alpha3SpecServersTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
   *
   * @schema GatewayV1Alpha3SpecServersTls#mode
   */
  readonly mode?: GatewayV1Alpha3SpecServersTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Alpha3SpecServersTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Alpha3SpecServersTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema GatewayV1Alpha3SpecServersTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Only one of `server_certificate`, `private_key` or `credential_name` or `credential_names` or `tls_certificates` should be specified.
   *
   * @schema GatewayV1Alpha3SpecServersTls#tlsCertificates
   */
  readonly tlsCertificates?: GatewayV1Alpha3SpecServersTlsTlsCertificates[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema GatewayV1Alpha3SpecServersTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema GatewayV1Alpha3SpecServersTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'GatewayV1Alpha3SpecServersTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Alpha3SpecServersTls(obj: GatewayV1Alpha3SpecServersTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'credentialNames': obj.credentialNames?.map(y => y),
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'tlsCertificates': obj.tlsCertificates?.map(y => toJson_GatewayV1Alpha3SpecServersTlsTlsCertificates(y)),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema GatewayV1Alpha3SpecServersTlsMaxProtocolVersion
 */
export enum GatewayV1Alpha3SpecServersTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema GatewayV1Alpha3SpecServersTlsMinProtocolVersion
 */
export enum GatewayV1Alpha3SpecServersTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
 *
 * @schema GatewayV1Alpha3SpecServersTlsMode
 */
export enum GatewayV1Alpha3SpecServersTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * @schema GatewayV1Alpha3SpecServersTlsTlsCertificates
 */
export interface GatewayV1Alpha3SpecServersTlsTlsCertificates {
  /**
   * @schema GatewayV1Alpha3SpecServersTlsTlsCertificates#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Alpha3SpecServersTlsTlsCertificates#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Alpha3SpecServersTlsTlsCertificates#serverCertificate
   */
  readonly serverCertificate?: string;

}

/**
 * Converts an object of type 'GatewayV1Alpha3SpecServersTlsTlsCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Alpha3SpecServersTlsTlsCertificates(obj: GatewayV1Alpha3SpecServersTlsTlsCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema GatewayV1Beta1
 */
export class GatewayV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GatewayV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'Gateway',
  }

  /**
   * Renders a Kubernetes manifest for "GatewayV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GatewayV1Beta1Props = {}): any {
    return {
      ...GatewayV1Beta1.GVK,
      ...toJson_GatewayV1Beta1Props(props),
    };
  }

  /**
   * Defines a "GatewayV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GatewayV1Beta1Props = {}) {
    super(scope, id, {
      ...GatewayV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...GatewayV1Beta1.GVK,
      ...toJson_GatewayV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema GatewayV1Beta1
 */
export interface GatewayV1Beta1Props {
  /**
   * @schema GatewayV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
   *
   * @schema GatewayV1Beta1#spec
   */
  readonly spec?: GatewayV1Beta1Spec;

}

/**
 * Converts an object of type 'GatewayV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1Props(obj: GatewayV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GatewayV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
 *
 * @schema GatewayV1Beta1Spec
 */
export interface GatewayV1Beta1Spec {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied.
   *
   * @schema GatewayV1Beta1Spec#selector
   */
  readonly selector?: { [key: string]: string };

  /**
   * A list of server specifications.
   *
   * @schema GatewayV1Beta1Spec#servers
   */
  readonly servers?: GatewayV1Beta1SpecServers[];

}

/**
 * Converts an object of type 'GatewayV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1Spec(obj: GatewayV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selector': ((obj.selector) === undefined) ? undefined : (Object.entries(obj.selector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'servers': obj.servers?.map(y => toJson_GatewayV1Beta1SpecServers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GatewayV1Beta1SpecServers
 */
export interface GatewayV1Beta1SpecServers {
  /**
   * The ip or the Unix domain socket to which the listener should be bound to.
   *
   * @schema GatewayV1Beta1SpecServers#bind
   */
  readonly bind?: string;

  /**
   * @schema GatewayV1Beta1SpecServers#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * One or more hosts exposed by this gateway.
   *
   * @schema GatewayV1Beta1SpecServers#hosts
   */
  readonly hosts: string[];

  /**
   * An optional name of the server, when set must be unique across all servers.
   *
   * @schema GatewayV1Beta1SpecServers#name
   */
  readonly name?: string;

  /**
   * The Port on which the proxy should listen for incoming connections.
   *
   * @schema GatewayV1Beta1SpecServers#port
   */
  readonly port: GatewayV1Beta1SpecServersPort;

  /**
   * Set of TLS related options that govern the server's behavior.
   *
   * @schema GatewayV1Beta1SpecServers#tls
   */
  readonly tls?: GatewayV1Beta1SpecServersTls;

}

/**
 * Converts an object of type 'GatewayV1Beta1SpecServers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecServers(obj: GatewayV1Beta1SpecServers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'defaultEndpoint': obj.defaultEndpoint,
    'hosts': obj.hosts?.map(y => y),
    'name': obj.name,
    'port': toJson_GatewayV1Beta1SpecServersPort(obj.port),
    'tls': toJson_GatewayV1Beta1SpecServersTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Port on which the proxy should listen for incoming connections.
 *
 * @schema GatewayV1Beta1SpecServersPort
 */
export interface GatewayV1Beta1SpecServersPort {
  /**
   * Label assigned to the port.
   *
   * @schema GatewayV1Beta1SpecServersPort#name
   */
  readonly name: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema GatewayV1Beta1SpecServersPort#number
   */
  readonly number: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema GatewayV1Beta1SpecServersPort#protocol
   */
  readonly protocol: string;

  /**
   * @schema GatewayV1Beta1SpecServersPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'GatewayV1Beta1SpecServersPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecServersPort(obj: GatewayV1Beta1SpecServersPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set of TLS related options that govern the server's behavior.
 *
 * @schema GatewayV1Beta1SpecServersTls
 */
export interface GatewayV1Beta1SpecServersTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema GatewayV1Beta1SpecServersTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
   *
   * @schema GatewayV1Beta1SpecServersTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema GatewayV1Beta1SpecServersTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema GatewayV1Beta1SpecServersTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * Same as CredentialName but for multiple certificates.
   *
   * @schema GatewayV1Beta1SpecServersTls#credentialNames
   */
  readonly credentialNames?: string[];

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema GatewayV1Beta1SpecServersTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema GatewayV1Beta1SpecServersTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: GatewayV1Beta1SpecServersTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema GatewayV1Beta1SpecServersTls#minProtocolVersion
   */
  readonly minProtocolVersion?: GatewayV1Beta1SpecServersTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
   *
   * @schema GatewayV1Beta1SpecServersTls#mode
   */
  readonly mode?: GatewayV1Beta1SpecServersTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Beta1SpecServersTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Beta1SpecServersTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema GatewayV1Beta1SpecServersTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Only one of `server_certificate`, `private_key` or `credential_name` or `credential_names` or `tls_certificates` should be specified.
   *
   * @schema GatewayV1Beta1SpecServersTls#tlsCertificates
   */
  readonly tlsCertificates?: GatewayV1Beta1SpecServersTlsTlsCertificates[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema GatewayV1Beta1SpecServersTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema GatewayV1Beta1SpecServersTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'GatewayV1Beta1SpecServersTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecServersTls(obj: GatewayV1Beta1SpecServersTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'credentialNames': obj.credentialNames?.map(y => y),
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'tlsCertificates': obj.tlsCertificates?.map(y => toJson_GatewayV1Beta1SpecServersTlsTlsCertificates(y)),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema GatewayV1Beta1SpecServersTlsMaxProtocolVersion
 */
export enum GatewayV1Beta1SpecServersTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema GatewayV1Beta1SpecServersTlsMinProtocolVersion
 */
export enum GatewayV1Beta1SpecServersTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
 *
 * @schema GatewayV1Beta1SpecServersTlsMode
 */
export enum GatewayV1Beta1SpecServersTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * @schema GatewayV1Beta1SpecServersTlsTlsCertificates
 */
export interface GatewayV1Beta1SpecServersTlsTlsCertificates {
  /**
   * @schema GatewayV1Beta1SpecServersTlsTlsCertificates#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Beta1SpecServersTlsTlsCertificates#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema GatewayV1Beta1SpecServersTlsTlsCertificates#serverCertificate
   */
  readonly serverCertificate?: string;

}

/**
 * Converts an object of type 'GatewayV1Beta1SpecServersTlsTlsCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecServersTlsTlsCertificates(obj: GatewayV1Beta1SpecServersTlsTlsCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema ProxyConfig
 */
export class ProxyConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProxyConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'ProxyConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProxyConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProxyConfigProps = {}): any {
    return {
      ...ProxyConfig.GVK,
      ...toJson_ProxyConfigProps(props),
    };
  }

  /**
   * Defines a "ProxyConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProxyConfigProps = {}) {
    super(scope, id, {
      ...ProxyConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProxyConfig.GVK,
      ...toJson_ProxyConfigProps(resolved),
    };
  }
}

/**
 * @schema ProxyConfig
 */
export interface ProxyConfigProps {
  /**
   * @schema ProxyConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
   *
   * @schema ProxyConfig#spec
   */
  readonly spec?: ProxyConfigSpec;

}

/**
 * Converts an object of type 'ProxyConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProxyConfigProps(obj: ProxyConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProxyConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
 *
 * @schema ProxyConfigSpec
 */
export interface ProxyConfigSpec {
  /**
   * The number of worker threads to run.
   *
   * @schema ProxyConfigSpec#concurrency
   */
  readonly concurrency?: number;

  /**
   * Additional environment variables for the proxy.
   *
   * @schema ProxyConfigSpec#environmentVariables
   */
  readonly environmentVariables?: { [key: string]: string };

  /**
   * Specifies the details of the proxy image.
   *
   * @schema ProxyConfigSpec#image
   */
  readonly image?: ProxyConfigSpecImage;

  /**
   * Optional.
   *
   * @schema ProxyConfigSpec#selector
   */
  readonly selector?: ProxyConfigSpecSelector;

}

/**
 * Converts an object of type 'ProxyConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProxyConfigSpec(obj: ProxyConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'concurrency': obj.concurrency,
    'environmentVariables': ((obj.environmentVariables) === undefined) ? undefined : (Object.entries(obj.environmentVariables).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'image': toJson_ProxyConfigSpecImage(obj.image),
    'selector': toJson_ProxyConfigSpecSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the details of the proxy image.
 *
 * @schema ProxyConfigSpecImage
 */
export interface ProxyConfigSpecImage {
  /**
   * The image type of the image.
   *
   * @schema ProxyConfigSpecImage#imageType
   */
  readonly imageType?: string;

}

/**
 * Converts an object of type 'ProxyConfigSpecImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProxyConfigSpecImage(obj: ProxyConfigSpecImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageType': obj.imageType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional.
 *
 * @schema ProxyConfigSpecSelector
 */
export interface ProxyConfigSpecSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema ProxyConfigSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ProxyConfigSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProxyConfigSpecSelector(obj: ProxyConfigSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema ServiceEntry
 */
export class ServiceEntry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceEntry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'ServiceEntry',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceEntry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceEntryProps): any {
    return {
      ...ServiceEntry.GVK,
      ...toJson_ServiceEntryProps(props),
    };
  }

  /**
   * Defines a "ServiceEntry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceEntryProps) {
    super(scope, id, {
      ...ServiceEntry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceEntry.GVK,
      ...toJson_ServiceEntryProps(resolved),
    };
  }
}

/**
 * @schema ServiceEntry
 */
export interface ServiceEntryProps {
  /**
   * @schema ServiceEntry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
   *
   * @schema ServiceEntry#spec
   */
  readonly spec: ServiceEntrySpec;

}

/**
 * Converts an object of type 'ServiceEntryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryProps(obj: ServiceEntryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceEntrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
 *
 * @schema ServiceEntrySpec
 */
export interface ServiceEntrySpec {
  /**
   * The virtual IP addresses associated with the service.
   *
   * @schema ServiceEntrySpec#addresses
   */
  readonly addresses?: string[];

  /**
   * One or more endpoints associated with the service.
   *
   * @schema ServiceEntrySpec#endpoints
   */
  readonly endpoints?: ServiceEntrySpecEndpoints[];

  /**
   * A list of namespaces to which this service is exported.
   *
   * @schema ServiceEntrySpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The hosts associated with the ServiceEntry.
   *
   * @schema ServiceEntrySpec#hosts
   */
  readonly hosts: string[];

  /**
   * Specify whether the service should be considered external to the mesh or part of the mesh.
   *
   * Valid Options: MESH_EXTERNAL, MESH_INTERNAL
   *
   * @schema ServiceEntrySpec#location
   */
  readonly location?: ServiceEntrySpecLocation;

  /**
   * The ports associated with the external service.
   *
   * @schema ServiceEntrySpec#ports
   */
  readonly ports?: ServiceEntrySpecPorts[];

  /**
   * Service resolution mode for the hosts.
   *
   * Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
   *
   * @schema ServiceEntrySpec#resolution
   */
  readonly resolution?: ServiceEntrySpecResolution;

  /**
   * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
   *
   * @schema ServiceEntrySpec#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Applicable only for MESH_INTERNAL services.
   *
   * @schema ServiceEntrySpec#workloadSelector
   */
  readonly workloadSelector?: ServiceEntrySpecWorkloadSelector;

}

/**
 * Converts an object of type 'ServiceEntrySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntrySpec(obj: ServiceEntrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'endpoints': obj.endpoints?.map(y => toJson_ServiceEntrySpecEndpoints(y)),
    'exportTo': obj.exportTo?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'location': obj.location,
    'ports': obj.ports?.map(y => toJson_ServiceEntrySpecPorts(y)),
    'resolution': obj.resolution,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'workloadSelector': toJson_ServiceEntrySpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceEntrySpecEndpoints
 */
export interface ServiceEntrySpecEndpoints {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema ServiceEntrySpecEndpoints#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema ServiceEntrySpecEndpoints#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema ServiceEntrySpecEndpoints#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema ServiceEntrySpecEndpoints#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ServiceEntrySpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntrySpecEndpoints(obj: ServiceEntrySpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify whether the service should be considered external to the mesh or part of the mesh.
 *
 * Valid Options: MESH_EXTERNAL, MESH_INTERNAL
 *
 * @schema ServiceEntrySpecLocation
 */
export enum ServiceEntrySpecLocation {
  /** MESH_EXTERNAL */
  MESH_UNDERSCORE_EXTERNAL = "MESH_EXTERNAL",
  /** MESH_INTERNAL */
  MESH_UNDERSCORE_INTERNAL = "MESH_INTERNAL",
}

/**
 * @schema ServiceEntrySpecPorts
 */
export interface ServiceEntrySpecPorts {
  /**
   * Label assigned to the port.
   *
   * @schema ServiceEntrySpecPorts#name
   */
  readonly name: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema ServiceEntrySpecPorts#number
   */
  readonly number: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema ServiceEntrySpecPorts#protocol
   */
  readonly protocol?: string;

  /**
   * The port number on the endpoint where the traffic will be received.
   *
   * @schema ServiceEntrySpecPorts#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'ServiceEntrySpecPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntrySpecPorts(obj: ServiceEntrySpecPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service resolution mode for the hosts.
 *
 * Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
 *
 * @schema ServiceEntrySpecResolution
 */
export enum ServiceEntrySpecResolution {
  /** NONE */
  NONE = "NONE",
  /** STATIC */
  STATIC = "STATIC",
  /** DNS */
  DNS = "DNS",
  /** DNS_ROUND_ROBIN */
  DNS_UNDERSCORE_ROUND_UNDERSCORE_ROBIN = "DNS_ROUND_ROBIN",
}

/**
 * Applicable only for MESH_INTERNAL services.
 *
 * @schema ServiceEntrySpecWorkloadSelector
 */
export interface ServiceEntrySpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema ServiceEntrySpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceEntrySpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntrySpecWorkloadSelector(obj: ServiceEntrySpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema ServiceEntryV1Alpha3
 */
export class ServiceEntryV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceEntryV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'ServiceEntry',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceEntryV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceEntryV1Alpha3Props): any {
    return {
      ...ServiceEntryV1Alpha3.GVK,
      ...toJson_ServiceEntryV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "ServiceEntryV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceEntryV1Alpha3Props) {
    super(scope, id, {
      ...ServiceEntryV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceEntryV1Alpha3.GVK,
      ...toJson_ServiceEntryV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema ServiceEntryV1Alpha3
 */
export interface ServiceEntryV1Alpha3Props {
  /**
   * @schema ServiceEntryV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
   *
   * @schema ServiceEntryV1Alpha3#spec
   */
  readonly spec: ServiceEntryV1Alpha3Spec;

}

/**
 * Converts an object of type 'ServiceEntryV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Alpha3Props(obj: ServiceEntryV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceEntryV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
 *
 * @schema ServiceEntryV1Alpha3Spec
 */
export interface ServiceEntryV1Alpha3Spec {
  /**
   * The virtual IP addresses associated with the service.
   *
   * @schema ServiceEntryV1Alpha3Spec#addresses
   */
  readonly addresses?: string[];

  /**
   * One or more endpoints associated with the service.
   *
   * @schema ServiceEntryV1Alpha3Spec#endpoints
   */
  readonly endpoints?: ServiceEntryV1Alpha3SpecEndpoints[];

  /**
   * A list of namespaces to which this service is exported.
   *
   * @schema ServiceEntryV1Alpha3Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The hosts associated with the ServiceEntry.
   *
   * @schema ServiceEntryV1Alpha3Spec#hosts
   */
  readonly hosts: string[];

  /**
   * Specify whether the service should be considered external to the mesh or part of the mesh.
   *
   * Valid Options: MESH_EXTERNAL, MESH_INTERNAL
   *
   * @schema ServiceEntryV1Alpha3Spec#location
   */
  readonly location?: ServiceEntryV1Alpha3SpecLocation;

  /**
   * The ports associated with the external service.
   *
   * @schema ServiceEntryV1Alpha3Spec#ports
   */
  readonly ports?: ServiceEntryV1Alpha3SpecPorts[];

  /**
   * Service resolution mode for the hosts.
   *
   * Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
   *
   * @schema ServiceEntryV1Alpha3Spec#resolution
   */
  readonly resolution?: ServiceEntryV1Alpha3SpecResolution;

  /**
   * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
   *
   * @schema ServiceEntryV1Alpha3Spec#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Applicable only for MESH_INTERNAL services.
   *
   * @schema ServiceEntryV1Alpha3Spec#workloadSelector
   */
  readonly workloadSelector?: ServiceEntryV1Alpha3SpecWorkloadSelector;

}

/**
 * Converts an object of type 'ServiceEntryV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Alpha3Spec(obj: ServiceEntryV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'endpoints': obj.endpoints?.map(y => toJson_ServiceEntryV1Alpha3SpecEndpoints(y)),
    'exportTo': obj.exportTo?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'location': obj.location,
    'ports': obj.ports?.map(y => toJson_ServiceEntryV1Alpha3SpecPorts(y)),
    'resolution': obj.resolution,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'workloadSelector': toJson_ServiceEntryV1Alpha3SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceEntryV1Alpha3SpecEndpoints
 */
export interface ServiceEntryV1Alpha3SpecEndpoints {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema ServiceEntryV1Alpha3SpecEndpoints#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ServiceEntryV1Alpha3SpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Alpha3SpecEndpoints(obj: ServiceEntryV1Alpha3SpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify whether the service should be considered external to the mesh or part of the mesh.
 *
 * Valid Options: MESH_EXTERNAL, MESH_INTERNAL
 *
 * @schema ServiceEntryV1Alpha3SpecLocation
 */
export enum ServiceEntryV1Alpha3SpecLocation {
  /** MESH_EXTERNAL */
  MESH_UNDERSCORE_EXTERNAL = "MESH_EXTERNAL",
  /** MESH_INTERNAL */
  MESH_UNDERSCORE_INTERNAL = "MESH_INTERNAL",
}

/**
 * @schema ServiceEntryV1Alpha3SpecPorts
 */
export interface ServiceEntryV1Alpha3SpecPorts {
  /**
   * Label assigned to the port.
   *
   * @schema ServiceEntryV1Alpha3SpecPorts#name
   */
  readonly name: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema ServiceEntryV1Alpha3SpecPorts#number
   */
  readonly number: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema ServiceEntryV1Alpha3SpecPorts#protocol
   */
  readonly protocol?: string;

  /**
   * The port number on the endpoint where the traffic will be received.
   *
   * @schema ServiceEntryV1Alpha3SpecPorts#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'ServiceEntryV1Alpha3SpecPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Alpha3SpecPorts(obj: ServiceEntryV1Alpha3SpecPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service resolution mode for the hosts.
 *
 * Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
 *
 * @schema ServiceEntryV1Alpha3SpecResolution
 */
export enum ServiceEntryV1Alpha3SpecResolution {
  /** NONE */
  NONE = "NONE",
  /** STATIC */
  STATIC = "STATIC",
  /** DNS */
  DNS = "DNS",
  /** DNS_ROUND_ROBIN */
  DNS_UNDERSCORE_ROUND_UNDERSCORE_ROBIN = "DNS_ROUND_ROBIN",
}

/**
 * Applicable only for MESH_INTERNAL services.
 *
 * @schema ServiceEntryV1Alpha3SpecWorkloadSelector
 */
export interface ServiceEntryV1Alpha3SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema ServiceEntryV1Alpha3SpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceEntryV1Alpha3SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Alpha3SpecWorkloadSelector(obj: ServiceEntryV1Alpha3SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema ServiceEntryV1Beta1
 */
export class ServiceEntryV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceEntryV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'ServiceEntry',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceEntryV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceEntryV1Beta1Props): any {
    return {
      ...ServiceEntryV1Beta1.GVK,
      ...toJson_ServiceEntryV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ServiceEntryV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceEntryV1Beta1Props) {
    super(scope, id, {
      ...ServiceEntryV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceEntryV1Beta1.GVK,
      ...toJson_ServiceEntryV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema ServiceEntryV1Beta1
 */
export interface ServiceEntryV1Beta1Props {
  /**
   * @schema ServiceEntryV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
   *
   * @schema ServiceEntryV1Beta1#spec
   */
  readonly spec: ServiceEntryV1Beta1Spec;

}

/**
 * Converts an object of type 'ServiceEntryV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Beta1Props(obj: ServiceEntryV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceEntryV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
 *
 * @schema ServiceEntryV1Beta1Spec
 */
export interface ServiceEntryV1Beta1Spec {
  /**
   * The virtual IP addresses associated with the service.
   *
   * @schema ServiceEntryV1Beta1Spec#addresses
   */
  readonly addresses?: string[];

  /**
   * One or more endpoints associated with the service.
   *
   * @schema ServiceEntryV1Beta1Spec#endpoints
   */
  readonly endpoints?: ServiceEntryV1Beta1SpecEndpoints[];

  /**
   * A list of namespaces to which this service is exported.
   *
   * @schema ServiceEntryV1Beta1Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The hosts associated with the ServiceEntry.
   *
   * @schema ServiceEntryV1Beta1Spec#hosts
   */
  readonly hosts: string[];

  /**
   * Specify whether the service should be considered external to the mesh or part of the mesh.
   *
   * Valid Options: MESH_EXTERNAL, MESH_INTERNAL
   *
   * @schema ServiceEntryV1Beta1Spec#location
   */
  readonly location?: ServiceEntryV1Beta1SpecLocation;

  /**
   * The ports associated with the external service.
   *
   * @schema ServiceEntryV1Beta1Spec#ports
   */
  readonly ports?: ServiceEntryV1Beta1SpecPorts[];

  /**
   * Service resolution mode for the hosts.
   *
   * Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
   *
   * @schema ServiceEntryV1Beta1Spec#resolution
   */
  readonly resolution?: ServiceEntryV1Beta1SpecResolution;

  /**
   * If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
   *
   * @schema ServiceEntryV1Beta1Spec#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Applicable only for MESH_INTERNAL services.
   *
   * @schema ServiceEntryV1Beta1Spec#workloadSelector
   */
  readonly workloadSelector?: ServiceEntryV1Beta1SpecWorkloadSelector;

}

/**
 * Converts an object of type 'ServiceEntryV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Beta1Spec(obj: ServiceEntryV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => y),
    'endpoints': obj.endpoints?.map(y => toJson_ServiceEntryV1Beta1SpecEndpoints(y)),
    'exportTo': obj.exportTo?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'location': obj.location,
    'ports': obj.ports?.map(y => toJson_ServiceEntryV1Beta1SpecPorts(y)),
    'resolution': obj.resolution,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'workloadSelector': toJson_ServiceEntryV1Beta1SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ServiceEntryV1Beta1SpecEndpoints
 */
export interface ServiceEntryV1Beta1SpecEndpoints {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema ServiceEntryV1Beta1SpecEndpoints#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ServiceEntryV1Beta1SpecEndpoints' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Beta1SpecEndpoints(obj: ServiceEntryV1Beta1SpecEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify whether the service should be considered external to the mesh or part of the mesh.
 *
 * Valid Options: MESH_EXTERNAL, MESH_INTERNAL
 *
 * @schema ServiceEntryV1Beta1SpecLocation
 */
export enum ServiceEntryV1Beta1SpecLocation {
  /** MESH_EXTERNAL */
  MESH_UNDERSCORE_EXTERNAL = "MESH_EXTERNAL",
  /** MESH_INTERNAL */
  MESH_UNDERSCORE_INTERNAL = "MESH_INTERNAL",
}

/**
 * @schema ServiceEntryV1Beta1SpecPorts
 */
export interface ServiceEntryV1Beta1SpecPorts {
  /**
   * Label assigned to the port.
   *
   * @schema ServiceEntryV1Beta1SpecPorts#name
   */
  readonly name: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema ServiceEntryV1Beta1SpecPorts#number
   */
  readonly number: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema ServiceEntryV1Beta1SpecPorts#protocol
   */
  readonly protocol?: string;

  /**
   * The port number on the endpoint where the traffic will be received.
   *
   * @schema ServiceEntryV1Beta1SpecPorts#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'ServiceEntryV1Beta1SpecPorts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Beta1SpecPorts(obj: ServiceEntryV1Beta1SpecPorts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service resolution mode for the hosts.
 *
 * Valid Options: NONE, STATIC, DNS, DNS_ROUND_ROBIN
 *
 * @schema ServiceEntryV1Beta1SpecResolution
 */
export enum ServiceEntryV1Beta1SpecResolution {
  /** NONE */
  NONE = "NONE",
  /** STATIC */
  STATIC = "STATIC",
  /** DNS */
  DNS = "DNS",
  /** DNS_ROUND_ROBIN */
  DNS_UNDERSCORE_ROUND_UNDERSCORE_ROBIN = "DNS_ROUND_ROBIN",
}

/**
 * Applicable only for MESH_INTERNAL services.
 *
 * @schema ServiceEntryV1Beta1SpecWorkloadSelector
 */
export interface ServiceEntryV1Beta1SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema ServiceEntryV1Beta1SpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceEntryV1Beta1SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServiceEntryV1Beta1SpecWorkloadSelector(obj: ServiceEntryV1Beta1SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema Sidecar
 */
export class Sidecar extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Sidecar"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'Sidecar',
  }

  /**
   * Renders a Kubernetes manifest for "Sidecar".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SidecarProps = {}): any {
    return {
      ...Sidecar.GVK,
      ...toJson_SidecarProps(props),
    };
  }

  /**
   * Defines a "Sidecar" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SidecarProps = {}) {
    super(scope, id, {
      ...Sidecar.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Sidecar.GVK,
      ...toJson_SidecarProps(resolved),
    };
  }
}

/**
 * @schema Sidecar
 */
export interface SidecarProps {
  /**
   * @schema Sidecar#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
   *
   * @schema Sidecar#spec
   */
  readonly spec?: SidecarSpec;

}

/**
 * Converts an object of type 'SidecarProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarProps(obj: SidecarProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SidecarSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
 *
 * @schema SidecarSpec
 */
export interface SidecarSpec {
  /**
   * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
   *
   * @schema SidecarSpec#egress
   */
  readonly egress?: SidecarSpecEgress[];

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarSpec#inboundConnectionPool
   */
  readonly inboundConnectionPool?: SidecarSpecInboundConnectionPool;

  /**
   * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
   *
   * @schema SidecarSpec#ingress
   */
  readonly ingress?: SidecarSpecIngress[];

  /**
   * Set the default behavior of the sidecar for handling outbound traffic from the application.
   *
   * @schema SidecarSpec#outboundTrafficPolicy
   */
  readonly outboundTrafficPolicy?: SidecarSpecOutboundTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
   *
   * @schema SidecarSpec#workloadSelector
   */
  readonly workloadSelector?: SidecarSpecWorkloadSelector;

}

/**
 * Converts an object of type 'SidecarSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpec(obj: SidecarSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egress': obj.egress?.map(y => toJson_SidecarSpecEgress(y)),
    'inboundConnectionPool': toJson_SidecarSpecInboundConnectionPool(obj.inboundConnectionPool),
    'ingress': obj.ingress?.map(y => toJson_SidecarSpecIngress(y)),
    'outboundTrafficPolicy': toJson_SidecarSpecOutboundTrafficPolicy(obj.outboundTrafficPolicy),
    'workloadSelector': toJson_SidecarSpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarSpecEgress
 */
export interface SidecarSpecEgress {
  /**
   * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
   *
   * @schema SidecarSpecEgress#bind
   */
  readonly bind?: string;

  /**
   * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * Valid Options: DEFAULT, IPTABLES, NONE
   *
   * @schema SidecarSpecEgress#captureMode
   */
  readonly captureMode?: SidecarSpecEgressCaptureMode;

  /**
   * One or more service hosts exposed by the listener in `namespace/dnsName` format.
   *
   * @schema SidecarSpecEgress#hosts
   */
  readonly hosts: string[];

  /**
   * The port associated with the listener.
   *
   * @schema SidecarSpecEgress#port
   */
  readonly port?: SidecarSpecEgressPort;

}

/**
 * Converts an object of type 'SidecarSpecEgress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecEgress(obj: SidecarSpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'hosts': obj.hosts?.map(y => y),
    'port': toJson_SidecarSpecEgressPort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarSpecInboundConnectionPool
 */
export interface SidecarSpecInboundConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarSpecInboundConnectionPool#http
   */
  readonly http?: SidecarSpecInboundConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarSpecInboundConnectionPool#tcp
   */
  readonly tcp?: SidecarSpecInboundConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecInboundConnectionPool(obj: SidecarSpecInboundConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarSpecInboundConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarSpecInboundConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarSpecIngress
 */
export interface SidecarSpecIngress {
  /**
   * The IP(IPv4 or IPv6) to which the listener should be bound.
   *
   * @schema SidecarSpecIngress#bind
   */
  readonly bind?: string;

  /**
   * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * Valid Options: DEFAULT, IPTABLES, NONE
   *
   * @schema SidecarSpecIngress#captureMode
   */
  readonly captureMode?: SidecarSpecIngressCaptureMode;

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarSpecIngress#connectionPool
   */
  readonly connectionPool?: SidecarSpecIngressConnectionPool;

  /**
   * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
   *
   * @schema SidecarSpecIngress#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * The port associated with the listener.
   *
   * @schema SidecarSpecIngress#port
   */
  readonly port: SidecarSpecIngressPort;

  /**
   * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
   *
   * @schema SidecarSpecIngress#tls
   */
  readonly tls?: SidecarSpecIngressTls;

}

/**
 * Converts an object of type 'SidecarSpecIngress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngress(obj: SidecarSpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'connectionPool': toJson_SidecarSpecIngressConnectionPool(obj.connectionPool),
    'defaultEndpoint': obj.defaultEndpoint,
    'port': toJson_SidecarSpecIngressPort(obj.port),
    'tls': toJson_SidecarSpecIngressTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set the default behavior of the sidecar for handling outbound traffic from the application.
 *
 * @schema SidecarSpecOutboundTrafficPolicy
 */
export interface SidecarSpecOutboundTrafficPolicy {
  /**
   * @schema SidecarSpecOutboundTrafficPolicy#egressProxy
   */
  readonly egressProxy?: SidecarSpecOutboundTrafficPolicyEgressProxy;

  /**
   *
   *
   * Valid Options: REGISTRY_ONLY, ALLOW_ANY
   *
   * @schema SidecarSpecOutboundTrafficPolicy#mode
   */
  readonly mode?: SidecarSpecOutboundTrafficPolicyMode;

}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicy(obj: SidecarSpecOutboundTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressProxy': toJson_SidecarSpecOutboundTrafficPolicyEgressProxy(obj.egressProxy),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
 *
 * @schema SidecarSpecWorkloadSelector
 */
export interface SidecarSpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema SidecarSpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SidecarSpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecWorkloadSelector(obj: SidecarSpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * Valid Options: DEFAULT, IPTABLES, NONE
 *
 * @schema SidecarSpecEgressCaptureMode
 */
export enum SidecarSpecEgressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarSpecEgressPort
 */
export interface SidecarSpecEgressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarSpecEgressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarSpecEgressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarSpecEgressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarSpecEgressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarSpecEgressPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecEgressPort(obj: SidecarSpecEgressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarSpecInboundConnectionPoolHttp
 */
export interface SidecarSpecInboundConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarSpecInboundConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarSpecInboundConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecInboundConnectionPoolHttp(obj: SidecarSpecInboundConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarSpecInboundConnectionPoolTcp
 */
export interface SidecarSpecInboundConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarSpecInboundConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarSpecInboundConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecInboundConnectionPoolTcp(obj: SidecarSpecInboundConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarSpecInboundConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * Valid Options: DEFAULT, IPTABLES, NONE
 *
 * @schema SidecarSpecIngressCaptureMode
 */
export enum SidecarSpecIngressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarSpecIngressConnectionPool
 */
export interface SidecarSpecIngressConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarSpecIngressConnectionPool#http
   */
  readonly http?: SidecarSpecIngressConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarSpecIngressConnectionPool#tcp
   */
  readonly tcp?: SidecarSpecIngressConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressConnectionPool(obj: SidecarSpecIngressConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarSpecIngressConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarSpecIngressConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The port associated with the listener.
 *
 * @schema SidecarSpecIngressPort
 */
export interface SidecarSpecIngressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarSpecIngressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarSpecIngressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarSpecIngressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarSpecIngressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarSpecIngressPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressPort(obj: SidecarSpecIngressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
 *
 * @schema SidecarSpecIngressTls
 */
export interface SidecarSpecIngressTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema SidecarSpecIngressTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
   *
   * @schema SidecarSpecIngressTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema SidecarSpecIngressTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema SidecarSpecIngressTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * Same as CredentialName but for multiple certificates.
   *
   * @schema SidecarSpecIngressTls#credentialNames
   */
  readonly credentialNames?: string[];

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema SidecarSpecIngressTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema SidecarSpecIngressTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: SidecarSpecIngressTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema SidecarSpecIngressTls#minProtocolVersion
   */
  readonly minProtocolVersion?: SidecarSpecIngressTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
   *
   * @schema SidecarSpecIngressTls#mode
   */
  readonly mode?: SidecarSpecIngressTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarSpecIngressTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarSpecIngressTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema SidecarSpecIngressTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Only one of `server_certificate`, `private_key` or `credential_name` or `credential_names` or `tls_certificates` should be specified.
   *
   * @schema SidecarSpecIngressTls#tlsCertificates
   */
  readonly tlsCertificates?: SidecarSpecIngressTlsTlsCertificates[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema SidecarSpecIngressTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema SidecarSpecIngressTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'SidecarSpecIngressTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressTls(obj: SidecarSpecIngressTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'credentialNames': obj.credentialNames?.map(y => y),
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'tlsCertificates': obj.tlsCertificates?.map(y => toJson_SidecarSpecIngressTlsTlsCertificates(y)),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarSpecOutboundTrafficPolicyEgressProxy
 */
export interface SidecarSpecOutboundTrafficPolicyEgressProxy {
  /**
   * The name of a service from the service registry.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#port
   */
  readonly port?: SidecarSpecOutboundTrafficPolicyEgressProxyPort;

  /**
   * The name of a subset within the service.
   *
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxy#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicyEgressProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicyEgressProxy(obj: SidecarSpecOutboundTrafficPolicyEgressProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_SidecarSpecOutboundTrafficPolicyEgressProxyPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: REGISTRY_ONLY, ALLOW_ANY
 *
 * @schema SidecarSpecOutboundTrafficPolicyMode
 */
export enum SidecarSpecOutboundTrafficPolicyMode {
  /** REGISTRY_ONLY */
  REGISTRY_UNDERSCORE_ONLY = "REGISTRY_ONLY",
  /** ALLOW_ANY */
  ALLOW_UNDERSCORE_ANY = "ALLOW_ANY",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema SidecarSpecInboundConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarSpecInboundConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive
 */
export interface SidecarSpecInboundConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarSpecInboundConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarSpecInboundConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecInboundConnectionPoolTcpTcpKeepalive(obj: SidecarSpecInboundConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarSpecIngressConnectionPoolHttp
 */
export interface SidecarSpecIngressConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarSpecIngressConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarSpecIngressConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressConnectionPoolHttp(obj: SidecarSpecIngressConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarSpecIngressConnectionPoolTcp
 */
export interface SidecarSpecIngressConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarSpecIngressConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarSpecIngressConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressConnectionPoolTcp(obj: SidecarSpecIngressConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarSpecIngressConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema SidecarSpecIngressTlsMaxProtocolVersion
 */
export enum SidecarSpecIngressTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema SidecarSpecIngressTlsMinProtocolVersion
 */
export enum SidecarSpecIngressTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
 *
 * @schema SidecarSpecIngressTlsMode
 */
export enum SidecarSpecIngressTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * @schema SidecarSpecIngressTlsTlsCertificates
 */
export interface SidecarSpecIngressTlsTlsCertificates {
  /**
   * @schema SidecarSpecIngressTlsTlsCertificates#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarSpecIngressTlsTlsCertificates#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarSpecIngressTlsTlsCertificates#serverCertificate
   */
  readonly serverCertificate?: string;

}

/**
 * Converts an object of type 'SidecarSpecIngressTlsTlsCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressTlsTlsCertificates(obj: SidecarSpecIngressTlsTlsCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema SidecarSpecOutboundTrafficPolicyEgressProxyPort
 */
export interface SidecarSpecOutboundTrafficPolicyEgressProxyPort {
  /**
   * @schema SidecarSpecOutboundTrafficPolicyEgressProxyPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'SidecarSpecOutboundTrafficPolicyEgressProxyPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecOutboundTrafficPolicyEgressProxyPort(obj: SidecarSpecOutboundTrafficPolicyEgressProxyPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema SidecarSpecIngressConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarSpecIngressConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive
 */
export interface SidecarSpecIngressConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarSpecIngressConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarSpecIngressConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarSpecIngressConnectionPoolTcpTcpKeepalive(obj: SidecarSpecIngressConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema SidecarV1Alpha3
 */
export class SidecarV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SidecarV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'Sidecar',
  }

  /**
   * Renders a Kubernetes manifest for "SidecarV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SidecarV1Alpha3Props = {}): any {
    return {
      ...SidecarV1Alpha3.GVK,
      ...toJson_SidecarV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "SidecarV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SidecarV1Alpha3Props = {}) {
    super(scope, id, {
      ...SidecarV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SidecarV1Alpha3.GVK,
      ...toJson_SidecarV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema SidecarV1Alpha3
 */
export interface SidecarV1Alpha3Props {
  /**
   * @schema SidecarV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
   *
   * @schema SidecarV1Alpha3#spec
   */
  readonly spec?: SidecarV1Alpha3Spec;

}

/**
 * Converts an object of type 'SidecarV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3Props(obj: SidecarV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SidecarV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
 *
 * @schema SidecarV1Alpha3Spec
 */
export interface SidecarV1Alpha3Spec {
  /**
   * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
   *
   * @schema SidecarV1Alpha3Spec#egress
   */
  readonly egress?: SidecarV1Alpha3SpecEgress[];

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarV1Alpha3Spec#inboundConnectionPool
   */
  readonly inboundConnectionPool?: SidecarV1Alpha3SpecInboundConnectionPool;

  /**
   * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
   *
   * @schema SidecarV1Alpha3Spec#ingress
   */
  readonly ingress?: SidecarV1Alpha3SpecIngress[];

  /**
   * Set the default behavior of the sidecar for handling outbound traffic from the application.
   *
   * @schema SidecarV1Alpha3Spec#outboundTrafficPolicy
   */
  readonly outboundTrafficPolicy?: SidecarV1Alpha3SpecOutboundTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
   *
   * @schema SidecarV1Alpha3Spec#workloadSelector
   */
  readonly workloadSelector?: SidecarV1Alpha3SpecWorkloadSelector;

}

/**
 * Converts an object of type 'SidecarV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3Spec(obj: SidecarV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egress': obj.egress?.map(y => toJson_SidecarV1Alpha3SpecEgress(y)),
    'inboundConnectionPool': toJson_SidecarV1Alpha3SpecInboundConnectionPool(obj.inboundConnectionPool),
    'ingress': obj.ingress?.map(y => toJson_SidecarV1Alpha3SpecIngress(y)),
    'outboundTrafficPolicy': toJson_SidecarV1Alpha3SpecOutboundTrafficPolicy(obj.outboundTrafficPolicy),
    'workloadSelector': toJson_SidecarV1Alpha3SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarV1Alpha3SpecEgress
 */
export interface SidecarV1Alpha3SpecEgress {
  /**
   * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
   *
   * @schema SidecarV1Alpha3SpecEgress#bind
   */
  readonly bind?: string;

  /**
   * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * Valid Options: DEFAULT, IPTABLES, NONE
   *
   * @schema SidecarV1Alpha3SpecEgress#captureMode
   */
  readonly captureMode?: SidecarV1Alpha3SpecEgressCaptureMode;

  /**
   * One or more service hosts exposed by the listener in `namespace/dnsName` format.
   *
   * @schema SidecarV1Alpha3SpecEgress#hosts
   */
  readonly hosts: string[];

  /**
   * The port associated with the listener.
   *
   * @schema SidecarV1Alpha3SpecEgress#port
   */
  readonly port?: SidecarV1Alpha3SpecEgressPort;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecEgress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecEgress(obj: SidecarV1Alpha3SpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'hosts': obj.hosts?.map(y => y),
    'port': toJson_SidecarV1Alpha3SpecEgressPort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarV1Alpha3SpecInboundConnectionPool
 */
export interface SidecarV1Alpha3SpecInboundConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPool#http
   */
  readonly http?: SidecarV1Alpha3SpecInboundConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPool#tcp
   */
  readonly tcp?: SidecarV1Alpha3SpecInboundConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecInboundConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecInboundConnectionPool(obj: SidecarV1Alpha3SpecInboundConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarV1Alpha3SpecInboundConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarV1Alpha3SpecInboundConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarV1Alpha3SpecIngress
 */
export interface SidecarV1Alpha3SpecIngress {
  /**
   * The IP(IPv4 or IPv6) to which the listener should be bound.
   *
   * @schema SidecarV1Alpha3SpecIngress#bind
   */
  readonly bind?: string;

  /**
   * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * Valid Options: DEFAULT, IPTABLES, NONE
   *
   * @schema SidecarV1Alpha3SpecIngress#captureMode
   */
  readonly captureMode?: SidecarV1Alpha3SpecIngressCaptureMode;

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarV1Alpha3SpecIngress#connectionPool
   */
  readonly connectionPool?: SidecarV1Alpha3SpecIngressConnectionPool;

  /**
   * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
   *
   * @schema SidecarV1Alpha3SpecIngress#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * The port associated with the listener.
   *
   * @schema SidecarV1Alpha3SpecIngress#port
   */
  readonly port: SidecarV1Alpha3SpecIngressPort;

  /**
   * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
   *
   * @schema SidecarV1Alpha3SpecIngress#tls
   */
  readonly tls?: SidecarV1Alpha3SpecIngressTls;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngress(obj: SidecarV1Alpha3SpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'connectionPool': toJson_SidecarV1Alpha3SpecIngressConnectionPool(obj.connectionPool),
    'defaultEndpoint': obj.defaultEndpoint,
    'port': toJson_SidecarV1Alpha3SpecIngressPort(obj.port),
    'tls': toJson_SidecarV1Alpha3SpecIngressTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set the default behavior of the sidecar for handling outbound traffic from the application.
 *
 * @schema SidecarV1Alpha3SpecOutboundTrafficPolicy
 */
export interface SidecarV1Alpha3SpecOutboundTrafficPolicy {
  /**
   * @schema SidecarV1Alpha3SpecOutboundTrafficPolicy#egressProxy
   */
  readonly egressProxy?: SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy;

  /**
   *
   *
   * Valid Options: REGISTRY_ONLY, ALLOW_ANY
   *
   * @schema SidecarV1Alpha3SpecOutboundTrafficPolicy#mode
   */
  readonly mode?: SidecarV1Alpha3SpecOutboundTrafficPolicyMode;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecOutboundTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecOutboundTrafficPolicy(obj: SidecarV1Alpha3SpecOutboundTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressProxy': toJson_SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy(obj.egressProxy),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
 *
 * @schema SidecarV1Alpha3SpecWorkloadSelector
 */
export interface SidecarV1Alpha3SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema SidecarV1Alpha3SpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecWorkloadSelector(obj: SidecarV1Alpha3SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * Valid Options: DEFAULT, IPTABLES, NONE
 *
 * @schema SidecarV1Alpha3SpecEgressCaptureMode
 */
export enum SidecarV1Alpha3SpecEgressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarV1Alpha3SpecEgressPort
 */
export interface SidecarV1Alpha3SpecEgressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarV1Alpha3SpecEgressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarV1Alpha3SpecEgressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarV1Alpha3SpecEgressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarV1Alpha3SpecEgressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecEgressPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecEgressPort(obj: SidecarV1Alpha3SpecEgressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp
 */
export interface SidecarV1Alpha3SpecInboundConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarV1Alpha3SpecInboundConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecInboundConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecInboundConnectionPoolHttp(obj: SidecarV1Alpha3SpecInboundConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcp
 */
export interface SidecarV1Alpha3SpecInboundConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecInboundConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecInboundConnectionPoolTcp(obj: SidecarV1Alpha3SpecInboundConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * Valid Options: DEFAULT, IPTABLES, NONE
 *
 * @schema SidecarV1Alpha3SpecIngressCaptureMode
 */
export enum SidecarV1Alpha3SpecIngressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarV1Alpha3SpecIngressConnectionPool
 */
export interface SidecarV1Alpha3SpecIngressConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPool#http
   */
  readonly http?: SidecarV1Alpha3SpecIngressConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPool#tcp
   */
  readonly tcp?: SidecarV1Alpha3SpecIngressConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressConnectionPool(obj: SidecarV1Alpha3SpecIngressConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarV1Alpha3SpecIngressConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarV1Alpha3SpecIngressConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The port associated with the listener.
 *
 * @schema SidecarV1Alpha3SpecIngressPort
 */
export interface SidecarV1Alpha3SpecIngressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarV1Alpha3SpecIngressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarV1Alpha3SpecIngressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarV1Alpha3SpecIngressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarV1Alpha3SpecIngressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressPort(obj: SidecarV1Alpha3SpecIngressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
 *
 * @schema SidecarV1Alpha3SpecIngressTls
 */
export interface SidecarV1Alpha3SpecIngressTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * Same as CredentialName but for multiple certificates.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#credentialNames
   */
  readonly credentialNames?: string[];

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema SidecarV1Alpha3SpecIngressTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: SidecarV1Alpha3SpecIngressTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema SidecarV1Alpha3SpecIngressTls#minProtocolVersion
   */
  readonly minProtocolVersion?: SidecarV1Alpha3SpecIngressTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
   *
   * @schema SidecarV1Alpha3SpecIngressTls#mode
   */
  readonly mode?: SidecarV1Alpha3SpecIngressTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Only one of `server_certificate`, `private_key` or `credential_name` or `credential_names` or `tls_certificates` should be specified.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#tlsCertificates
   */
  readonly tlsCertificates?: SidecarV1Alpha3SpecIngressTlsTlsCertificates[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema SidecarV1Alpha3SpecIngressTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressTls(obj: SidecarV1Alpha3SpecIngressTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'credentialNames': obj.credentialNames?.map(y => y),
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'tlsCertificates': obj.tlsCertificates?.map(y => toJson_SidecarV1Alpha3SpecIngressTlsTlsCertificates(y)),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy
 */
export interface SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy {
  /**
   * The name of a service from the service registry.
   *
   * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy#port
   */
  readonly port?: SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort;

  /**
   * The name of a subset within the service.
   *
   * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy(obj: SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: REGISTRY_ONLY, ALLOW_ANY
 *
 * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyMode
 */
export enum SidecarV1Alpha3SpecOutboundTrafficPolicyMode {
  /** REGISTRY_ONLY */
  REGISTRY_UNDERSCORE_ONLY = "REGISTRY_ONLY",
  /** ALLOW_ANY */
  ALLOW_UNDERSCORE_ANY = "ALLOW_ANY",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema SidecarV1Alpha3SpecInboundConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarV1Alpha3SpecInboundConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive
 */
export interface SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive(obj: SidecarV1Alpha3SpecInboundConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp
 */
export interface SidecarV1Alpha3SpecIngressConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarV1Alpha3SpecIngressConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressConnectionPoolHttp(obj: SidecarV1Alpha3SpecIngressConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcp
 */
export interface SidecarV1Alpha3SpecIngressConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressConnectionPoolTcp(obj: SidecarV1Alpha3SpecIngressConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema SidecarV1Alpha3SpecIngressTlsMaxProtocolVersion
 */
export enum SidecarV1Alpha3SpecIngressTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema SidecarV1Alpha3SpecIngressTlsMinProtocolVersion
 */
export enum SidecarV1Alpha3SpecIngressTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
 *
 * @schema SidecarV1Alpha3SpecIngressTlsMode
 */
export enum SidecarV1Alpha3SpecIngressTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * @schema SidecarV1Alpha3SpecIngressTlsTlsCertificates
 */
export interface SidecarV1Alpha3SpecIngressTlsTlsCertificates {
  /**
   * @schema SidecarV1Alpha3SpecIngressTlsTlsCertificates#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Alpha3SpecIngressTlsTlsCertificates#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Alpha3SpecIngressTlsTlsCertificates#serverCertificate
   */
  readonly serverCertificate?: string;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressTlsTlsCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressTlsTlsCertificates(obj: SidecarV1Alpha3SpecIngressTlsTlsCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort
 */
export interface SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort {
  /**
   * @schema SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort(obj: SidecarV1Alpha3SpecOutboundTrafficPolicyEgressProxyPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema SidecarV1Alpha3SpecIngressConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarV1Alpha3SpecIngressConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive
 */
export interface SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive(obj: SidecarV1Alpha3SpecIngressConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema SidecarV1Beta1
 */
export class SidecarV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SidecarV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'Sidecar',
  }

  /**
   * Renders a Kubernetes manifest for "SidecarV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SidecarV1Beta1Props = {}): any {
    return {
      ...SidecarV1Beta1.GVK,
      ...toJson_SidecarV1Beta1Props(props),
    };
  }

  /**
   * Defines a "SidecarV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SidecarV1Beta1Props = {}) {
    super(scope, id, {
      ...SidecarV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...SidecarV1Beta1.GVK,
      ...toJson_SidecarV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema SidecarV1Beta1
 */
export interface SidecarV1Beta1Props {
  /**
   * @schema SidecarV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
   *
   * @schema SidecarV1Beta1#spec
   */
  readonly spec?: SidecarV1Beta1Spec;

}

/**
 * Converts an object of type 'SidecarV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1Props(obj: SidecarV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SidecarV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
 *
 * @schema SidecarV1Beta1Spec
 */
export interface SidecarV1Beta1Spec {
  /**
   * Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh.
   *
   * @schema SidecarV1Beta1Spec#egress
   */
  readonly egress?: SidecarV1Beta1SpecEgress[];

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarV1Beta1Spec#inboundConnectionPool
   */
  readonly inboundConnectionPool?: SidecarV1Beta1SpecInboundConnectionPool;

  /**
   * Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance.
   *
   * @schema SidecarV1Beta1Spec#ingress
   */
  readonly ingress?: SidecarV1Beta1SpecIngress[];

  /**
   * Set the default behavior of the sidecar for handling outbound traffic from the application.
   *
   * @schema SidecarV1Beta1Spec#outboundTrafficPolicy
   */
  readonly outboundTrafficPolicy?: SidecarV1Beta1SpecOutboundTrafficPolicy;

  /**
   * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
   *
   * @schema SidecarV1Beta1Spec#workloadSelector
   */
  readonly workloadSelector?: SidecarV1Beta1SpecWorkloadSelector;

}

/**
 * Converts an object of type 'SidecarV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1Spec(obj: SidecarV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egress': obj.egress?.map(y => toJson_SidecarV1Beta1SpecEgress(y)),
    'inboundConnectionPool': toJson_SidecarV1Beta1SpecInboundConnectionPool(obj.inboundConnectionPool),
    'ingress': obj.ingress?.map(y => toJson_SidecarV1Beta1SpecIngress(y)),
    'outboundTrafficPolicy': toJson_SidecarV1Beta1SpecOutboundTrafficPolicy(obj.outboundTrafficPolicy),
    'workloadSelector': toJson_SidecarV1Beta1SpecWorkloadSelector(obj.workloadSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarV1Beta1SpecEgress
 */
export interface SidecarV1Beta1SpecEgress {
  /**
   * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.
   *
   * @schema SidecarV1Beta1SpecEgress#bind
   */
  readonly bind?: string;

  /**
   * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * Valid Options: DEFAULT, IPTABLES, NONE
   *
   * @schema SidecarV1Beta1SpecEgress#captureMode
   */
  readonly captureMode?: SidecarV1Beta1SpecEgressCaptureMode;

  /**
   * One or more service hosts exposed by the listener in `namespace/dnsName` format.
   *
   * @schema SidecarV1Beta1SpecEgress#hosts
   */
  readonly hosts: string[];

  /**
   * The port associated with the listener.
   *
   * @schema SidecarV1Beta1SpecEgress#port
   */
  readonly port?: SidecarV1Beta1SpecEgressPort;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecEgress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecEgress(obj: SidecarV1Beta1SpecEgress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'hosts': obj.hosts?.map(y => y),
    'port': toJson_SidecarV1Beta1SpecEgressPort(obj.port),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPool
 */
export interface SidecarV1Beta1SpecInboundConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPool#http
   */
  readonly http?: SidecarV1Beta1SpecInboundConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPool#tcp
   */
  readonly tcp?: SidecarV1Beta1SpecInboundConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPool(obj: SidecarV1Beta1SpecInboundConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarV1Beta1SpecInboundConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarV1Beta1SpecInboundConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarV1Beta1SpecIngress
 */
export interface SidecarV1Beta1SpecIngress {
  /**
   * The IP(IPv4 or IPv6) to which the listener should be bound.
   *
   * @schema SidecarV1Beta1SpecIngress#bind
   */
  readonly bind?: string;

  /**
   * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
   *
   * Valid Options: DEFAULT, IPTABLES, NONE
   *
   * @schema SidecarV1Beta1SpecIngress#captureMode
   */
  readonly captureMode?: SidecarV1Beta1SpecIngressCaptureMode;

  /**
   * Settings controlling the volume of connections Envoy will accept from the network.
   *
   * @schema SidecarV1Beta1SpecIngress#connectionPool
   */
  readonly connectionPool?: SidecarV1Beta1SpecIngressConnectionPool;

  /**
   * The IP endpoint or Unix domain socket to which traffic should be forwarded to.
   *
   * @schema SidecarV1Beta1SpecIngress#defaultEndpoint
   */
  readonly defaultEndpoint?: string;

  /**
   * The port associated with the listener.
   *
   * @schema SidecarV1Beta1SpecIngress#port
   */
  readonly port: SidecarV1Beta1SpecIngressPort;

  /**
   * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
   *
   * @schema SidecarV1Beta1SpecIngress#tls
   */
  readonly tls?: SidecarV1Beta1SpecIngressTls;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngress' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngress(obj: SidecarV1Beta1SpecIngress | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bind': obj.bind,
    'captureMode': obj.captureMode,
    'connectionPool': toJson_SidecarV1Beta1SpecIngressConnectionPool(obj.connectionPool),
    'defaultEndpoint': obj.defaultEndpoint,
    'port': toJson_SidecarV1Beta1SpecIngressPort(obj.port),
    'tls': toJson_SidecarV1Beta1SpecIngressTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set the default behavior of the sidecar for handling outbound traffic from the application.
 *
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicy
 */
export interface SidecarV1Beta1SpecOutboundTrafficPolicy {
  /**
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicy#egressProxy
   */
  readonly egressProxy?: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy;

  /**
   *
   *
   * Valid Options: REGISTRY_ONLY, ALLOW_ANY
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicy#mode
   */
  readonly mode?: SidecarV1Beta1SpecOutboundTrafficPolicyMode;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecOutboundTrafficPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecOutboundTrafficPolicy(obj: SidecarV1Beta1SpecOutboundTrafficPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'egressProxy': toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy(obj.egressProxy),
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Criteria used to select the specific set of pods/VMs on which this `Sidecar` configuration should be applied.
 *
 * @schema SidecarV1Beta1SpecWorkloadSelector
 */
export interface SidecarV1Beta1SpecWorkloadSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied.
   *
   * @schema SidecarV1Beta1SpecWorkloadSelector#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecWorkloadSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecWorkloadSelector(obj: SidecarV1Beta1SpecWorkloadSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * When the bind address is an IP, the captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * Valid Options: DEFAULT, IPTABLES, NONE
 *
 * @schema SidecarV1Beta1SpecEgressCaptureMode
 */
export enum SidecarV1Beta1SpecEgressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * The port associated with the listener.
 *
 * @schema SidecarV1Beta1SpecEgressPort
 */
export interface SidecarV1Beta1SpecEgressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarV1Beta1SpecEgressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarV1Beta1SpecEgressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarV1Beta1SpecEgressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarV1Beta1SpecEgressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecEgressPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecEgressPort(obj: SidecarV1Beta1SpecEgressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp
 */
export interface SidecarV1Beta1SpecInboundConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarV1Beta1SpecInboundConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPoolHttp(obj: SidecarV1Beta1SpecInboundConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp
 */
export interface SidecarV1Beta1SpecInboundConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPoolTcp(obj: SidecarV1Beta1SpecInboundConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The captureMode option dictates how traffic to the listener is expected to be captured (or not).
 *
 * Valid Options: DEFAULT, IPTABLES, NONE
 *
 * @schema SidecarV1Beta1SpecIngressCaptureMode
 */
export enum SidecarV1Beta1SpecIngressCaptureMode {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** IPTABLES */
  IPTABLES = "IPTABLES",
  /** NONE */
  NONE = "NONE",
}

/**
 * Settings controlling the volume of connections Envoy will accept from the network.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPool
 */
export interface SidecarV1Beta1SpecIngressConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPool#http
   */
  readonly http?: SidecarV1Beta1SpecIngressConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPool#tcp
   */
  readonly tcp?: SidecarV1Beta1SpecIngressConnectionPoolTcp;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPool' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPool(obj: SidecarV1Beta1SpecIngressConnectionPool | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': toJson_SidecarV1Beta1SpecIngressConnectionPoolHttp(obj.http),
    'tcp': toJson_SidecarV1Beta1SpecIngressConnectionPoolTcp(obj.tcp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The port associated with the listener.
 *
 * @schema SidecarV1Beta1SpecIngressPort
 */
export interface SidecarV1Beta1SpecIngressPort {
  /**
   * Label assigned to the port.
   *
   * @schema SidecarV1Beta1SpecIngressPort#name
   */
  readonly name?: string;

  /**
   * A valid non-negative integer port number.
   *
   * @schema SidecarV1Beta1SpecIngressPort#number
   */
  readonly number?: number;

  /**
   * The protocol exposed on the port.
   *
   * @schema SidecarV1Beta1SpecIngressPort#protocol
   */
  readonly protocol?: string;

  /**
   * @schema SidecarV1Beta1SpecIngressPort#targetPort
   */
  readonly targetPort?: number;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressPort(obj: SidecarV1Beta1SpecIngressPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'number': obj.number,
    'protocol': obj.protocol,
    'targetPort': obj.targetPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Set of TLS related options that will enable TLS termination on the sidecar for requests originating from outside the mesh.
 *
 * @schema SidecarV1Beta1SpecIngressTls
 */
export interface SidecarV1Beta1SpecIngressTls {
  /**
   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in verifying a presented client side certificate.
   *
   * @schema SidecarV1Beta1SpecIngressTls#caCrl
   */
  readonly caCrl?: string;

  /**
   * Optional: If specified, only support the specified cipher list.
   *
   * @schema SidecarV1Beta1SpecIngressTls#cipherSuites
   */
  readonly cipherSuites?: string[];

  /**
   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * Same as CredentialName but for multiple certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#credentialNames
   */
  readonly credentialNames?: string[];

  /**
   * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
   *
   * @schema SidecarV1Beta1SpecIngressTls#httpsRedirect
   */
  readonly httpsRedirect?: boolean;

  /**
   * Optional: Maximum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema SidecarV1Beta1SpecIngressTls#maxProtocolVersion
   */
  readonly maxProtocolVersion?: SidecarV1Beta1SpecIngressTlsMaxProtocolVersion;

  /**
   * Optional: Minimum TLS protocol version.
   *
   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
   *
   * @schema SidecarV1Beta1SpecIngressTls#minProtocolVersion
   */
  readonly minProtocolVersion?: SidecarV1Beta1SpecIngressTlsMinProtocolVersion;

  /**
   * Optional: Indicates whether connections to this port should be secured using TLS.
   *
   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
   *
   * @schema SidecarV1Beta1SpecIngressTls#mode
   */
  readonly mode?: SidecarV1Beta1SpecIngressTlsMode;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTls#serverCertificate
   */
  readonly serverCertificate?: string;

  /**
   * A list of alternate names to verify the subject identity in the certificate presented by the client.
   *
   * @schema SidecarV1Beta1SpecIngressTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

  /**
   * Only one of `server_certificate`, `private_key` or `credential_name` or `credential_names` or `tls_certificates` should be specified.
   *
   * @schema SidecarV1Beta1SpecIngressTls#tlsCertificates
   */
  readonly tlsCertificates?: SidecarV1Beta1SpecIngressTlsTlsCertificates[];

  /**
   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#verifyCertificateHash
   */
  readonly verifyCertificateHash?: string[];

  /**
   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client certificates.
   *
   * @schema SidecarV1Beta1SpecIngressTls#verifyCertificateSpki
   */
  readonly verifyCertificateSpki?: string[];

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressTls(obj: SidecarV1Beta1SpecIngressTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'caCrl': obj.caCrl,
    'cipherSuites': obj.cipherSuites?.map(y => y),
    'credentialName': obj.credentialName,
    'credentialNames': obj.credentialNames?.map(y => y),
    'httpsRedirect': obj.httpsRedirect,
    'maxProtocolVersion': obj.maxProtocolVersion,
    'minProtocolVersion': obj.minProtocolVersion,
    'mode': obj.mode,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
    'subjectAltNames': obj.subjectAltNames?.map(y => y),
    'tlsCertificates': obj.tlsCertificates?.map(y => toJson_SidecarV1Beta1SpecIngressTlsTlsCertificates(y)),
    'verifyCertificateHash': obj.verifyCertificateHash?.map(y => y),
    'verifyCertificateSpki': obj.verifyCertificateSpki?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy
 */
export interface SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy {
  /**
   * The name of a service from the service registry.
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy#port
   */
  readonly port?: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort;

  /**
   * The name of a subset within the service.
   *
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy(obj: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 *
 *
 * Valid Options: REGISTRY_ONLY, ALLOW_ANY
 *
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicyMode
 */
export enum SidecarV1Beta1SpecOutboundTrafficPolicyMode {
  /** REGISTRY_ONLY */
  REGISTRY_UNDERSCORE_ONLY = "REGISTRY_ONLY",
  /** ALLOW_ANY */
  ALLOW_UNDERSCORE_ANY = "ALLOW_ANY",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarV1Beta1SpecInboundConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive
 */
export interface SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive(obj: SidecarV1Beta1SpecInboundConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP connection pool settings.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp
 */
export interface SidecarV1Beta1SpecIngressConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: SidecarV1Beta1SpecIngressConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of requests that will be queued while waiting for a ready connection pool connection.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of active requests to a destination.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#maxConcurrentStreams
   */
  readonly maxConcurrentStreams?: number;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPoolHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPoolHttp(obj: SidecarV1Beta1SpecIngressConnectionPoolHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'h2UpgradePolicy': obj.h2UpgradePolicy,
    'http1MaxPendingRequests': obj.http1MaxPendingRequests,
    'http2MaxRequests': obj.http2MaxRequests,
    'idleTimeout': obj.idleTimeout,
    'maxConcurrentStreams': obj.maxConcurrentStreams,
    'maxRequestsPerConnection': obj.maxRequestsPerConnection,
    'maxRetries': obj.maxRetries,
    'useClientProtocol': obj.useClientProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp
 */
export interface SidecarV1Beta1SpecIngressConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * The idle timeout for TCP connections.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * The maximum duration of a connection.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#maxConnectionDuration
   */
  readonly maxConnectionDuration?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPoolTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPoolTcp(obj: SidecarV1Beta1SpecIngressConnectionPoolTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'idleTimeout': obj.idleTimeout,
    'maxConnectionDuration': obj.maxConnectionDuration,
    'maxConnections': obj.maxConnections,
    'tcpKeepalive': toJson_SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive(obj.tcpKeepalive),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional: Maximum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema SidecarV1Beta1SpecIngressTlsMaxProtocolVersion
 */
export enum SidecarV1Beta1SpecIngressTlsMaxProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Minimum TLS protocol version.
 *
 * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3
 *
 * @schema SidecarV1Beta1SpecIngressTlsMinProtocolVersion
 */
export enum SidecarV1Beta1SpecIngressTlsMinProtocolVersion {
  /** TLS_AUTO */
  TLS_UNDERSCORE_AUTO = "TLS_AUTO",
  /** TLSV1_0 */
  TLSV1_UNDERSCORE_0 = "TLSV1_0",
  /** TLSV1_1 */
  TLSV1_UNDERSCORE_1 = "TLSV1_1",
  /** TLSV1_2 */
  TLSV1_UNDERSCORE_2 = "TLSV1_2",
  /** TLSV1_3 */
  TLSV1_UNDERSCORE_3 = "TLSV1_3",
}

/**
 * Optional: Indicates whether connections to this port should be secured using TLS.
 *
 * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL, OPTIONAL_MUTUAL
 *
 * @schema SidecarV1Beta1SpecIngressTlsMode
 */
export enum SidecarV1Beta1SpecIngressTlsMode {
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** AUTO_PASSTHROUGH */
  AUTO_UNDERSCORE_PASSTHROUGH = "AUTO_PASSTHROUGH",
  /** ISTIO_MUTUAL */
  ISTIO_UNDERSCORE_MUTUAL = "ISTIO_MUTUAL",
  /** OPTIONAL_MUTUAL */
  OPTIONAL_UNDERSCORE_MUTUAL = "OPTIONAL_MUTUAL",
}

/**
 * @schema SidecarV1Beta1SpecIngressTlsTlsCertificates
 */
export interface SidecarV1Beta1SpecIngressTlsTlsCertificates {
  /**
   * @schema SidecarV1Beta1SpecIngressTlsTlsCertificates#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTlsTlsCertificates#privateKey
   */
  readonly privateKey?: string;

  /**
   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.
   *
   * @schema SidecarV1Beta1SpecIngressTlsTlsCertificates#serverCertificate
   */
  readonly serverCertificate?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressTlsTlsCertificates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressTlsTlsCertificates(obj: SidecarV1Beta1SpecIngressTlsTlsCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caCertificates': obj.caCertificates,
    'privateKey': obj.privateKey,
    'serverCertificate': obj.serverCertificate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort
 */
export interface SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort {
  /**
   * @schema SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort(obj: SidecarV1Beta1SpecOutboundTrafficPolicyEgressProxyPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolHttpH2UpgradePolicy
 */
export enum SidecarV1Beta1SpecIngressConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_UNDERSCORE_NOT_UNDERSCORE_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive
 */
export interface SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * Maximum number of keepalive probes to send without response before deciding the connection is dead.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * The time duration a connection needs to be idle before keep-alive probes start being sent.
   *
   * @schema SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Converts an object of type 'SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive(obj: SidecarV1Beta1SpecIngressConnectionPoolTcpTcpKeepalive | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'interval': obj.interval,
    'probes': obj.probes,
    'time': obj.time,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema VirtualService
 */
export class VirtualService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'VirtualService',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceProps = {}): any {
    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(props),
    };
  }

  /**
   * Defines a "VirtualService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceProps = {}) {
    super(scope, id, {
      ...VirtualService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualService.GVK,
      ...toJson_VirtualServiceProps(resolved),
    };
  }
}

/**
 * @schema VirtualService
 */
export interface VirtualServiceProps {
  /**
   * @schema VirtualService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   *
   * @schema VirtualService#spec
   */
  readonly spec?: VirtualServiceSpec;

}

/**
 * Converts an object of type 'VirtualServiceProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceProps(obj: VirtualServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
 *
 * @schema VirtualServiceSpec
 */
export interface VirtualServiceSpec {
  /**
   * A list of namespaces to which this virtual service is exported.
   *
   * @schema VirtualServiceSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The names of gateways and sidecars that should apply these routes.
   *
   * @schema VirtualServiceSpec#gateways
   */
  readonly gateways?: string[];

  /**
   * The destination hosts to which traffic is being sent.
   *
   * @schema VirtualServiceSpec#hosts
   */
  readonly hosts?: string[];

  /**
   * An ordered list of route rules for HTTP traffic.
   *
   * @schema VirtualServiceSpec#http
   */
  readonly http?: VirtualServiceSpecHttp[];

  /**
   * An ordered list of route rules for opaque TCP traffic.
   *
   * @schema VirtualServiceSpec#tcp
   */
  readonly tcp?: VirtualServiceSpecTcp[];

  /**
   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
   *
   * @schema VirtualServiceSpec#tls
   */
  readonly tls?: VirtualServiceSpecTls[];

}

/**
 * Converts an object of type 'VirtualServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpec(obj: VirtualServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'http': obj.http?.map(y => toJson_VirtualServiceSpecHttp(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualServiceSpecTcp(y)),
    'tls': obj.tls?.map(y => toJson_VirtualServiceSpecTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttp
 */
export interface VirtualServiceSpecHttp {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   *
   * @schema VirtualServiceSpecHttp#corsPolicy
   */
  readonly corsPolicy?: VirtualServiceSpecHttpCorsPolicy;

  /**
   * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
   *
   * @schema VirtualServiceSpecHttp#delegate
   */
  readonly delegate?: VirtualServiceSpecHttpDelegate;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#directResponse
   */
  readonly directResponse?: VirtualServiceSpecHttpDirectResponse;

  /**
   * Fault injection policy to apply on HTTP traffic at the client side.
   *
   * @schema VirtualServiceSpecHttp#fault
   */
  readonly fault?: VirtualServiceSpecHttpFault;

  /**
   * @schema VirtualServiceSpecHttp#headers
   */
  readonly headers?: VirtualServiceSpecHttpHeaders;

  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceSpecHttp#match
   */
  readonly match?: VirtualServiceSpecHttpMatch[];

  /**
   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
   *
   * @schema VirtualServiceSpecHttp#mirror
   */
  readonly mirror?: VirtualServiceSpecHttpMirror;

  /**
   * @schema VirtualServiceSpecHttp#mirror_percent
   */
  readonly mirrorPercent?: number;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceSpecHttp#mirrorPercentage
   */
  readonly mirrorPercentage?: VirtualServiceSpecHttpMirrorPercentage;

  /**
   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
   *
   * @schema VirtualServiceSpecHttp#mirrors
   */
  readonly mirrors?: VirtualServiceSpecHttpMirrors[];

  /**
   * The name assigned to the route for debugging purposes.
   *
   * @schema VirtualServiceSpecHttp#name
   */
  readonly name?: string;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#redirect
   */
  readonly redirect?: VirtualServiceSpecHttpRedirect;

  /**
   * Retry policy for HTTP requests.
   *
   * @schema VirtualServiceSpecHttp#retries
   */
  readonly retries?: VirtualServiceSpecHttpRetries;

  /**
   * Rewrite HTTP URIs and Authority headers.
   *
   * @schema VirtualServiceSpecHttp#rewrite
   */
  readonly rewrite?: VirtualServiceSpecHttpRewrite;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceSpecHttp#route
   */
  readonly route?: VirtualServiceSpecHttpRoute[];

  /**
   * Timeout for HTTP requests, default is disabled.
   *
   * @schema VirtualServiceSpecHttp#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttp(obj: VirtualServiceSpecHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_VirtualServiceSpecHttpCorsPolicy(obj.corsPolicy),
    'delegate': toJson_VirtualServiceSpecHttpDelegate(obj.delegate),
    'directResponse': toJson_VirtualServiceSpecHttpDirectResponse(obj.directResponse),
    'fault': toJson_VirtualServiceSpecHttpFault(obj.fault),
    'headers': toJson_VirtualServiceSpecHttpHeaders(obj.headers),
    'match': obj.match?.map(y => toJson_VirtualServiceSpecHttpMatch(y)),
    'mirror': toJson_VirtualServiceSpecHttpMirror(obj.mirror),
    'mirror_percent': obj.mirrorPercent,
    'mirrorPercentage': toJson_VirtualServiceSpecHttpMirrorPercentage(obj.mirrorPercentage),
    'mirrors': obj.mirrors?.map(y => toJson_VirtualServiceSpecHttpMirrors(y)),
    'name': obj.name,
    'redirect': toJson_VirtualServiceSpecHttpRedirect(obj.redirect),
    'retries': toJson_VirtualServiceSpecHttpRetries(obj.retries),
    'rewrite': toJson_VirtualServiceSpecHttpRewrite(obj.rewrite),
    'route': obj.route?.map(y => toJson_VirtualServiceSpecHttpRoute(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecTcp
 */
export interface VirtualServiceSpecTcp {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceSpecTcp#match
   */
  readonly match?: VirtualServiceSpecTcpMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTcp#route
   */
  readonly route?: VirtualServiceSpecTcpRoute[];

}

/**
 * Converts an object of type 'VirtualServiceSpecTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTcp(obj: VirtualServiceSpecTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceSpecTcpMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceSpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecTls
 */
export interface VirtualServiceSpecTls {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceSpecTls#match
   */
  readonly match: VirtualServiceSpecTlsMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTls#route
   */
  readonly route?: VirtualServiceSpecTlsRoute[];

}

/**
 * Converts an object of type 'VirtualServiceSpecTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTls(obj: VirtualServiceSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceSpecTlsMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceSpecTlsRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cross-Origin Resource Sharing policy (CORS).
 *
 * @schema VirtualServiceSpecHttpCorsPolicy
 */
export interface VirtualServiceSpecHttpCorsPolicy {
  /**
   * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * List of HTTP headers that can be used when requesting the resource.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * List of HTTP methods allowed to access the resource.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * @schema VirtualServiceSpecHttpCorsPolicy#allowOrigin
   */
  readonly allowOrigin?: string[];

  /**
   * String patterns that match allowed origins.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: VirtualServiceSpecHttpCorsPolicyAllowOrigins[];

  /**
   * A list of HTTP headers that the browsers are allowed to access.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached.
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#maxAge
   */
  readonly maxAge?: string;

  /**
   * Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.
   *
   * Valid Options: FORWARD, IGNORE
   *
   * @schema VirtualServiceSpecHttpCorsPolicy#unmatchedPreflights
   */
  readonly unmatchedPreflights?: VirtualServiceSpecHttpCorsPolicyUnmatchedPreflights;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpCorsPolicy(obj: VirtualServiceSpecHttpCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => toJson_VirtualServiceSpecHttpCorsPolicyAllowOrigins(y)),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
    'unmatchedPreflights': obj.unmatchedPreflights,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
 *
 * @schema VirtualServiceSpecHttpDelegate
 */
export interface VirtualServiceSpecHttpDelegate {
  /**
   * Name specifies the name of the delegate VirtualService.
   *
   * @schema VirtualServiceSpecHttpDelegate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the namespace where the delegate VirtualService resides.
   *
   * @schema VirtualServiceSpecHttpDelegate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDelegate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpDelegate(obj: VirtualServiceSpecHttpDelegate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceSpecHttpDirectResponse
 */
export interface VirtualServiceSpecHttpDirectResponse {
  /**
   * Specifies the content of the response body.
   *
   * @schema VirtualServiceSpecHttpDirectResponse#body
   */
  readonly body?: VirtualServiceSpecHttpDirectResponseBody;

  /**
   * Specifies the HTTP response status to be returned.
   *
   * @schema VirtualServiceSpecHttpDirectResponse#status
   */
  readonly status: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDirectResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpDirectResponse(obj: VirtualServiceSpecHttpDirectResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_VirtualServiceSpecHttpDirectResponseBody(obj.body),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at the client side.
 *
 * @schema VirtualServiceSpecHttpFault
 */
export interface VirtualServiceSpecHttpFault {
  /**
   * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
   *
   * @schema VirtualServiceSpecHttpFault#abort
   */
  readonly abort?: VirtualServiceSpecHttpFaultAbort;

  /**
   * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
   *
   * @schema VirtualServiceSpecHttpFault#delay
   */
  readonly delay?: VirtualServiceSpecHttpFaultDelay;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpFault(obj: VirtualServiceSpecHttpFault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_VirtualServiceSpecHttpFaultAbort(obj.abort),
    'delay': toJson_VirtualServiceSpecHttpFaultDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpHeaders
 */
export interface VirtualServiceSpecHttpHeaders {
  /**
   * @schema VirtualServiceSpecHttpHeaders#request
   */
  readonly request?: VirtualServiceSpecHttpHeadersRequest;

  /**
   * @schema VirtualServiceSpecHttpHeaders#response
   */
  readonly response?: VirtualServiceSpecHttpHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpHeaders(obj: VirtualServiceSpecHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceSpecHttpHeadersRequest(obj.request),
    'response': toJson_VirtualServiceSpecHttpHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpMatch
 */
export interface VirtualServiceSpecHttpMatch {
  /**
   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#authority
   */
  readonly authority?: VirtualServiceSpecHttpMatchAuthority;

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecHttpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   *
   * @schema VirtualServiceSpecHttpMatch#headers
   */
  readonly headers?: { [key: string]: VirtualServiceSpecHttpMatchHeaders };

  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   *
   * @schema VirtualServiceSpecHttpMatch#ignoreUriCase
   */
  readonly ignoreUriCase?: boolean;

  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#method
   */
  readonly method?: VirtualServiceSpecHttpMatchMethod;

  /**
   * The name assigned to a match.
   *
   * @schema VirtualServiceSpecHttpMatch#name
   */
  readonly name?: string;

  /**
   * Specifies the ports on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMatch#port
   */
  readonly port?: number;

  /**
   * Query parameters for matching.
   *
   * @schema VirtualServiceSpecHttpMatch#queryParams
   */
  readonly queryParams?: { [key: string]: VirtualServiceSpecHttpMatchQueryParams };

  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#scheme
   */
  readonly scheme?: VirtualServiceSpecHttpMatchScheme;

  /**
   * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
   *
   * @schema VirtualServiceSpecHttpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecHttpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * The human readable prefix to use when emitting statistics for this route.
   *
   * @schema VirtualServiceSpecHttpMatch#statPrefix
   */
  readonly statPrefix?: string;

  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatch#uri
   */
  readonly uri?: VirtualServiceSpecHttpMatchUri;

  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   *
   * @schema VirtualServiceSpecHttpMatch#withoutHeaders
   */
  readonly withoutHeaders?: { [key: string]: VirtualServiceSpecHttpMatchWithoutHeaders };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatch(obj: VirtualServiceSpecHttpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': toJson_VirtualServiceSpecHttpMatchAuthority(obj.authority),
    'gateways': obj.gateways?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchHeaders(i[1]) }), {})),
    'ignoreUriCase': obj.ignoreUriCase,
    'method': toJson_VirtualServiceSpecHttpMatchMethod(obj.method),
    'name': obj.name,
    'port': obj.port,
    'queryParams': ((obj.queryParams) === undefined) ? undefined : (Object.entries(obj.queryParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchQueryParams(i[1]) }), {})),
    'scheme': toJson_VirtualServiceSpecHttpMatchScheme(obj.scheme),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'statPrefix': obj.statPrefix,
    'uri': toJson_VirtualServiceSpecHttpMatchUri(obj.uri),
    'withoutHeaders': ((obj.withoutHeaders) === undefined) ? undefined : (Object.entries(obj.withoutHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceSpecHttpMatchWithoutHeaders(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
 *
 * @schema VirtualServiceSpecHttpMirror
 */
export interface VirtualServiceSpecHttpMirror {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpMirror#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMirror#port
   */
  readonly port?: VirtualServiceSpecHttpMirrorPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpMirror#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirror(obj: VirtualServiceSpecHttpMirror | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecHttpMirrorPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of the traffic to be mirrored by the `mirror` field.
 *
 * @schema VirtualServiceSpecHttpMirrorPercentage
 */
export interface VirtualServiceSpecHttpMirrorPercentage {
  /**
   * @schema VirtualServiceSpecHttpMirrorPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirrorPercentage(obj: VirtualServiceSpecHttpMirrorPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpMirrors
 */
export interface VirtualServiceSpecHttpMirrors {
  /**
   * Destination specifies the target of the mirror operation.
   *
   * @schema VirtualServiceSpecHttpMirrors#destination
   */
  readonly destination: VirtualServiceSpecHttpMirrorsDestination;

  /**
   * Percentage of the traffic to be mirrored by the `destination` field.
   *
   * @schema VirtualServiceSpecHttpMirrors#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpMirrorsPercentage;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirrors(obj: VirtualServiceSpecHttpMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecHttpMirrorsDestination(obj.destination),
    'percentage': toJson_VirtualServiceSpecHttpMirrorsPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceSpecHttpRedirect
 */
export interface VirtualServiceSpecHttpRedirect {
  /**
   * On a redirect, overwrite the Authority/Host portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#authority
   */
  readonly authority?: string;

  /**
   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
   *
   * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
   *
   * @schema VirtualServiceSpecHttpRedirect#derivePort
   */
  readonly derivePort?: VirtualServiceSpecHttpRedirectDerivePort;

  /**
   * On a redirect, overwrite the port portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#port
   */
  readonly port?: number;

  /**
   * On a redirect, Specifies the HTTP status code to use in the redirect response.
   *
   * @schema VirtualServiceSpecHttpRedirect#redirectCode
   */
  readonly redirectCode?: number;

  /**
   * On a redirect, overwrite the scheme portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#scheme
   */
  readonly scheme?: string;

  /**
   * On a redirect, overwrite the Path portion of the URL with this value.
   *
   * @schema VirtualServiceSpecHttpRedirect#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRedirect(obj: VirtualServiceSpecHttpRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'derivePort': obj.derivePort,
    'port': obj.port,
    'redirectCode': obj.redirectCode,
    'scheme': obj.scheme,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry policy for HTTP requests.
 *
 * @schema VirtualServiceSpecHttpRetries
 */
export interface VirtualServiceSpecHttpRetries {
  /**
   * Number of retries to be allowed for a given request.
   *
   * @schema VirtualServiceSpecHttpRetries#attempts
   */
  readonly attempts?: number;

  /**
   * Specifies the minimum duration between retry attempts.
   *
   * @schema VirtualServiceSpecHttpRetries#backoff
   */
  readonly backoff?: string;

  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   *
   * @schema VirtualServiceSpecHttpRetries#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Flag to specify whether the retries should ignore previously tried hosts during retry.
   *
   * @schema VirtualServiceSpecHttpRetries#retryIgnorePreviousHosts
   */
  readonly retryIgnorePreviousHosts?: boolean;

  /**
   * Specifies the conditions under which retry takes place.
   *
   * @schema VirtualServiceSpecHttpRetries#retryOn
   */
  readonly retryOn?: string;

  /**
   * Flag to specify whether the retries should retry to other localities.
   *
   * @schema VirtualServiceSpecHttpRetries#retryRemoteLocalities
   */
  readonly retryRemoteLocalities?: boolean;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRetries' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRetries(obj: VirtualServiceSpecHttpRetries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attempts': obj.attempts,
    'backoff': obj.backoff,
    'perTryTimeout': obj.perTryTimeout,
    'retryIgnorePreviousHosts': obj.retryIgnorePreviousHosts,
    'retryOn': obj.retryOn,
    'retryRemoteLocalities': obj.retryRemoteLocalities,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rewrite HTTP URIs and Authority headers.
 *
 * @schema VirtualServiceSpecHttpRewrite
 */
export interface VirtualServiceSpecHttpRewrite {
  /**
   * rewrite the Authority/Host header with this value.
   *
   * @schema VirtualServiceSpecHttpRewrite#authority
   */
  readonly authority?: string;

  /**
   * rewrite the path (or the prefix) portion of the URI with this value.
   *
   * @schema VirtualServiceSpecHttpRewrite#uri
   */
  readonly uri?: string;

  /**
   * rewrite the path portion of the URI with the specified regex.
   *
   * @schema VirtualServiceSpecHttpRewrite#uriRegexRewrite
   */
  readonly uriRegexRewrite?: VirtualServiceSpecHttpRewriteUriRegexRewrite;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRewrite(obj: VirtualServiceSpecHttpRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'uri': obj.uri,
    'uriRegexRewrite': toJson_VirtualServiceSpecHttpRewriteUriRegexRewrite(obj.uriRegexRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpRoute
 */
export interface VirtualServiceSpecHttpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceSpecHttpRoute#destination
   */
  readonly destination: VirtualServiceSpecHttpRouteDestination;

  /**
   * @schema VirtualServiceSpecHttpRoute#headers
   */
  readonly headers?: VirtualServiceSpecHttpRouteHeaders;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceSpecHttpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRoute(obj: VirtualServiceSpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecHttpRouteDestination(obj.destination),
    'headers': toJson_VirtualServiceSpecHttpRouteHeaders(obj.headers),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecTcpMatch
 */
export interface VirtualServiceSpecTcpMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceSpecTcpMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecTcpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTcpMatch#port
   */
  readonly port?: number;

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceSpecTcpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecTcpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * @schema VirtualServiceSpecTcpMatch#sourceSubnet
   */
  readonly sourceSubnet?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTcpMatch(obj: VirtualServiceSpecTcpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'sourceSubnet': obj.sourceSubnet,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecTcpRoute
 */
export interface VirtualServiceSpecTcpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTcpRoute#destination
   */
  readonly destination: VirtualServiceSpecTcpRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceSpecTcpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTcpRoute(obj: VirtualServiceSpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecTcpRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecTlsMatch
 */
export interface VirtualServiceSpecTlsMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceSpecTlsMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceSpecTlsMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTlsMatch#port
   */
  readonly port?: number;

  /**
   * SNI (server name indicator) to match on.
   *
   * @schema VirtualServiceSpecTlsMatch#sniHosts
   */
  readonly sniHosts: string[];

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceSpecTlsMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceSpecTlsMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTlsMatch(obj: VirtualServiceSpecTlsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sniHosts': obj.sniHosts?.map(y => y),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecTlsRoute
 */
export interface VirtualServiceSpecTlsRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceSpecTlsRoute#destination
   */
  readonly destination: VirtualServiceSpecTlsRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceSpecTlsRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTlsRoute(obj: VirtualServiceSpecTlsRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceSpecTlsRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins
 */
export interface VirtualServiceSpecHttpCorsPolicyAllowOrigins {
  /**
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpCorsPolicyAllowOrigins#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpCorsPolicyAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpCorsPolicyAllowOrigins(obj: VirtualServiceSpecHttpCorsPolicyAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.
 *
 * Valid Options: FORWARD, IGNORE
 *
 * @schema VirtualServiceSpecHttpCorsPolicyUnmatchedPreflights
 */
export enum VirtualServiceSpecHttpCorsPolicyUnmatchedPreflights {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** FORWARD */
  FORWARD = "FORWARD",
  /** IGNORE */
  IGNORE = "IGNORE",
}

/**
 * Specifies the content of the response body.
 *
 * @schema VirtualServiceSpecHttpDirectResponseBody
 */
export interface VirtualServiceSpecHttpDirectResponseBody {
  /**
   * response body as base64 encoded bytes.
   *
   * @schema VirtualServiceSpecHttpDirectResponseBody#bytes
   */
  readonly bytes?: string;

  /**
   * @schema VirtualServiceSpecHttpDirectResponseBody#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpDirectResponseBody' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpDirectResponseBody(obj: VirtualServiceSpecHttpDirectResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytes': obj.bytes,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
 *
 * @schema VirtualServiceSpecHttpFaultAbort
 */
export interface VirtualServiceSpecHttpFaultAbort {
  /**
   * GRPC status code to use to abort the request.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#grpcStatus
   */
  readonly grpcStatus?: string;

  /**
   * @schema VirtualServiceSpecHttpFaultAbort#http2Error
   */
  readonly http2Error?: string;

  /**
   * HTTP status code to use to abort the Http request.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage of requests to be aborted with the error code provided.
   *
   * @schema VirtualServiceSpecHttpFaultAbort#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpFaultAbortPercentage;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultAbort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpFaultAbort(obj: VirtualServiceSpecHttpFaultAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcStatus': obj.grpcStatus,
    'http2Error': obj.http2Error,
    'httpStatus': obj.httpStatus,
    'percentage': toJson_VirtualServiceSpecHttpFaultAbortPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
 *
 * @schema VirtualServiceSpecHttpFaultDelay
 */
export interface VirtualServiceSpecHttpFaultDelay {
  /**
   * @schema VirtualServiceSpecHttpFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema VirtualServiceSpecHttpFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay will be injected (0-100).
   *
   * @schema VirtualServiceSpecHttpFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay will be injected.
   *
   * @schema VirtualServiceSpecHttpFaultDelay#percentage
   */
  readonly percentage?: VirtualServiceSpecHttpFaultDelayPercentage;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpFaultDelay(obj: VirtualServiceSpecHttpFaultDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exponentialDelay': obj.exponentialDelay,
    'fixedDelay': obj.fixedDelay,
    'percent': obj.percent,
    'percentage': toJson_VirtualServiceSpecHttpFaultDelayPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpHeadersRequest
 */
export interface VirtualServiceSpecHttpHeadersRequest {
  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpHeadersRequest(obj: VirtualServiceSpecHttpHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpHeadersResponse
 */
export interface VirtualServiceSpecHttpHeadersResponse {
  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpHeadersResponse(obj: VirtualServiceSpecHttpHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchAuthority
 */
export interface VirtualServiceSpecHttpMatchAuthority {
  /**
   * @schema VirtualServiceSpecHttpMatchAuthority#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchAuthority#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchAuthority#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchAuthority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchAuthority(obj: VirtualServiceSpecHttpMatchAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchHeaders
 */
export interface VirtualServiceSpecHttpMatchHeaders {
  /**
   * @schema VirtualServiceSpecHttpMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchHeaders(obj: VirtualServiceSpecHttpMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchMethod
 */
export interface VirtualServiceSpecHttpMatchMethod {
  /**
   * @schema VirtualServiceSpecHttpMatchMethod#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchMethod#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchMethod#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchMethod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchMethod(obj: VirtualServiceSpecHttpMatchMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchQueryParams
 */
export interface VirtualServiceSpecHttpMatchQueryParams {
  /**
   * @schema VirtualServiceSpecHttpMatchQueryParams#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchQueryParams#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchQueryParams#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchQueryParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchQueryParams(obj: VirtualServiceSpecHttpMatchQueryParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchScheme
 */
export interface VirtualServiceSpecHttpMatchScheme {
  /**
   * @schema VirtualServiceSpecHttpMatchScheme#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchScheme#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchScheme#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchScheme' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchScheme(obj: VirtualServiceSpecHttpMatchScheme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceSpecHttpMatchUri
 */
export interface VirtualServiceSpecHttpMatchUri {
  /**
   * @schema VirtualServiceSpecHttpMatchUri#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchUri#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchUri#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchUri' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchUri(obj: VirtualServiceSpecHttpMatchUri | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpMatchWithoutHeaders
 */
export interface VirtualServiceSpecHttpMatchWithoutHeaders {
  /**
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpMatchWithoutHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMatchWithoutHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMatchWithoutHeaders(obj: VirtualServiceSpecHttpMatchWithoutHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpMirrorPort
 */
export interface VirtualServiceSpecHttpMirrorPort {
  /**
   * @schema VirtualServiceSpecHttpMirrorPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirrorPort(obj: VirtualServiceSpecHttpMirrorPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination specifies the target of the mirror operation.
 *
 * @schema VirtualServiceSpecHttpMirrorsDestination
 */
export interface VirtualServiceSpecHttpMirrorsDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpMirrorsDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpMirrorsDestination#port
   */
  readonly port?: VirtualServiceSpecHttpMirrorsDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpMirrorsDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorsDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirrorsDestination(obj: VirtualServiceSpecHttpMirrorsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecHttpMirrorsDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of the traffic to be mirrored by the `destination` field.
 *
 * @schema VirtualServiceSpecHttpMirrorsPercentage
 */
export interface VirtualServiceSpecHttpMirrorsPercentage {
  /**
   * @schema VirtualServiceSpecHttpMirrorsPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorsPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirrorsPercentage(obj: VirtualServiceSpecHttpMirrorsPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
 *
 * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
 *
 * @schema VirtualServiceSpecHttpRedirectDerivePort
 */
export enum VirtualServiceSpecHttpRedirectDerivePort {
  /** FROM_PROTOCOL_DEFAULT */
  FROM_UNDERSCORE_PROTOCOL_UNDERSCORE_DEFAULT = "FROM_PROTOCOL_DEFAULT",
  /** FROM_REQUEST_PORT */
  FROM_UNDERSCORE_REQUEST_UNDERSCORE_PORT = "FROM_REQUEST_PORT",
}

/**
 * rewrite the path portion of the URI with the specified regex.
 *
 * @schema VirtualServiceSpecHttpRewriteUriRegexRewrite
 */
export interface VirtualServiceSpecHttpRewriteUriRegexRewrite {
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceSpecHttpRewriteUriRegexRewrite#match
   */
  readonly match?: string;

  /**
   * The string that should replace into matching portions of original URI.
   *
   * @schema VirtualServiceSpecHttpRewriteUriRegexRewrite#rewrite
   */
  readonly rewrite?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRewriteUriRegexRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRewriteUriRegexRewrite(obj: VirtualServiceSpecHttpRewriteUriRegexRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match,
    'rewrite': obj.rewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceSpecHttpRouteDestination
 */
export interface VirtualServiceSpecHttpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#port
   */
  readonly port?: VirtualServiceSpecHttpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecHttpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRouteDestination(obj: VirtualServiceSpecHttpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecHttpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeaders
 */
export interface VirtualServiceSpecHttpRouteHeaders {
  /**
   * @schema VirtualServiceSpecHttpRouteHeaders#request
   */
  readonly request?: VirtualServiceSpecHttpRouteHeadersRequest;

  /**
   * @schema VirtualServiceSpecHttpRouteHeaders#response
   */
  readonly response?: VirtualServiceSpecHttpRouteHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeaders(obj: VirtualServiceSpecHttpRouteHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceSpecHttpRouteHeadersRequest(obj.request),
    'response': toJson_VirtualServiceSpecHttpRouteHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceSpecTcpRouteDestination
 */
export interface VirtualServiceSpecTcpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#port
   */
  readonly port?: VirtualServiceSpecTcpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecTcpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTcpRouteDestination(obj: VirtualServiceSpecTcpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecTcpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceSpecTlsRouteDestination
 */
export interface VirtualServiceSpecTlsRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#port
   */
  readonly port?: VirtualServiceSpecTlsRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceSpecTlsRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTlsRouteDestination(obj: VirtualServiceSpecTlsRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceSpecTlsRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of requests to be aborted with the error code provided.
 *
 * @schema VirtualServiceSpecHttpFaultAbortPercentage
 */
export interface VirtualServiceSpecHttpFaultAbortPercentage {
  /**
   * @schema VirtualServiceSpecHttpFaultAbortPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultAbortPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpFaultAbortPercentage(obj: VirtualServiceSpecHttpFaultAbortPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of requests on which the delay will be injected.
 *
 * @schema VirtualServiceSpecHttpFaultDelayPercentage
 */
export interface VirtualServiceSpecHttpFaultDelayPercentage {
  /**
   * @schema VirtualServiceSpecHttpFaultDelayPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpFaultDelayPercentage(obj: VirtualServiceSpecHttpFaultDelayPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpMirrorsDestinationPort
 */
export interface VirtualServiceSpecHttpMirrorsDestinationPort {
  /**
   * @schema VirtualServiceSpecHttpMirrorsDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpMirrorsDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpMirrorsDestinationPort(obj: VirtualServiceSpecHttpMirrorsDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecHttpRouteDestinationPort
 */
export interface VirtualServiceSpecHttpRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecHttpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRouteDestinationPort(obj: VirtualServiceSpecHttpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeadersRequest
 */
export interface VirtualServiceSpecHttpRouteHeadersRequest {
  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeadersRequest(obj: VirtualServiceSpecHttpRouteHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceSpecHttpRouteHeadersResponse
 */
export interface VirtualServiceSpecHttpRouteHeadersResponse {
  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceSpecHttpRouteHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceSpecHttpRouteHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecHttpRouteHeadersResponse(obj: VirtualServiceSpecHttpRouteHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecTcpRouteDestinationPort
 */
export interface VirtualServiceSpecTcpRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecTcpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTcpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTcpRouteDestinationPort(obj: VirtualServiceSpecTcpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceSpecTlsRouteDestinationPort
 */
export interface VirtualServiceSpecTlsRouteDestinationPort {
  /**
   * @schema VirtualServiceSpecTlsRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceSpecTlsRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceSpecTlsRouteDestinationPort(obj: VirtualServiceSpecTlsRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema VirtualServiceV1Alpha3
 */
export class VirtualServiceV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualServiceV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'VirtualService',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualServiceV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceV1Alpha3Props = {}): any {
    return {
      ...VirtualServiceV1Alpha3.GVK,
      ...toJson_VirtualServiceV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "VirtualServiceV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceV1Alpha3Props = {}) {
    super(scope, id, {
      ...VirtualServiceV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualServiceV1Alpha3.GVK,
      ...toJson_VirtualServiceV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema VirtualServiceV1Alpha3
 */
export interface VirtualServiceV1Alpha3Props {
  /**
   * @schema VirtualServiceV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   *
   * @schema VirtualServiceV1Alpha3#spec
   */
  readonly spec?: VirtualServiceV1Alpha3Spec;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3Props(obj: VirtualServiceV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServiceV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
 *
 * @schema VirtualServiceV1Alpha3Spec
 */
export interface VirtualServiceV1Alpha3Spec {
  /**
   * A list of namespaces to which this virtual service is exported.
   *
   * @schema VirtualServiceV1Alpha3Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The names of gateways and sidecars that should apply these routes.
   *
   * @schema VirtualServiceV1Alpha3Spec#gateways
   */
  readonly gateways?: string[];

  /**
   * The destination hosts to which traffic is being sent.
   *
   * @schema VirtualServiceV1Alpha3Spec#hosts
   */
  readonly hosts?: string[];

  /**
   * An ordered list of route rules for HTTP traffic.
   *
   * @schema VirtualServiceV1Alpha3Spec#http
   */
  readonly http?: VirtualServiceV1Alpha3SpecHttp[];

  /**
   * An ordered list of route rules for opaque TCP traffic.
   *
   * @schema VirtualServiceV1Alpha3Spec#tcp
   */
  readonly tcp?: VirtualServiceV1Alpha3SpecTcp[];

  /**
   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
   *
   * @schema VirtualServiceV1Alpha3Spec#tls
   */
  readonly tls?: VirtualServiceV1Alpha3SpecTls[];

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3Spec(obj: VirtualServiceV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'http': obj.http?.map(y => toJson_VirtualServiceV1Alpha3SpecHttp(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualServiceV1Alpha3SpecTcp(y)),
    'tls': obj.tls?.map(y => toJson_VirtualServiceV1Alpha3SpecTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttp
 */
export interface VirtualServiceV1Alpha3SpecHttp {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#corsPolicy
   */
  readonly corsPolicy?: VirtualServiceV1Alpha3SpecHttpCorsPolicy;

  /**
   * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#delegate
   */
  readonly delegate?: VirtualServiceV1Alpha3SpecHttpDelegate;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#directResponse
   */
  readonly directResponse?: VirtualServiceV1Alpha3SpecHttpDirectResponse;

  /**
   * Fault injection policy to apply on HTTP traffic at the client side.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#fault
   */
  readonly fault?: VirtualServiceV1Alpha3SpecHttpFault;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttp#headers
   */
  readonly headers?: VirtualServiceV1Alpha3SpecHttpHeaders;

  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#match
   */
  readonly match?: VirtualServiceV1Alpha3SpecHttpMatch[];

  /**
   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#mirror
   */
  readonly mirror?: VirtualServiceV1Alpha3SpecHttpMirror;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttp#mirror_percent
   */
  readonly mirrorPercent?: number;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#mirrorPercentage
   */
  readonly mirrorPercentage?: VirtualServiceV1Alpha3SpecHttpMirrorPercentage;

  /**
   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#mirrors
   */
  readonly mirrors?: VirtualServiceV1Alpha3SpecHttpMirrors[];

  /**
   * The name assigned to the route for debugging purposes.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#name
   */
  readonly name?: string;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#redirect
   */
  readonly redirect?: VirtualServiceV1Alpha3SpecHttpRedirect;

  /**
   * Retry policy for HTTP requests.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#retries
   */
  readonly retries?: VirtualServiceV1Alpha3SpecHttpRetries;

  /**
   * Rewrite HTTP URIs and Authority headers.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#rewrite
   */
  readonly rewrite?: VirtualServiceV1Alpha3SpecHttpRewrite;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#route
   */
  readonly route?: VirtualServiceV1Alpha3SpecHttpRoute[];

  /**
   * Timeout for HTTP requests, default is disabled.
   *
   * @schema VirtualServiceV1Alpha3SpecHttp#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttp(obj: VirtualServiceV1Alpha3SpecHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_VirtualServiceV1Alpha3SpecHttpCorsPolicy(obj.corsPolicy),
    'delegate': toJson_VirtualServiceV1Alpha3SpecHttpDelegate(obj.delegate),
    'directResponse': toJson_VirtualServiceV1Alpha3SpecHttpDirectResponse(obj.directResponse),
    'fault': toJson_VirtualServiceV1Alpha3SpecHttpFault(obj.fault),
    'headers': toJson_VirtualServiceV1Alpha3SpecHttpHeaders(obj.headers),
    'match': obj.match?.map(y => toJson_VirtualServiceV1Alpha3SpecHttpMatch(y)),
    'mirror': toJson_VirtualServiceV1Alpha3SpecHttpMirror(obj.mirror),
    'mirror_percent': obj.mirrorPercent,
    'mirrorPercentage': toJson_VirtualServiceV1Alpha3SpecHttpMirrorPercentage(obj.mirrorPercentage),
    'mirrors': obj.mirrors?.map(y => toJson_VirtualServiceV1Alpha3SpecHttpMirrors(y)),
    'name': obj.name,
    'redirect': toJson_VirtualServiceV1Alpha3SpecHttpRedirect(obj.redirect),
    'retries': toJson_VirtualServiceV1Alpha3SpecHttpRetries(obj.retries),
    'rewrite': toJson_VirtualServiceV1Alpha3SpecHttpRewrite(obj.rewrite),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Alpha3SpecHttpRoute(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecTcp
 */
export interface VirtualServiceV1Alpha3SpecTcp {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Alpha3SpecTcp#match
   */
  readonly match?: VirtualServiceV1Alpha3SpecTcpMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceV1Alpha3SpecTcp#route
   */
  readonly route?: VirtualServiceV1Alpha3SpecTcpRoute[];

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTcp(obj: VirtualServiceV1Alpha3SpecTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceV1Alpha3SpecTcpMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Alpha3SpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecTls
 */
export interface VirtualServiceV1Alpha3SpecTls {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Alpha3SpecTls#match
   */
  readonly match: VirtualServiceV1Alpha3SpecTlsMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceV1Alpha3SpecTls#route
   */
  readonly route?: VirtualServiceV1Alpha3SpecTlsRoute[];

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTls(obj: VirtualServiceV1Alpha3SpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceV1Alpha3SpecTlsMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Alpha3SpecTlsRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cross-Origin Resource Sharing policy (CORS).
 *
 * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy
 */
export interface VirtualServiceV1Alpha3SpecHttpCorsPolicy {
  /**
   * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * List of HTTP headers that can be used when requesting the resource.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * List of HTTP methods allowed to access the resource.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#allowOrigin
   */
  readonly allowOrigin?: string[];

  /**
   * String patterns that match allowed origins.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins[];

  /**
   * A list of HTTP headers that the browsers are allowed to access.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#maxAge
   */
  readonly maxAge?: string;

  /**
   * Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.
   *
   * Valid Options: FORWARD, IGNORE
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicy#unmatchedPreflights
   */
  readonly unmatchedPreflights?: VirtualServiceV1Alpha3SpecHttpCorsPolicyUnmatchedPreflights;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpCorsPolicy(obj: VirtualServiceV1Alpha3SpecHttpCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => toJson_VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins(y)),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
    'unmatchedPreflights': obj.unmatchedPreflights,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpDelegate
 */
export interface VirtualServiceV1Alpha3SpecHttpDelegate {
  /**
   * Name specifies the name of the delegate VirtualService.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpDelegate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the namespace where the delegate VirtualService resides.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpDelegate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpDelegate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpDelegate(obj: VirtualServiceV1Alpha3SpecHttpDelegate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpDirectResponse
 */
export interface VirtualServiceV1Alpha3SpecHttpDirectResponse {
  /**
   * Specifies the content of the response body.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpDirectResponse#body
   */
  readonly body?: VirtualServiceV1Alpha3SpecHttpDirectResponseBody;

  /**
   * Specifies the HTTP response status to be returned.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpDirectResponse#status
   */
  readonly status: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpDirectResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpDirectResponse(obj: VirtualServiceV1Alpha3SpecHttpDirectResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_VirtualServiceV1Alpha3SpecHttpDirectResponseBody(obj.body),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at the client side.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpFault
 */
export interface VirtualServiceV1Alpha3SpecHttpFault {
  /**
   * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFault#abort
   */
  readonly abort?: VirtualServiceV1Alpha3SpecHttpFaultAbort;

  /**
   * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFault#delay
   */
  readonly delay?: VirtualServiceV1Alpha3SpecHttpFaultDelay;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpFault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpFault(obj: VirtualServiceV1Alpha3SpecHttpFault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_VirtualServiceV1Alpha3SpecHttpFaultAbort(obj.abort),
    'delay': toJson_VirtualServiceV1Alpha3SpecHttpFaultDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpHeaders
 */
export interface VirtualServiceV1Alpha3SpecHttpHeaders {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeaders#request
   */
  readonly request?: VirtualServiceV1Alpha3SpecHttpHeadersRequest;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeaders#response
   */
  readonly response?: VirtualServiceV1Alpha3SpecHttpHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpHeaders(obj: VirtualServiceV1Alpha3SpecHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceV1Alpha3SpecHttpHeadersRequest(obj.request),
    'response': toJson_VirtualServiceV1Alpha3SpecHttpHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpMatch
 */
export interface VirtualServiceV1Alpha3SpecHttpMatch {
  /**
   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#authority
   */
  readonly authority?: VirtualServiceV1Alpha3SpecHttpMatchAuthority;

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#headers
   */
  readonly headers?: { [key: string]: VirtualServiceV1Alpha3SpecHttpMatchHeaders };

  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#ignoreUriCase
   */
  readonly ignoreUriCase?: boolean;

  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#method
   */
  readonly method?: VirtualServiceV1Alpha3SpecHttpMatchMethod;

  /**
   * The name assigned to a match.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#name
   */
  readonly name?: string;

  /**
   * Specifies the ports on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#port
   */
  readonly port?: number;

  /**
   * Query parameters for matching.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#queryParams
   */
  readonly queryParams?: { [key: string]: VirtualServiceV1Alpha3SpecHttpMatchQueryParams };

  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#scheme
   */
  readonly scheme?: VirtualServiceV1Alpha3SpecHttpMatchScheme;

  /**
   * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * The human readable prefix to use when emitting statistics for this route.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#statPrefix
   */
  readonly statPrefix?: string;

  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#uri
   */
  readonly uri?: VirtualServiceV1Alpha3SpecHttpMatchUri;

  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatch#withoutHeaders
   */
  readonly withoutHeaders?: { [key: string]: VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders };

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatch(obj: VirtualServiceV1Alpha3SpecHttpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': toJson_VirtualServiceV1Alpha3SpecHttpMatchAuthority(obj.authority),
    'gateways': obj.gateways?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Alpha3SpecHttpMatchHeaders(i[1]) }), {})),
    'ignoreUriCase': obj.ignoreUriCase,
    'method': toJson_VirtualServiceV1Alpha3SpecHttpMatchMethod(obj.method),
    'name': obj.name,
    'port': obj.port,
    'queryParams': ((obj.queryParams) === undefined) ? undefined : (Object.entries(obj.queryParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Alpha3SpecHttpMatchQueryParams(i[1]) }), {})),
    'scheme': toJson_VirtualServiceV1Alpha3SpecHttpMatchScheme(obj.scheme),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'statPrefix': obj.statPrefix,
    'uri': toJson_VirtualServiceV1Alpha3SpecHttpMatchUri(obj.uri),
    'withoutHeaders': ((obj.withoutHeaders) === undefined) ? undefined : (Object.entries(obj.withoutHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMirror
 */
export interface VirtualServiceV1Alpha3SpecHttpMirror {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirror#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirror#port
   */
  readonly port?: VirtualServiceV1Alpha3SpecHttpMirrorPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirror#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirror(obj: VirtualServiceV1Alpha3SpecHttpMirror | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Alpha3SpecHttpMirrorPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of the traffic to be mirrored by the `mirror` field.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMirrorPercentage
 */
export interface VirtualServiceV1Alpha3SpecHttpMirrorPercentage {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirrorPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirrorPercentage(obj: VirtualServiceV1Alpha3SpecHttpMirrorPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpMirrors
 */
export interface VirtualServiceV1Alpha3SpecHttpMirrors {
  /**
   * Destination specifies the target of the mirror operation.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirrors#destination
   */
  readonly destination: VirtualServiceV1Alpha3SpecHttpMirrorsDestination;

  /**
   * Percentage of the traffic to be mirrored by the `destination` field.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirrors#percentage
   */
  readonly percentage?: VirtualServiceV1Alpha3SpecHttpMirrorsPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirrors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirrors(obj: VirtualServiceV1Alpha3SpecHttpMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Alpha3SpecHttpMirrorsDestination(obj.destination),
    'percentage': toJson_VirtualServiceV1Alpha3SpecHttpMirrorsPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRedirect
 */
export interface VirtualServiceV1Alpha3SpecHttpRedirect {
  /**
   * On a redirect, overwrite the Authority/Host portion of the URL with this value.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRedirect#authority
   */
  readonly authority?: string;

  /**
   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
   *
   * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRedirect#derivePort
   */
  readonly derivePort?: VirtualServiceV1Alpha3SpecHttpRedirectDerivePort;

  /**
   * On a redirect, overwrite the port portion of the URL with this value.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRedirect#port
   */
  readonly port?: number;

  /**
   * On a redirect, Specifies the HTTP status code to use in the redirect response.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRedirect#redirectCode
   */
  readonly redirectCode?: number;

  /**
   * On a redirect, overwrite the scheme portion of the URL with this value.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRedirect#scheme
   */
  readonly scheme?: string;

  /**
   * On a redirect, overwrite the Path portion of the URL with this value.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRedirect#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRedirect(obj: VirtualServiceV1Alpha3SpecHttpRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'derivePort': obj.derivePort,
    'port': obj.port,
    'redirectCode': obj.redirectCode,
    'scheme': obj.scheme,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry policy for HTTP requests.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRetries
 */
export interface VirtualServiceV1Alpha3SpecHttpRetries {
  /**
   * Number of retries to be allowed for a given request.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRetries#attempts
   */
  readonly attempts?: number;

  /**
   * Specifies the minimum duration between retry attempts.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRetries#backoff
   */
  readonly backoff?: string;

  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRetries#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Flag to specify whether the retries should ignore previously tried hosts during retry.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRetries#retryIgnorePreviousHosts
   */
  readonly retryIgnorePreviousHosts?: boolean;

  /**
   * Specifies the conditions under which retry takes place.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRetries#retryOn
   */
  readonly retryOn?: string;

  /**
   * Flag to specify whether the retries should retry to other localities.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRetries#retryRemoteLocalities
   */
  readonly retryRemoteLocalities?: boolean;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRetries' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRetries(obj: VirtualServiceV1Alpha3SpecHttpRetries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attempts': obj.attempts,
    'backoff': obj.backoff,
    'perTryTimeout': obj.perTryTimeout,
    'retryIgnorePreviousHosts': obj.retryIgnorePreviousHosts,
    'retryOn': obj.retryOn,
    'retryRemoteLocalities': obj.retryRemoteLocalities,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rewrite HTTP URIs and Authority headers.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRewrite
 */
export interface VirtualServiceV1Alpha3SpecHttpRewrite {
  /**
   * rewrite the Authority/Host header with this value.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRewrite#authority
   */
  readonly authority?: string;

  /**
   * rewrite the path (or the prefix) portion of the URI with this value.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRewrite#uri
   */
  readonly uri?: string;

  /**
   * rewrite the path portion of the URI with the specified regex.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRewrite#uriRegexRewrite
   */
  readonly uriRegexRewrite?: VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRewrite(obj: VirtualServiceV1Alpha3SpecHttpRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'uri': obj.uri,
    'uriRegexRewrite': toJson_VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite(obj.uriRegexRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpRoute
 */
export interface VirtualServiceV1Alpha3SpecHttpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRoute#destination
   */
  readonly destination: VirtualServiceV1Alpha3SpecHttpRouteDestination;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRoute#headers
   */
  readonly headers?: VirtualServiceV1Alpha3SpecHttpRouteHeaders;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRoute(obj: VirtualServiceV1Alpha3SpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Alpha3SpecHttpRouteDestination(obj.destination),
    'headers': toJson_VirtualServiceV1Alpha3SpecHttpRouteHeaders(obj.headers),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecTcpMatch
 */
export interface VirtualServiceV1Alpha3SpecTcpMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpMatch#port
   */
  readonly port?: number;

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecTcpMatch#sourceSubnet
   */
  readonly sourceSubnet?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTcpMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTcpMatch(obj: VirtualServiceV1Alpha3SpecTcpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'sourceSubnet': obj.sourceSubnet,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecTcpRoute
 */
export interface VirtualServiceV1Alpha3SpecTcpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpRoute#destination
   */
  readonly destination: VirtualServiceV1Alpha3SpecTcpRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTcpRoute(obj: VirtualServiceV1Alpha3SpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Alpha3SpecTcpRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecTlsMatch
 */
export interface VirtualServiceV1Alpha3SpecTlsMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsMatch#port
   */
  readonly port?: number;

  /**
   * SNI (server name indicator) to match on.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsMatch#sniHosts
   */
  readonly sniHosts: string[];

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTlsMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTlsMatch(obj: VirtualServiceV1Alpha3SpecTlsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sniHosts': obj.sniHosts?.map(y => y),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecTlsRoute
 */
export interface VirtualServiceV1Alpha3SpecTlsRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsRoute#destination
   */
  readonly destination: VirtualServiceV1Alpha3SpecTlsRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTlsRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTlsRoute(obj: VirtualServiceV1Alpha3SpecTlsRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Alpha3SpecTlsRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins
 */
export interface VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins(obj: VirtualServiceV1Alpha3SpecHttpCorsPolicyAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.
 *
 * Valid Options: FORWARD, IGNORE
 *
 * @schema VirtualServiceV1Alpha3SpecHttpCorsPolicyUnmatchedPreflights
 */
export enum VirtualServiceV1Alpha3SpecHttpCorsPolicyUnmatchedPreflights {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** FORWARD */
  FORWARD = "FORWARD",
  /** IGNORE */
  IGNORE = "IGNORE",
}

/**
 * Specifies the content of the response body.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpDirectResponseBody
 */
export interface VirtualServiceV1Alpha3SpecHttpDirectResponseBody {
  /**
   * response body as base64 encoded bytes.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpDirectResponseBody#bytes
   */
  readonly bytes?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpDirectResponseBody#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpDirectResponseBody' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpDirectResponseBody(obj: VirtualServiceV1Alpha3SpecHttpDirectResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytes': obj.bytes,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpFaultAbort
 */
export interface VirtualServiceV1Alpha3SpecHttpFaultAbort {
  /**
   * GRPC status code to use to abort the request.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFaultAbort#grpcStatus
   */
  readonly grpcStatus?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpFaultAbort#http2Error
   */
  readonly http2Error?: string;

  /**
   * HTTP status code to use to abort the Http request.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFaultAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage of requests to be aborted with the error code provided.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFaultAbort#percentage
   */
  readonly percentage?: VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpFaultAbort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpFaultAbort(obj: VirtualServiceV1Alpha3SpecHttpFaultAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcStatus': obj.grpcStatus,
    'http2Error': obj.http2Error,
    'httpStatus': obj.httpStatus,
    'percentage': toJson_VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpFaultDelay
 */
export interface VirtualServiceV1Alpha3SpecHttpFaultDelay {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay will be injected (0-100).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay will be injected.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpFaultDelay#percentage
   */
  readonly percentage?: VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpFaultDelay(obj: VirtualServiceV1Alpha3SpecHttpFaultDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exponentialDelay': obj.exponentialDelay,
    'fixedDelay': obj.fixedDelay,
    'percent': obj.percent,
    'percentage': toJson_VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpHeadersRequest
 */
export interface VirtualServiceV1Alpha3SpecHttpHeadersRequest {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpHeadersRequest(obj: VirtualServiceV1Alpha3SpecHttpHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpHeadersResponse
 */
export interface VirtualServiceV1Alpha3SpecHttpHeadersResponse {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpHeadersResponse(obj: VirtualServiceV1Alpha3SpecHttpHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMatchAuthority
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchAuthority {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchAuthority#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchAuthority#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchAuthority#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchAuthority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchAuthority(obj: VirtualServiceV1Alpha3SpecHttpMatchAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpMatchHeaders
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchHeaders {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchHeaders(obj: VirtualServiceV1Alpha3SpecHttpMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMatchMethod
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchMethod {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchMethod#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchMethod#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchMethod#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchMethod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchMethod(obj: VirtualServiceV1Alpha3SpecHttpMatchMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpMatchQueryParams
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchQueryParams {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchQueryParams#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchQueryParams#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchQueryParams#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchQueryParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchQueryParams(obj: VirtualServiceV1Alpha3SpecHttpMatchQueryParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMatchScheme
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchScheme {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchScheme#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchScheme#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchScheme#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchScheme' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchScheme(obj: VirtualServiceV1Alpha3SpecHttpMatchScheme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMatchUri
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchUri {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchUri#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchUri#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchUri#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchUri' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchUri(obj: VirtualServiceV1Alpha3SpecHttpMatchUri | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders
 */
export interface VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders(obj: VirtualServiceV1Alpha3SpecHttpMatchWithoutHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMirrorPort
 */
export interface VirtualServiceV1Alpha3SpecHttpMirrorPort {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirrorPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirrorPort(obj: VirtualServiceV1Alpha3SpecHttpMirrorPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination specifies the target of the mirror operation.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMirrorsDestination
 */
export interface VirtualServiceV1Alpha3SpecHttpMirrorsDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorsDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorsDestination#port
   */
  readonly port?: VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorsDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirrorsDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirrorsDestination(obj: VirtualServiceV1Alpha3SpecHttpMirrorsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of the traffic to be mirrored by the `destination` field.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMirrorsPercentage
 */
export interface VirtualServiceV1Alpha3SpecHttpMirrorsPercentage {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorsPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirrorsPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirrorsPercentage(obj: VirtualServiceV1Alpha3SpecHttpMirrorsPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
 *
 * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRedirectDerivePort
 */
export enum VirtualServiceV1Alpha3SpecHttpRedirectDerivePort {
  /** FROM_PROTOCOL_DEFAULT */
  FROM_UNDERSCORE_PROTOCOL_UNDERSCORE_DEFAULT = "FROM_PROTOCOL_DEFAULT",
  /** FROM_REQUEST_PORT */
  FROM_UNDERSCORE_REQUEST_UNDERSCORE_PORT = "FROM_REQUEST_PORT",
}

/**
 * rewrite the path portion of the URI with the specified regex.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite
 */
export interface VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite {
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite#match
   */
  readonly match?: string;

  /**
   * The string that should replace into matching portions of original URI.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite#rewrite
   */
  readonly rewrite?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite(obj: VirtualServiceV1Alpha3SpecHttpRewriteUriRegexRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match,
    'rewrite': obj.rewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRouteDestination
 */
export interface VirtualServiceV1Alpha3SpecHttpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRouteDestination#port
   */
  readonly port?: VirtualServiceV1Alpha3SpecHttpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Alpha3SpecHttpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRouteDestination(obj: VirtualServiceV1Alpha3SpecHttpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Alpha3SpecHttpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpRouteHeaders
 */
export interface VirtualServiceV1Alpha3SpecHttpRouteHeaders {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeaders#request
   */
  readonly request?: VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest;

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeaders#response
   */
  readonly response?: VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRouteHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRouteHeaders(obj: VirtualServiceV1Alpha3SpecHttpRouteHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest(obj.request),
    'response': toJson_VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Alpha3SpecTcpRouteDestination
 */
export interface VirtualServiceV1Alpha3SpecTcpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpRouteDestination#port
   */
  readonly port?: VirtualServiceV1Alpha3SpecTcpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Alpha3SpecTcpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTcpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTcpRouteDestination(obj: VirtualServiceV1Alpha3SpecTcpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Alpha3SpecTcpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Alpha3SpecTlsRouteDestination
 */
export interface VirtualServiceV1Alpha3SpecTlsRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsRouteDestination#port
   */
  readonly port?: VirtualServiceV1Alpha3SpecTlsRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Alpha3SpecTlsRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTlsRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTlsRouteDestination(obj: VirtualServiceV1Alpha3SpecTlsRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Alpha3SpecTlsRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of requests to be aborted with the error code provided.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage
 */
export interface VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage(obj: VirtualServiceV1Alpha3SpecHttpFaultAbortPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of requests on which the delay will be injected.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage
 */
export interface VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage(obj: VirtualServiceV1Alpha3SpecHttpFaultDelayPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort
 */
export interface VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort(obj: VirtualServiceV1Alpha3SpecHttpMirrorsDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Alpha3SpecHttpRouteDestinationPort
 */
export interface VirtualServiceV1Alpha3SpecHttpRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRouteDestinationPort(obj: VirtualServiceV1Alpha3SpecHttpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest
 */
export interface VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest(obj: VirtualServiceV1Alpha3SpecHttpRouteHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse
 */
export interface VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse {
  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse(obj: VirtualServiceV1Alpha3SpecHttpRouteHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Alpha3SpecTcpRouteDestinationPort
 */
export interface VirtualServiceV1Alpha3SpecTcpRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Alpha3SpecTcpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTcpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTcpRouteDestinationPort(obj: VirtualServiceV1Alpha3SpecTcpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Alpha3SpecTlsRouteDestinationPort
 */
export interface VirtualServiceV1Alpha3SpecTlsRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Alpha3SpecTlsRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Alpha3SpecTlsRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Alpha3SpecTlsRouteDestinationPort(obj: VirtualServiceV1Alpha3SpecTlsRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema VirtualServiceV1Beta1
 */
export class VirtualServiceV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualServiceV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'VirtualService',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualServiceV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServiceV1Beta1Props = {}): any {
    return {
      ...VirtualServiceV1Beta1.GVK,
      ...toJson_VirtualServiceV1Beta1Props(props),
    };
  }

  /**
   * Defines a "VirtualServiceV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServiceV1Beta1Props = {}) {
    super(scope, id, {
      ...VirtualServiceV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualServiceV1Beta1.GVK,
      ...toJson_VirtualServiceV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema VirtualServiceV1Beta1
 */
export interface VirtualServiceV1Beta1Props {
  /**
   * @schema VirtualServiceV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   *
   * @schema VirtualServiceV1Beta1#spec
   */
  readonly spec?: VirtualServiceV1Beta1Spec;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1Props(obj: VirtualServiceV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServiceV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
 *
 * @schema VirtualServiceV1Beta1Spec
 */
export interface VirtualServiceV1Beta1Spec {
  /**
   * A list of namespaces to which this virtual service is exported.
   *
   * @schema VirtualServiceV1Beta1Spec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The names of gateways and sidecars that should apply these routes.
   *
   * @schema VirtualServiceV1Beta1Spec#gateways
   */
  readonly gateways?: string[];

  /**
   * The destination hosts to which traffic is being sent.
   *
   * @schema VirtualServiceV1Beta1Spec#hosts
   */
  readonly hosts?: string[];

  /**
   * An ordered list of route rules for HTTP traffic.
   *
   * @schema VirtualServiceV1Beta1Spec#http
   */
  readonly http?: VirtualServiceV1Beta1SpecHttp[];

  /**
   * An ordered list of route rules for opaque TCP traffic.
   *
   * @schema VirtualServiceV1Beta1Spec#tcp
   */
  readonly tcp?: VirtualServiceV1Beta1SpecTcp[];

  /**
   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.
   *
   * @schema VirtualServiceV1Beta1Spec#tls
   */
  readonly tls?: VirtualServiceV1Beta1SpecTls[];

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1Spec(obj: VirtualServiceV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exportTo': obj.exportTo?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'hosts': obj.hosts?.map(y => y),
    'http': obj.http?.map(y => toJson_VirtualServiceV1Beta1SpecHttp(y)),
    'tcp': obj.tcp?.map(y => toJson_VirtualServiceV1Beta1SpecTcp(y)),
    'tls': obj.tls?.map(y => toJson_VirtualServiceV1Beta1SpecTls(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttp
 */
export interface VirtualServiceV1Beta1SpecHttp {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   *
   * @schema VirtualServiceV1Beta1SpecHttp#corsPolicy
   */
  readonly corsPolicy?: VirtualServiceV1Beta1SpecHttpCorsPolicy;

  /**
   * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#delegate
   */
  readonly delegate?: VirtualServiceV1Beta1SpecHttpDelegate;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#directResponse
   */
  readonly directResponse?: VirtualServiceV1Beta1SpecHttpDirectResponse;

  /**
   * Fault injection policy to apply on HTTP traffic at the client side.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#fault
   */
  readonly fault?: VirtualServiceV1Beta1SpecHttpFault;

  /**
   * @schema VirtualServiceV1Beta1SpecHttp#headers
   */
  readonly headers?: VirtualServiceV1Beta1SpecHttpHeaders;

  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#match
   */
  readonly match?: VirtualServiceV1Beta1SpecHttpMatch[];

  /**
   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#mirror
   */
  readonly mirror?: VirtualServiceV1Beta1SpecHttpMirror;

  /**
   * @schema VirtualServiceV1Beta1SpecHttp#mirror_percent
   */
  readonly mirrorPercent?: number;

  /**
   * Percentage of the traffic to be mirrored by the `mirror` field.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#mirrorPercentage
   */
  readonly mirrorPercentage?: VirtualServiceV1Beta1SpecHttpMirrorPercentage;

  /**
   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#mirrors
   */
  readonly mirrors?: VirtualServiceV1Beta1SpecHttpMirrors[];

  /**
   * The name assigned to the route for debugging purposes.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#name
   */
  readonly name?: string;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#redirect
   */
  readonly redirect?: VirtualServiceV1Beta1SpecHttpRedirect;

  /**
   * Retry policy for HTTP requests.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#retries
   */
  readonly retries?: VirtualServiceV1Beta1SpecHttpRetries;

  /**
   * Rewrite HTTP URIs and Authority headers.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#rewrite
   */
  readonly rewrite?: VirtualServiceV1Beta1SpecHttpRewrite;

  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#route
   */
  readonly route?: VirtualServiceV1Beta1SpecHttpRoute[];

  /**
   * Timeout for HTTP requests, default is disabled.
   *
   * @schema VirtualServiceV1Beta1SpecHttp#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttp(obj: VirtualServiceV1Beta1SpecHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'corsPolicy': toJson_VirtualServiceV1Beta1SpecHttpCorsPolicy(obj.corsPolicy),
    'delegate': toJson_VirtualServiceV1Beta1SpecHttpDelegate(obj.delegate),
    'directResponse': toJson_VirtualServiceV1Beta1SpecHttpDirectResponse(obj.directResponse),
    'fault': toJson_VirtualServiceV1Beta1SpecHttpFault(obj.fault),
    'headers': toJson_VirtualServiceV1Beta1SpecHttpHeaders(obj.headers),
    'match': obj.match?.map(y => toJson_VirtualServiceV1Beta1SpecHttpMatch(y)),
    'mirror': toJson_VirtualServiceV1Beta1SpecHttpMirror(obj.mirror),
    'mirror_percent': obj.mirrorPercent,
    'mirrorPercentage': toJson_VirtualServiceV1Beta1SpecHttpMirrorPercentage(obj.mirrorPercentage),
    'mirrors': obj.mirrors?.map(y => toJson_VirtualServiceV1Beta1SpecHttpMirrors(y)),
    'name': obj.name,
    'redirect': toJson_VirtualServiceV1Beta1SpecHttpRedirect(obj.redirect),
    'retries': toJson_VirtualServiceV1Beta1SpecHttpRetries(obj.retries),
    'rewrite': toJson_VirtualServiceV1Beta1SpecHttpRewrite(obj.rewrite),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Beta1SpecHttpRoute(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTcp
 */
export interface VirtualServiceV1Beta1SpecTcp {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Beta1SpecTcp#match
   */
  readonly match?: VirtualServiceV1Beta1SpecTcpMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTcp#route
   */
  readonly route?: VirtualServiceV1Beta1SpecTcpRoute[];

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcp(obj: VirtualServiceV1Beta1SpecTcp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceV1Beta1SpecTcpMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Beta1SpecTcpRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTls
 */
export interface VirtualServiceV1Beta1SpecTls {
  /**
   * Match conditions to be satisfied for the rule to be activated.
   *
   * @schema VirtualServiceV1Beta1SpecTls#match
   */
  readonly match: VirtualServiceV1Beta1SpecTlsMatch[];

  /**
   * The destination to which the connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTls#route
   */
  readonly route?: VirtualServiceV1Beta1SpecTlsRoute[];

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTls(obj: VirtualServiceV1Beta1SpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match?.map(y => toJson_VirtualServiceV1Beta1SpecTlsMatch(y)),
    'route': obj.route?.map(y => toJson_VirtualServiceV1Beta1SpecTlsRoute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cross-Origin Resource Sharing policy (CORS).
 *
 * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy
 */
export interface VirtualServiceV1Beta1SpecHttpCorsPolicy {
  /**
   * Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowCredentials
   */
  readonly allowCredentials?: boolean;

  /**
   * List of HTTP headers that can be used when requesting the resource.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowHeaders
   */
  readonly allowHeaders?: string[];

  /**
   * List of HTTP methods allowed to access the resource.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowMethods
   */
  readonly allowMethods?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowOrigin
   */
  readonly allowOrigin?: string[];

  /**
   * String patterns that match allowed origins.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#allowOrigins
   */
  readonly allowOrigins?: VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins[];

  /**
   * A list of HTTP headers that the browsers are allowed to access.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#exposeHeaders
   */
  readonly exposeHeaders?: string[];

  /**
   * Specifies how long the results of a preflight request can be cached.
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#maxAge
   */
  readonly maxAge?: string;

  /**
   * Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.
   *
   * Valid Options: FORWARD, IGNORE
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicy#unmatchedPreflights
   */
  readonly unmatchedPreflights?: VirtualServiceV1Beta1SpecHttpCorsPolicyUnmatchedPreflights;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpCorsPolicy' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpCorsPolicy(obj: VirtualServiceV1Beta1SpecHttpCorsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCredentials': obj.allowCredentials,
    'allowHeaders': obj.allowHeaders?.map(y => y),
    'allowMethods': obj.allowMethods?.map(y => y),
    'allowOrigin': obj.allowOrigin?.map(y => y),
    'allowOrigins': obj.allowOrigins?.map(y => toJson_VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins(y)),
    'exposeHeaders': obj.exposeHeaders?.map(y => y),
    'maxAge': obj.maxAge,
    'unmatchedPreflights': obj.unmatchedPreflights,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delegate is used to specify the particular VirtualService which can be used to define delegate HTTPRoute.
 *
 * @schema VirtualServiceV1Beta1SpecHttpDelegate
 */
export interface VirtualServiceV1Beta1SpecHttpDelegate {
  /**
   * Name specifies the name of the delegate VirtualService.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDelegate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies the namespace where the delegate VirtualService resides.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDelegate#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpDelegate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpDelegate(obj: VirtualServiceV1Beta1SpecHttpDelegate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceV1Beta1SpecHttpDirectResponse
 */
export interface VirtualServiceV1Beta1SpecHttpDirectResponse {
  /**
   * Specifies the content of the response body.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponse#body
   */
  readonly body?: VirtualServiceV1Beta1SpecHttpDirectResponseBody;

  /**
   * Specifies the HTTP response status to be returned.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponse#status
   */
  readonly status: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpDirectResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpDirectResponse(obj: VirtualServiceV1Beta1SpecHttpDirectResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': toJson_VirtualServiceV1Beta1SpecHttpDirectResponseBody(obj.body),
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at the client side.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFault
 */
export interface VirtualServiceV1Beta1SpecHttpFault {
  /**
   * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFault#abort
   */
  readonly abort?: VirtualServiceV1Beta1SpecHttpFaultAbort;

  /**
   * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFault#delay
   */
  readonly delay?: VirtualServiceV1Beta1SpecHttpFaultDelay;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFault(obj: VirtualServiceV1Beta1SpecHttpFault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'abort': toJson_VirtualServiceV1Beta1SpecHttpFaultAbort(obj.abort),
    'delay': toJson_VirtualServiceV1Beta1SpecHttpFaultDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeaders#request
   */
  readonly request?: VirtualServiceV1Beta1SpecHttpHeadersRequest;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeaders#response
   */
  readonly response?: VirtualServiceV1Beta1SpecHttpHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpHeaders(obj: VirtualServiceV1Beta1SpecHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceV1Beta1SpecHttpHeadersRequest(obj.request),
    'response': toJson_VirtualServiceV1Beta1SpecHttpHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatch
 */
export interface VirtualServiceV1Beta1SpecHttpMatch {
  /**
   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#authority
   */
  readonly authority?: VirtualServiceV1Beta1SpecHttpMatchAuthority;

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#headers
   */
  readonly headers?: { [key: string]: VirtualServiceV1Beta1SpecHttpMatchHeaders };

  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#ignoreUriCase
   */
  readonly ignoreUriCase?: boolean;

  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#method
   */
  readonly method?: VirtualServiceV1Beta1SpecHttpMatchMethod;

  /**
   * The name assigned to a match.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#name
   */
  readonly name?: string;

  /**
   * Specifies the ports on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#port
   */
  readonly port?: number;

  /**
   * Query parameters for matching.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#queryParams
   */
  readonly queryParams?: { [key: string]: VirtualServiceV1Beta1SpecHttpMatchQueryParams };

  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#scheme
   */
  readonly scheme?: VirtualServiceV1Beta1SpecHttpMatchScheme;

  /**
   * One or more labels that constrain the applicability of a rule to source (client) workloads with the given labels.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * The human readable prefix to use when emitting statistics for this route.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#statPrefix
   */
  readonly statPrefix?: string;

  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#uri
   */
  readonly uri?: VirtualServiceV1Beta1SpecHttpMatchUri;

  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatch#withoutHeaders
   */
  readonly withoutHeaders?: { [key: string]: VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatch(obj: VirtualServiceV1Beta1SpecHttpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': toJson_VirtualServiceV1Beta1SpecHttpMatchAuthority(obj.authority),
    'gateways': obj.gateways?.map(y => y),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Beta1SpecHttpMatchHeaders(i[1]) }), {})),
    'ignoreUriCase': obj.ignoreUriCase,
    'method': toJson_VirtualServiceV1Beta1SpecHttpMatchMethod(obj.method),
    'name': obj.name,
    'port': obj.port,
    'queryParams': ((obj.queryParams) === undefined) ? undefined : (Object.entries(obj.queryParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Beta1SpecHttpMatchQueryParams(i[1]) }), {})),
    'scheme': toJson_VirtualServiceV1Beta1SpecHttpMatchScheme(obj.scheme),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'statPrefix': obj.statPrefix,
    'uri': toJson_VirtualServiceV1Beta1SpecHttpMatchUri(obj.uri),
    'withoutHeaders': ((obj.withoutHeaders) === undefined) ? undefined : (Object.entries(obj.withoutHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Mirror HTTP traffic to a another destination in addition to forwarding the requests to the intended destination.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirror
 */
export interface VirtualServiceV1Beta1SpecHttpMirror {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirror#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirror#port
   */
  readonly port?: VirtualServiceV1Beta1SpecHttpMirrorPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirror#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirror(obj: VirtualServiceV1Beta1SpecHttpMirror | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecHttpMirrorPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of the traffic to be mirrored by the `mirror` field.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorPercentage(obj: VirtualServiceV1Beta1SpecHttpMirrorPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMirrors
 */
export interface VirtualServiceV1Beta1SpecHttpMirrors {
  /**
   * Destination specifies the target of the mirror operation.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrors#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecHttpMirrorsDestination;

  /**
   * Percentage of the traffic to be mirrored by the `destination` field.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrors#percentage
   */
  readonly percentage?: VirtualServiceV1Beta1SpecHttpMirrorsPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrors' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrors(obj: VirtualServiceV1Beta1SpecHttpMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestination(obj.destination),
    'percentage': toJson_VirtualServiceV1Beta1SpecHttpMirrorsPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRedirect
 */
export interface VirtualServiceV1Beta1SpecHttpRedirect {
  /**
   * On a redirect, overwrite the Authority/Host portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#authority
   */
  readonly authority?: string;

  /**
   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
   *
   * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#derivePort
   */
  readonly derivePort?: VirtualServiceV1Beta1SpecHttpRedirectDerivePort;

  /**
   * On a redirect, overwrite the port portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#port
   */
  readonly port?: number;

  /**
   * On a redirect, Specifies the HTTP status code to use in the redirect response.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#redirectCode
   */
  readonly redirectCode?: number;

  /**
   * On a redirect, overwrite the scheme portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#scheme
   */
  readonly scheme?: string;

  /**
   * On a redirect, overwrite the Path portion of the URL with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRedirect#uri
   */
  readonly uri?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRedirect(obj: VirtualServiceV1Beta1SpecHttpRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'derivePort': obj.derivePort,
    'port': obj.port,
    'redirectCode': obj.redirectCode,
    'scheme': obj.scheme,
    'uri': obj.uri,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry policy for HTTP requests.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRetries
 */
export interface VirtualServiceV1Beta1SpecHttpRetries {
  /**
   * Number of retries to be allowed for a given request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#attempts
   */
  readonly attempts?: number;

  /**
   * Specifies the minimum duration between retry attempts.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#backoff
   */
  readonly backoff?: string;

  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#perTryTimeout
   */
  readonly perTryTimeout?: string;

  /**
   * Flag to specify whether the retries should ignore previously tried hosts during retry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#retryIgnorePreviousHosts
   */
  readonly retryIgnorePreviousHosts?: boolean;

  /**
   * Specifies the conditions under which retry takes place.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#retryOn
   */
  readonly retryOn?: string;

  /**
   * Flag to specify whether the retries should retry to other localities.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRetries#retryRemoteLocalities
   */
  readonly retryRemoteLocalities?: boolean;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRetries' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRetries(obj: VirtualServiceV1Beta1SpecHttpRetries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attempts': obj.attempts,
    'backoff': obj.backoff,
    'perTryTimeout': obj.perTryTimeout,
    'retryIgnorePreviousHosts': obj.retryIgnorePreviousHosts,
    'retryOn': obj.retryOn,
    'retryRemoteLocalities': obj.retryRemoteLocalities,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Rewrite HTTP URIs and Authority headers.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRewrite
 */
export interface VirtualServiceV1Beta1SpecHttpRewrite {
  /**
   * rewrite the Authority/Host header with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewrite#authority
   */
  readonly authority?: string;

  /**
   * rewrite the path (or the prefix) portion of the URI with this value.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewrite#uri
   */
  readonly uri?: string;

  /**
   * rewrite the path portion of the URI with the specified regex.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewrite#uriRegexRewrite
   */
  readonly uriRegexRewrite?: VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRewrite(obj: VirtualServiceV1Beta1SpecHttpRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority,
    'uri': obj.uri,
    'uriRegexRewrite': toJson_VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite(obj.uriRegexRewrite),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRoute
 */
export interface VirtualServiceV1Beta1SpecHttpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRoute#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecHttpRouteDestination;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRoute#headers
   */
  readonly headers?: VirtualServiceV1Beta1SpecHttpRouteHeaders;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRoute(obj: VirtualServiceV1Beta1SpecHttpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecHttpRouteDestination(obj.destination),
    'headers': toJson_VirtualServiceV1Beta1SpecHttpRouteHeaders(obj.headers),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTcpMatch
 */
export interface VirtualServiceV1Beta1SpecTcpMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#port
   */
  readonly port?: number;

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Beta1SpecTcpMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecTcpMatch#sourceSubnet
   */
  readonly sourceSubnet?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpMatch(obj: VirtualServiceV1Beta1SpecTcpMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
    'sourceSubnet': obj.sourceSubnet,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTcpRoute
 */
export interface VirtualServiceV1Beta1SpecTcpRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRoute#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecTcpRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpRoute(obj: VirtualServiceV1Beta1SpecTcpRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecTcpRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTlsMatch
 */
export interface VirtualServiceV1Beta1SpecTlsMatch {
  /**
   * IPv4 or IPv6 ip addresses of destination with optional subnet.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#destinationSubnets
   */
  readonly destinationSubnets?: string[];

  /**
   * Names of gateways where the rule should be applied.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#gateways
   */
  readonly gateways?: string[];

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#port
   */
  readonly port?: number;

  /**
   * SNI (server name indicator) to match on.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#sniHosts
   */
  readonly sniHosts: string[];

  /**
   * One or more labels that constrain the applicability of a rule to workloads with the given labels.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#sourceLabels
   */
  readonly sourceLabels?: { [key: string]: string };

  /**
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   *
   * @schema VirtualServiceV1Beta1SpecTlsMatch#sourceNamespace
   */
  readonly sourceNamespace?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsMatch(obj: VirtualServiceV1Beta1SpecTlsMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destinationSubnets': obj.destinationSubnets?.map(y => y),
    'gateways': obj.gateways?.map(y => y),
    'port': obj.port,
    'sniHosts': obj.sniHosts?.map(y => y),
    'sourceLabels': ((obj.sourceLabels) === undefined) ? undefined : (Object.entries(obj.sourceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'sourceNamespace': obj.sourceNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecTlsRoute
 */
export interface VirtualServiceV1Beta1SpecTlsRoute {
  /**
   * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRoute#destination
   */
  readonly destination: VirtualServiceV1Beta1SpecTlsRouteDestination;

  /**
   * Weight specifies the relative proportion of traffic to be forwarded to the destination.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRoute#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsRoute' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsRoute(obj: VirtualServiceV1Beta1SpecTlsRoute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'destination': toJson_VirtualServiceV1Beta1SpecTlsRouteDestination(obj.destination),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins
 */
export interface VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins(obj: VirtualServiceV1Beta1SpecHttpCorsPolicyAllowOrigins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Indicates whether preflight requests not matching the configured allowed origin shouldn't be forwarded to the upstream.
 *
 * Valid Options: FORWARD, IGNORE
 *
 * @schema VirtualServiceV1Beta1SpecHttpCorsPolicyUnmatchedPreflights
 */
export enum VirtualServiceV1Beta1SpecHttpCorsPolicyUnmatchedPreflights {
  /** UNSPECIFIED */
  UNSPECIFIED = "UNSPECIFIED",
  /** FORWARD */
  FORWARD = "FORWARD",
  /** IGNORE */
  IGNORE = "IGNORE",
}

/**
 * Specifies the content of the response body.
 *
 * @schema VirtualServiceV1Beta1SpecHttpDirectResponseBody
 */
export interface VirtualServiceV1Beta1SpecHttpDirectResponseBody {
  /**
   * response body as base64 encoded bytes.
   *
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponseBody#bytes
   */
  readonly bytes?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpDirectResponseBody#string
   */
  readonly string?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpDirectResponseBody' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpDirectResponseBody(obj: VirtualServiceV1Beta1SpecHttpDirectResponseBody | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bytes': obj.bytes,
    'string': obj.string,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Abort Http request attempts and return error codes back to downstream service, giving the impression that the upstream service is faulty.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultAbort
 */
export interface VirtualServiceV1Beta1SpecHttpFaultAbort {
  /**
   * GRPC status code to use to abort the request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#grpcStatus
   */
  readonly grpcStatus?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#http2Error
   */
  readonly http2Error?: string;

  /**
   * HTTP status code to use to abort the Http request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#httpStatus
   */
  readonly httpStatus?: number;

  /**
   * Percentage of requests to be aborted with the error code provided.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbort#percentage
   */
  readonly percentage?: VirtualServiceV1Beta1SpecHttpFaultAbortPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultAbort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultAbort(obj: VirtualServiceV1Beta1SpecHttpFaultAbort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpcStatus': obj.grpcStatus,
    'http2Error': obj.http2Error,
    'httpStatus': obj.httpStatus,
    'percentage': toJson_VirtualServiceV1Beta1SpecHttpFaultAbortPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delay requests before forwarding, emulating various failures such as network issues, overloaded upstream service, etc.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultDelay
 */
export interface VirtualServiceV1Beta1SpecHttpFaultDelay {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay will be injected (0-100).
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay will be injected.
   *
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelay#percentage
   */
  readonly percentage?: VirtualServiceV1Beta1SpecHttpFaultDelayPercentage;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultDelay(obj: VirtualServiceV1Beta1SpecHttpFaultDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exponentialDelay': obj.exponentialDelay,
    'fixedDelay': obj.fixedDelay,
    'percent': obj.percent,
    'percentage': toJson_VirtualServiceV1Beta1SpecHttpFaultDelayPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest
 */
export interface VirtualServiceV1Beta1SpecHttpHeadersRequest {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpHeadersRequest(obj: VirtualServiceV1Beta1SpecHttpHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse
 */
export interface VirtualServiceV1Beta1SpecHttpHeadersResponse {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpHeadersResponse(obj: VirtualServiceV1Beta1SpecHttpHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Authority values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority
 */
export interface VirtualServiceV1Beta1SpecHttpMatchAuthority {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchAuthority#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchAuthority' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchAuthority(obj: VirtualServiceV1Beta1SpecHttpMatchAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpMatchHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchHeaders(obj: VirtualServiceV1Beta1SpecHttpMatchHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchMethod
 */
export interface VirtualServiceV1Beta1SpecHttpMatchMethod {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchMethod#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchMethod#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchMethod#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchMethod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchMethod(obj: VirtualServiceV1Beta1SpecHttpMatchMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams
 */
export interface VirtualServiceV1Beta1SpecHttpMatchQueryParams {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchQueryParams#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchQueryParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchQueryParams(obj: VirtualServiceV1Beta1SpecHttpMatchQueryParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchScheme
 */
export interface VirtualServiceV1Beta1SpecHttpMatchScheme {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchScheme#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchScheme#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchScheme#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchScheme' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchScheme(obj: VirtualServiceV1Beta1SpecHttpMatchScheme | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
 *
 * @schema VirtualServiceV1Beta1SpecHttpMatchUri
 */
export interface VirtualServiceV1Beta1SpecHttpMatchUri {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchUri#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchUri#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchUri#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchUri' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchUri(obj: VirtualServiceV1Beta1SpecHttpMatchUri | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders#exact
   */
  readonly exact?: string;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders#prefix
   */
  readonly prefix?: string;

  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders#regex
   */
  readonly regex?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders(obj: VirtualServiceV1Beta1SpecHttpMatchWithoutHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exact': obj.exact,
    'prefix': obj.prefix,
    'regex': obj.regex,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorPort
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorPort {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorPort(obj: VirtualServiceV1Beta1SpecHttpMirrorPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination specifies the target of the mirror operation.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorsDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorsDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestination(obj: VirtualServiceV1Beta1SpecHttpMirrorsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of the traffic to be mirrored by the `destination` field.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorsPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorsPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorsPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorsPercentage(obj: VirtualServiceV1Beta1SpecHttpMirrorsPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.
 *
 * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
 *
 * @schema VirtualServiceV1Beta1SpecHttpRedirectDerivePort
 */
export enum VirtualServiceV1Beta1SpecHttpRedirectDerivePort {
  /** FROM_PROTOCOL_DEFAULT */
  FROM_UNDERSCORE_PROTOCOL_UNDERSCORE_DEFAULT = "FROM_PROTOCOL_DEFAULT",
  /** FROM_REQUEST_PORT */
  FROM_UNDERSCORE_REQUEST_UNDERSCORE_PORT = "FROM_REQUEST_PORT",
}

/**
 * rewrite the path portion of the URI with the specified regex.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite
 */
export interface VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite {
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite#match
   */
  readonly match?: string;

  /**
   * The string that should replace into matching portions of original URI.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite#rewrite
   */
  readonly rewrite?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite(obj: VirtualServiceV1Beta1SpecHttpRewriteUriRegexRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'match': obj.match,
    'rewrite': obj.rewrite,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRouteDestination
 */
export interface VirtualServiceV1Beta1SpecHttpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecHttpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteDestination(obj: VirtualServiceV1Beta1SpecHttpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecHttpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRouteHeaders
 */
export interface VirtualServiceV1Beta1SpecHttpRouteHeaders {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeaders#request
   */
  readonly request?: VirtualServiceV1Beta1SpecHttpRouteHeadersRequest;

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeaders#response
   */
  readonly response?: VirtualServiceV1Beta1SpecHttpRouteHeadersResponse;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteHeaders(obj: VirtualServiceV1Beta1SpecHttpRouteHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'request': toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersRequest(obj.request),
    'response': toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersResponse(obj.response),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Beta1SpecTcpRouteDestination
 */
export interface VirtualServiceV1Beta1SpecTcpRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecTcpRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpRouteDestination(obj: VirtualServiceV1Beta1SpecTcpRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecTcpRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Destination uniquely identifies the instances of a service to which the request/connection should be forwarded to.
 *
 * @schema VirtualServiceV1Beta1SpecTlsRouteDestination
 */
export interface VirtualServiceV1Beta1SpecTlsRouteDestination {
  /**
   * The name of a service from the service registry.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestination#host
   */
  readonly host: string;

  /**
   * Specifies the port on the host that is being addressed.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestination#port
   */
  readonly port?: VirtualServiceV1Beta1SpecTlsRouteDestinationPort;

  /**
   * The name of a subset within the service.
   *
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestination#subset
   */
  readonly subset?: string;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsRouteDestination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsRouteDestination(obj: VirtualServiceV1Beta1SpecTlsRouteDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': toJson_VirtualServiceV1Beta1SpecTlsRouteDestinationPort(obj.port),
    'subset': obj.subset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of requests to be aborted with the error code provided.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultAbortPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpFaultAbortPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultAbortPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultAbortPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultAbortPercentage(obj: VirtualServiceV1Beta1SpecHttpFaultAbortPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Percentage of requests on which the delay will be injected.
 *
 * @schema VirtualServiceV1Beta1SpecHttpFaultDelayPercentage
 */
export interface VirtualServiceV1Beta1SpecHttpFaultDelayPercentage {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpFaultDelayPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpFaultDelayPercentage(obj: VirtualServiceV1Beta1SpecHttpFaultDelayPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort
 */
export interface VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort(obj: VirtualServiceV1Beta1SpecHttpMirrorsDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecHttpRouteDestinationPort
 */
export interface VirtualServiceV1Beta1SpecHttpRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteDestinationPort(obj: VirtualServiceV1Beta1SpecHttpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest
 */
export interface VirtualServiceV1Beta1SpecHttpRouteHeadersRequest {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersRequest#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteHeadersRequest' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersRequest(obj: VirtualServiceV1Beta1SpecHttpRouteHeadersRequest | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse
 */
export interface VirtualServiceV1Beta1SpecHttpRouteHeadersResponse {
  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse#add
   */
  readonly add?: { [key: string]: string };

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse#remove
   */
  readonly remove?: string[];

  /**
   * @schema VirtualServiceV1Beta1SpecHttpRouteHeadersResponse#set
   */
  readonly set?: { [key: string]: string };

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecHttpRouteHeadersResponse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecHttpRouteHeadersResponse(obj: VirtualServiceV1Beta1SpecHttpRouteHeadersResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': ((obj.add) === undefined) ? undefined : (Object.entries(obj.add).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'remove': obj.remove?.map(y => y),
    'set': ((obj.set) === undefined) ? undefined : (Object.entries(obj.set).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecTcpRouteDestinationPort
 */
export interface VirtualServiceV1Beta1SpecTcpRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecTcpRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTcpRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTcpRouteDestinationPort(obj: VirtualServiceV1Beta1SpecTcpRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specifies the port on the host that is being addressed.
 *
 * @schema VirtualServiceV1Beta1SpecTlsRouteDestinationPort
 */
export interface VirtualServiceV1Beta1SpecTlsRouteDestinationPort {
  /**
   * @schema VirtualServiceV1Beta1SpecTlsRouteDestinationPort#number
   */
  readonly number?: number;

}

/**
 * Converts an object of type 'VirtualServiceV1Beta1SpecTlsRouteDestinationPort' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_VirtualServiceV1Beta1SpecTlsRouteDestinationPort(obj: VirtualServiceV1Beta1SpecTlsRouteDestinationPort | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema WorkloadEntry
 */
export class WorkloadEntry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadEntry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'WorkloadEntry',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadEntry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadEntryProps): any {
    return {
      ...WorkloadEntry.GVK,
      ...toJson_WorkloadEntryProps(props),
    };
  }

  /**
   * Defines a "WorkloadEntry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadEntryProps) {
    super(scope, id, {
      ...WorkloadEntry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadEntry.GVK,
      ...toJson_WorkloadEntryProps(resolved),
    };
  }
}

/**
 * @schema WorkloadEntry
 */
export interface WorkloadEntryProps {
  /**
   * @schema WorkloadEntry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
   *
   * @schema WorkloadEntry#spec
   */
  readonly spec: WorkloadEntrySpec;

}

/**
 * Converts an object of type 'WorkloadEntryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadEntryProps(obj: WorkloadEntryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadEntrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
 *
 * @schema WorkloadEntrySpec
 */
export interface WorkloadEntrySpec {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadEntrySpec#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadEntrySpec#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadEntrySpec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadEntrySpec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadEntrySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadEntrySpec(obj: WorkloadEntrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema WorkloadEntryV1Alpha3
 */
export class WorkloadEntryV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadEntryV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'WorkloadEntry',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadEntryV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadEntryV1Alpha3Props): any {
    return {
      ...WorkloadEntryV1Alpha3.GVK,
      ...toJson_WorkloadEntryV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "WorkloadEntryV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadEntryV1Alpha3Props) {
    super(scope, id, {
      ...WorkloadEntryV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadEntryV1Alpha3.GVK,
      ...toJson_WorkloadEntryV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema WorkloadEntryV1Alpha3
 */
export interface WorkloadEntryV1Alpha3Props {
  /**
   * @schema WorkloadEntryV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
   *
   * @schema WorkloadEntryV1Alpha3#spec
   */
  readonly spec: WorkloadEntryV1Alpha3Spec;

}

/**
 * Converts an object of type 'WorkloadEntryV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadEntryV1Alpha3Props(obj: WorkloadEntryV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadEntryV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
 *
 * @schema WorkloadEntryV1Alpha3Spec
 */
export interface WorkloadEntryV1Alpha3Spec {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadEntryV1Alpha3Spec#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadEntryV1Alpha3Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadEntryV1Alpha3Spec#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadEntryV1Alpha3Spec#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadEntryV1Alpha3Spec#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadEntryV1Alpha3Spec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadEntryV1Alpha3Spec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadEntryV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadEntryV1Alpha3Spec(obj: WorkloadEntryV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema WorkloadEntryV1Beta1
 */
export class WorkloadEntryV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadEntryV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'WorkloadEntry',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadEntryV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadEntryV1Beta1Props): any {
    return {
      ...WorkloadEntryV1Beta1.GVK,
      ...toJson_WorkloadEntryV1Beta1Props(props),
    };
  }

  /**
   * Defines a "WorkloadEntryV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadEntryV1Beta1Props) {
    super(scope, id, {
      ...WorkloadEntryV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadEntryV1Beta1.GVK,
      ...toJson_WorkloadEntryV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema WorkloadEntryV1Beta1
 */
export interface WorkloadEntryV1Beta1Props {
  /**
   * @schema WorkloadEntryV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
   *
   * @schema WorkloadEntryV1Beta1#spec
   */
  readonly spec: WorkloadEntryV1Beta1Spec;

}

/**
 * Converts an object of type 'WorkloadEntryV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadEntryV1Beta1Props(obj: WorkloadEntryV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadEntryV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
 *
 * @schema WorkloadEntryV1Beta1Spec
 */
export interface WorkloadEntryV1Beta1Spec {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadEntryV1Beta1Spec#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadEntryV1Beta1Spec#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadEntryV1Beta1Spec#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadEntryV1Beta1Spec#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadEntryV1Beta1Spec#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadEntryV1Beta1Spec#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadEntryV1Beta1Spec#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadEntryV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadEntryV1Beta1Spec(obj: WorkloadEntryV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema WorkloadGroup
 */
export class WorkloadGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1',
    kind: 'WorkloadGroup',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadGroupProps): any {
    return {
      ...WorkloadGroup.GVK,
      ...toJson_WorkloadGroupProps(props),
    };
  }

  /**
   * Defines a "WorkloadGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadGroupProps) {
    super(scope, id, {
      ...WorkloadGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadGroup.GVK,
      ...toJson_WorkloadGroupProps(resolved),
    };
  }
}

/**
 * @schema WorkloadGroup
 */
export interface WorkloadGroupProps {
  /**
   * @schema WorkloadGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
   *
   * @schema WorkloadGroup#spec
   */
  readonly spec: WorkloadGroupSpec;

}

/**
 * Converts an object of type 'WorkloadGroupProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupProps(obj: WorkloadGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
 *
 * @schema WorkloadGroupSpec
 */
export interface WorkloadGroupSpec {
  /**
   * Metadata that will be used for all corresponding `WorkloadEntries`.
   *
   * @schema WorkloadGroupSpec#metadata
   */
  readonly metadata?: WorkloadGroupSpecMetadata;

  /**
   * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
   *
   * @schema WorkloadGroupSpec#probe
   */
  readonly probe?: WorkloadGroupSpecProbe;

  /**
   * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
   *
   * @schema WorkloadGroupSpec#template
   */
  readonly template: WorkloadGroupSpecTemplate;

}

/**
 * Converts an object of type 'WorkloadGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpec(obj: WorkloadGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_WorkloadGroupSpecMetadata(obj.metadata),
    'probe': toJson_WorkloadGroupSpecProbe(obj.probe),
    'template': toJson_WorkloadGroupSpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata that will be used for all corresponding `WorkloadEntries`.
 *
 * @schema WorkloadGroupSpecMetadata
 */
export interface WorkloadGroupSpecMetadata {
  /**
   * @schema WorkloadGroupSpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema WorkloadGroupSpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkloadGroupSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecMetadata(obj: WorkloadGroupSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
 *
 * @schema WorkloadGroupSpecProbe
 */
export interface WorkloadGroupSpecProbe {
  /**
   * Health is determined by how the command that is executed exited.
   *
   * @schema WorkloadGroupSpecProbe#exec
   */
  readonly exec?: WorkloadGroupSpecProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   *
   * @schema WorkloadGroupSpecProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC call is made and response/error is used to determine health.
   *
   * @schema WorkloadGroupSpecProbe#grpc
   */
  readonly grpc?: WorkloadGroupSpecProbeGrpc;

  /**
   * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
   *
   * @schema WorkloadGroupSpecProbe#httpGet
   */
  readonly httpGet?: WorkloadGroupSpecProbeHttpGet;

  /**
   * Number of seconds after the container has started before readiness probes are initiated.
   *
   * @schema WorkloadGroupSpecProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   *
   * @schema WorkloadGroupSpecProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   *
   * @schema WorkloadGroupSpecProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Health is determined by if the proxy is able to connect.
   *
   * @schema WorkloadGroupSpecProbe#tcpSocket
   */
  readonly tcpSocket?: WorkloadGroupSpecProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out.
   *
   * @schema WorkloadGroupSpecProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecProbe(obj: WorkloadGroupSpecProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_WorkloadGroupSpecProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_WorkloadGroupSpecProbeGrpc(obj.grpc),
    'httpGet': toJson_WorkloadGroupSpecProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_WorkloadGroupSpecProbeTcpSocket(obj.tcpSocket),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
 *
 * @schema WorkloadGroupSpecTemplate
 */
export interface WorkloadGroupSpecTemplate {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadGroupSpecTemplate#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadGroupSpecTemplate#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadGroupSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadGroupSpecTemplate#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadGroupSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecTemplate(obj: WorkloadGroupSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Health is determined by how the command that is executed exited.
 *
 * @schema WorkloadGroupSpecProbeExec
 */
export interface WorkloadGroupSpecProbeExec {
  /**
   * Command to run.
   *
   * @schema WorkloadGroupSpecProbeExec#command
   */
  readonly command: string[];

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecProbeExec(obj: WorkloadGroupSpecProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC call is made and response/error is used to determine health.
 *
 * @schema WorkloadGroupSpecProbeGrpc
 */
export interface WorkloadGroupSpecProbeGrpc {
  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupSpecProbeGrpc#port
   */
  readonly port?: number;

  /**
   * @schema WorkloadGroupSpecProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecProbeGrpc(obj: WorkloadGroupSpecProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
 *
 * @schema WorkloadGroupSpecProbeHttpGet
 */
export interface WorkloadGroupSpecProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Headers the proxy will pass on to make the request.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: WorkloadGroupSpecProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupSpecProbeHttpGet#port
   */
  readonly port: number;

  /**
   * @schema WorkloadGroupSpecProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecProbeHttpGet(obj: WorkloadGroupSpecProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_WorkloadGroupSpecProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Health is determined by if the proxy is able to connect.
 *
 * @schema WorkloadGroupSpecProbeTcpSocket
 */
export interface WorkloadGroupSpecProbeTcpSocket {
  /**
   * @schema WorkloadGroupSpecProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema WorkloadGroupSpecProbeTcpSocket#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecProbeTcpSocket(obj: WorkloadGroupSpecProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders
 */
export interface WorkloadGroupSpecProbeHttpGetHttpHeaders {
  /**
   * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders#name
   */
  readonly name?: string;

  /**
   * @schema WorkloadGroupSpecProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkloadGroupSpecProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupSpecProbeHttpGetHttpHeaders(obj: WorkloadGroupSpecProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema WorkloadGroupV1Alpha3
 */
export class WorkloadGroupV1Alpha3 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadGroupV1Alpha3"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1alpha3',
    kind: 'WorkloadGroup',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadGroupV1Alpha3".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadGroupV1Alpha3Props): any {
    return {
      ...WorkloadGroupV1Alpha3.GVK,
      ...toJson_WorkloadGroupV1Alpha3Props(props),
    };
  }

  /**
   * Defines a "WorkloadGroupV1Alpha3" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadGroupV1Alpha3Props) {
    super(scope, id, {
      ...WorkloadGroupV1Alpha3.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadGroupV1Alpha3.GVK,
      ...toJson_WorkloadGroupV1Alpha3Props(resolved),
    };
  }
}

/**
 * @schema WorkloadGroupV1Alpha3
 */
export interface WorkloadGroupV1Alpha3Props {
  /**
   * @schema WorkloadGroupV1Alpha3#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
   *
   * @schema WorkloadGroupV1Alpha3#spec
   */
  readonly spec: WorkloadGroupV1Alpha3Spec;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3Props(obj: WorkloadGroupV1Alpha3Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadGroupV1Alpha3Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
 *
 * @schema WorkloadGroupV1Alpha3Spec
 */
export interface WorkloadGroupV1Alpha3Spec {
  /**
   * Metadata that will be used for all corresponding `WorkloadEntries`.
   *
   * @schema WorkloadGroupV1Alpha3Spec#metadata
   */
  readonly metadata?: WorkloadGroupV1Alpha3SpecMetadata;

  /**
   * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
   *
   * @schema WorkloadGroupV1Alpha3Spec#probe
   */
  readonly probe?: WorkloadGroupV1Alpha3SpecProbe;

  /**
   * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
   *
   * @schema WorkloadGroupV1Alpha3Spec#template
   */
  readonly template: WorkloadGroupV1Alpha3SpecTemplate;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3Spec(obj: WorkloadGroupV1Alpha3Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_WorkloadGroupV1Alpha3SpecMetadata(obj.metadata),
    'probe': toJson_WorkloadGroupV1Alpha3SpecProbe(obj.probe),
    'template': toJson_WorkloadGroupV1Alpha3SpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata that will be used for all corresponding `WorkloadEntries`.
 *
 * @schema WorkloadGroupV1Alpha3SpecMetadata
 */
export interface WorkloadGroupV1Alpha3SpecMetadata {
  /**
   * @schema WorkloadGroupV1Alpha3SpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema WorkloadGroupV1Alpha3SpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecMetadata(obj: WorkloadGroupV1Alpha3SpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
 *
 * @schema WorkloadGroupV1Alpha3SpecProbe
 */
export interface WorkloadGroupV1Alpha3SpecProbe {
  /**
   * Health is determined by how the command that is executed exited.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#exec
   */
  readonly exec?: WorkloadGroupV1Alpha3SpecProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC call is made and response/error is used to determine health.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#grpc
   */
  readonly grpc?: WorkloadGroupV1Alpha3SpecProbeGrpc;

  /**
   * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#httpGet
   */
  readonly httpGet?: WorkloadGroupV1Alpha3SpecProbeHttpGet;

  /**
   * Number of seconds after the container has started before readiness probes are initiated.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Health is determined by if the proxy is able to connect.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#tcpSocket
   */
  readonly tcpSocket?: WorkloadGroupV1Alpha3SpecProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecProbe(obj: WorkloadGroupV1Alpha3SpecProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_WorkloadGroupV1Alpha3SpecProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_WorkloadGroupV1Alpha3SpecProbeGrpc(obj.grpc),
    'httpGet': toJson_WorkloadGroupV1Alpha3SpecProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_WorkloadGroupV1Alpha3SpecProbeTcpSocket(obj.tcpSocket),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
 *
 * @schema WorkloadGroupV1Alpha3SpecTemplate
 */
export interface WorkloadGroupV1Alpha3SpecTemplate {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadGroupV1Alpha3SpecTemplate#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecTemplate(obj: WorkloadGroupV1Alpha3SpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Health is determined by how the command that is executed exited.
 *
 * @schema WorkloadGroupV1Alpha3SpecProbeExec
 */
export interface WorkloadGroupV1Alpha3SpecProbeExec {
  /**
   * Command to run.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbeExec#command
   */
  readonly command: string[];

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecProbeExec(obj: WorkloadGroupV1Alpha3SpecProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC call is made and response/error is used to determine health.
 *
 * @schema WorkloadGroupV1Alpha3SpecProbeGrpc
 */
export interface WorkloadGroupV1Alpha3SpecProbeGrpc {
  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbeGrpc#port
   */
  readonly port?: number;

  /**
   * @schema WorkloadGroupV1Alpha3SpecProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecProbeGrpc(obj: WorkloadGroupV1Alpha3SpecProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
 *
 * @schema WorkloadGroupV1Alpha3SpecProbeHttpGet
 */
export interface WorkloadGroupV1Alpha3SpecProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Headers the proxy will pass on to make the request.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGet#port
   */
  readonly port: number;

  /**
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecProbeHttpGet(obj: WorkloadGroupV1Alpha3SpecProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Health is determined by if the proxy is able to connect.
 *
 * @schema WorkloadGroupV1Alpha3SpecProbeTcpSocket
 */
export interface WorkloadGroupV1Alpha3SpecProbeTcpSocket {
  /**
   * @schema WorkloadGroupV1Alpha3SpecProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema WorkloadGroupV1Alpha3SpecProbeTcpSocket#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecProbeTcpSocket(obj: WorkloadGroupV1Alpha3SpecProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders
 */
export interface WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders {
  /**
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders#name
   */
  readonly name?: string;

  /**
   * @schema WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders(obj: WorkloadGroupV1Alpha3SpecProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema WorkloadGroupV1Beta1
 */
export class WorkloadGroupV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WorkloadGroupV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networking.istio.io/v1beta1',
    kind: 'WorkloadGroup',
  }

  /**
   * Renders a Kubernetes manifest for "WorkloadGroupV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WorkloadGroupV1Beta1Props): any {
    return {
      ...WorkloadGroupV1Beta1.GVK,
      ...toJson_WorkloadGroupV1Beta1Props(props),
    };
  }

  /**
   * Defines a "WorkloadGroupV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WorkloadGroupV1Beta1Props) {
    super(scope, id, {
      ...WorkloadGroupV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...WorkloadGroupV1Beta1.GVK,
      ...toJson_WorkloadGroupV1Beta1Props(resolved),
    };
  }
}

/**
 * @schema WorkloadGroupV1Beta1
 */
export interface WorkloadGroupV1Beta1Props {
  /**
   * @schema WorkloadGroupV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
   *
   * @schema WorkloadGroupV1Beta1#spec
   */
  readonly spec: WorkloadGroupV1Beta1Spec;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1Props(obj: WorkloadGroupV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WorkloadGroupV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
 *
 * @schema WorkloadGroupV1Beta1Spec
 */
export interface WorkloadGroupV1Beta1Spec {
  /**
   * Metadata that will be used for all corresponding `WorkloadEntries`.
   *
   * @schema WorkloadGroupV1Beta1Spec#metadata
   */
  readonly metadata?: WorkloadGroupV1Beta1SpecMetadata;

  /**
   * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
   *
   * @schema WorkloadGroupV1Beta1Spec#probe
   */
  readonly probe?: WorkloadGroupV1Beta1SpecProbe;

  /**
   * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
   *
   * @schema WorkloadGroupV1Beta1Spec#template
   */
  readonly template: WorkloadGroupV1Beta1SpecTemplate;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1Spec(obj: WorkloadGroupV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_WorkloadGroupV1Beta1SpecMetadata(obj.metadata),
    'probe': toJson_WorkloadGroupV1Beta1SpecProbe(obj.probe),
    'template': toJson_WorkloadGroupV1Beta1SpecTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Metadata that will be used for all corresponding `WorkloadEntries`.
 *
 * @schema WorkloadGroupV1Beta1SpecMetadata
 */
export interface WorkloadGroupV1Beta1SpecMetadata {
  /**
   * @schema WorkloadGroupV1Beta1SpecMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema WorkloadGroupV1Beta1SpecMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecMetadata(obj: WorkloadGroupV1Beta1SpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
 *
 * @schema WorkloadGroupV1Beta1SpecProbe
 */
export interface WorkloadGroupV1Beta1SpecProbe {
  /**
   * Health is determined by how the command that is executed exited.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#exec
   */
  readonly exec?: WorkloadGroupV1Beta1SpecProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC call is made and response/error is used to determine health.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#grpc
   */
  readonly grpc?: WorkloadGroupV1Beta1SpecProbeGrpc;

  /**
   * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#httpGet
   */
  readonly httpGet?: WorkloadGroupV1Beta1SpecProbeHttpGet;

  /**
   * Number of seconds after the container has started before readiness probes are initiated.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * Health is determined by if the proxy is able to connect.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#tcpSocket
   */
  readonly tcpSocket?: WorkloadGroupV1Beta1SpecProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out.
   *
   * @schema WorkloadGroupV1Beta1SpecProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbe' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbe(obj: WorkloadGroupV1Beta1SpecProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_WorkloadGroupV1Beta1SpecProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_WorkloadGroupV1Beta1SpecProbeGrpc(obj.grpc),
    'httpGet': toJson_WorkloadGroupV1Beta1SpecProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_WorkloadGroupV1Beta1SpecProbeTcpSocket(obj.tcpSocket),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
 *
 * @schema WorkloadGroupV1Beta1SpecTemplate
 */
export interface WorkloadGroupV1Beta1SpecTemplate {
  /**
   * Address associated with the network endpoint without the port.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#address
   */
  readonly address?: string;

  /**
   * One or more labels associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The locality associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#locality
   */
  readonly locality?: string;

  /**
   * Network enables Istio to group endpoints resident in the same L3 domain/network.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#network
   */
  readonly network?: string;

  /**
   * Set of ports associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#ports
   */
  readonly ports?: { [key: string]: number };

  /**
   * The service account associated with the workload if a sidecar is present in the workload.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * The load balancing weight associated with the endpoint.
   *
   * @schema WorkloadGroupV1Beta1SpecTemplate#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecTemplate(obj: WorkloadGroupV1Beta1SpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'locality': obj.locality,
    'network': obj.network,
    'ports': ((obj.ports) === undefined) ? undefined : (Object.entries(obj.ports).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceAccount': obj.serviceAccount,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Health is determined by how the command that is executed exited.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeExec
 */
export interface WorkloadGroupV1Beta1SpecProbeExec {
  /**
   * Command to run.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeExec#command
   */
  readonly command: string[];

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeExec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeExec(obj: WorkloadGroupV1Beta1SpecProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GRPC call is made and response/error is used to determine health.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeGrpc
 */
export interface WorkloadGroupV1Beta1SpecProbeGrpc {
  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeGrpc#port
   */
  readonly port?: number;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeGrpc(obj: WorkloadGroupV1Beta1SpecProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * `httpGet` is performed to a given endpoint and the status/able to connect determines health.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeHttpGet
 */
export interface WorkloadGroupV1Beta1SpecProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Headers the proxy will pass on to make the request.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Port on which the endpoint lives.
   *
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#port
   */
  readonly port: number;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeHttpGet(obj: WorkloadGroupV1Beta1SpecProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Health is determined by if the proxy is able to connect.
 *
 * @schema WorkloadGroupV1Beta1SpecProbeTcpSocket
 */
export interface WorkloadGroupV1Beta1SpecProbeTcpSocket {
  /**
   * @schema WorkloadGroupV1Beta1SpecProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeTcpSocket#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeTcpSocket(obj: WorkloadGroupV1Beta1SpecProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders
 */
export interface WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders {
  /**
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders#name
   */
  readonly name?: string;

  /**
   * @schema WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders(obj: WorkloadGroupV1Beta1SpecProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

