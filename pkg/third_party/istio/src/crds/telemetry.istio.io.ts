// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema Telemetry
 */
export class Telemetry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Telemetry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'telemetry.istio.io/v1',
    kind: 'Telemetry',
  }

  /**
   * Renders a Kubernetes manifest for "Telemetry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TelemetryProps = {}): any {
    return {
      ...Telemetry.GVK,
      ...toJson_TelemetryProps(props),
    };
  }

  /**
   * Defines a "Telemetry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TelemetryProps = {}) {
    super(scope, id, {
      ...Telemetry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...Telemetry.GVK,
      ...toJson_TelemetryProps(resolved),
    };
  }
}

/**
 * @schema Telemetry
 */
export interface TelemetryProps {
  /**
   * @schema Telemetry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
   *
   * @schema Telemetry#spec
   */
  readonly spec?: TelemetrySpec;

}

/**
 * Converts an object of type 'TelemetryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryProps(obj: TelemetryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TelemetrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
 *
 * @schema TelemetrySpec
 */
export interface TelemetrySpec {
  /**
   * Optional.
   *
   * @schema TelemetrySpec#accessLogging
   */
  readonly accessLogging?: TelemetrySpecAccessLogging[];

  /**
   * Optional.
   *
   * @schema TelemetrySpec#metrics
   */
  readonly metrics?: TelemetrySpecMetrics[];

  /**
   * Optional.
   *
   * @schema TelemetrySpec#selector
   */
  readonly selector?: TelemetrySpecSelector;

  /**
   * @schema TelemetrySpec#targetRef
   */
  readonly targetRef?: TelemetrySpecTargetRef;

  /**
   * Optional.
   *
   * @schema TelemetrySpec#targetRefs
   */
  readonly targetRefs?: TelemetrySpecTargetRefs[];

  /**
   * Optional.
   *
   * @schema TelemetrySpec#tracing
   */
  readonly tracing?: TelemetrySpecTracing[];

}

/**
 * Converts an object of type 'TelemetrySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpec(obj: TelemetrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogging': obj.accessLogging?.map(y => toJson_TelemetrySpecAccessLogging(y)),
    'metrics': obj.metrics?.map(y => toJson_TelemetrySpecMetrics(y)),
    'selector': toJson_TelemetrySpecSelector(obj.selector),
    'targetRef': toJson_TelemetrySpecTargetRef(obj.targetRef),
    'targetRefs': obj.targetRefs?.map(y => toJson_TelemetrySpecTargetRefs(y)),
    'tracing': obj.tracing?.map(y => toJson_TelemetrySpecTracing(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecAccessLogging
 */
export interface TelemetrySpecAccessLogging {
  /**
   * Controls logging.
   *
   * @schema TelemetrySpecAccessLogging#disabled
   */
  readonly disabled?: boolean;

  /**
   * Optional.
   *
   * @schema TelemetrySpecAccessLogging#filter
   */
  readonly filter?: TelemetrySpecAccessLoggingFilter;

  /**
   * Allows tailoring of logging behavior to specific conditions.
   *
   * @schema TelemetrySpecAccessLogging#match
   */
  readonly match?: TelemetrySpecAccessLoggingMatch;

  /**
   * Optional.
   *
   * @schema TelemetrySpecAccessLogging#providers
   */
  readonly providers?: TelemetrySpecAccessLoggingProviders[];

}

/**
 * Converts an object of type 'TelemetrySpecAccessLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecAccessLogging(obj: TelemetrySpecAccessLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'filter': toJson_TelemetrySpecAccessLoggingFilter(obj.filter),
    'match': toJson_TelemetrySpecAccessLoggingMatch(obj.match),
    'providers': obj.providers?.map(y => toJson_TelemetrySpecAccessLoggingProviders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecMetrics
 */
export interface TelemetrySpecMetrics {
  /**
   * Optional.
   *
   * @schema TelemetrySpecMetrics#overrides
   */
  readonly overrides?: TelemetrySpecMetricsOverrides[];

  /**
   * Optional.
   *
   * @schema TelemetrySpecMetrics#providers
   */
  readonly providers?: TelemetrySpecMetricsProviders[];

  /**
   * Optional.
   *
   * @schema TelemetrySpecMetrics#reportingInterval
   */
  readonly reportingInterval?: string;

}

/**
 * Converts an object of type 'TelemetrySpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecMetrics(obj: TelemetrySpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overrides': obj.overrides?.map(y => toJson_TelemetrySpecMetricsOverrides(y)),
    'providers': obj.providers?.map(y => toJson_TelemetrySpecMetricsProviders(y)),
    'reportingInterval': obj.reportingInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional.
 *
 * @schema TelemetrySpecSelector
 */
export interface TelemetrySpecSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema TelemetrySpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TelemetrySpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecSelector(obj: TelemetrySpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecTargetRef
 */
export interface TelemetrySpecTargetRef {
  /**
   * group is the group of the target resource.
   *
   * @schema TelemetrySpecTargetRef#group
   */
  readonly group?: string;

  /**
   * kind is kind of the target resource.
   *
   * @schema TelemetrySpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * name is the name of the target resource.
   *
   * @schema TelemetrySpecTargetRef#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the referent.
   *
   * @schema TelemetrySpecTargetRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'TelemetrySpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTargetRef(obj: TelemetrySpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecTargetRefs
 */
export interface TelemetrySpecTargetRefs {
  /**
   * group is the group of the target resource.
   *
   * @schema TelemetrySpecTargetRefs#group
   */
  readonly group?: string;

  /**
   * kind is kind of the target resource.
   *
   * @schema TelemetrySpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * name is the name of the target resource.
   *
   * @schema TelemetrySpecTargetRefs#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the referent.
   *
   * @schema TelemetrySpecTargetRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'TelemetrySpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTargetRefs(obj: TelemetrySpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecTracing
 */
export interface TelemetrySpecTracing {
  /**
   * Optional.
   *
   * @schema TelemetrySpecTracing#customTags
   */
  readonly customTags?: { [key: string]: TelemetrySpecTracingCustomTags };

  /**
   * Controls span reporting.
   *
   * @schema TelemetrySpecTracing#disableSpanReporting
   */
  readonly disableSpanReporting?: boolean;

  /**
   * Determines whether or not trace spans generated by Envoy will include Istio specific tags.
   *
   * @schema TelemetrySpecTracing#enableIstioTags
   */
  readonly enableIstioTags?: boolean;

  /**
   * Allows tailoring of behavior to specific conditions.
   *
   * @schema TelemetrySpecTracing#match
   */
  readonly match?: TelemetrySpecTracingMatch;

  /**
   * Optional.
   *
   * @schema TelemetrySpecTracing#providers
   */
  readonly providers?: TelemetrySpecTracingProviders[];

  /**
   * Controls the rate at which traffic will be selected for tracing if no prior sampling decision has been made.
   *
   * @schema TelemetrySpecTracing#randomSamplingPercentage
   */
  readonly randomSamplingPercentage?: number;

  /**
   * @schema TelemetrySpecTracing#useRequestIdForTraceSampling
   */
  readonly useRequestIdForTraceSampling?: boolean;

}

/**
 * Converts an object of type 'TelemetrySpecTracing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracing(obj: TelemetrySpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customTags': ((obj.customTags) === undefined) ? undefined : (Object.entries(obj.customTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_TelemetrySpecTracingCustomTags(i[1]) }), {})),
    'disableSpanReporting': obj.disableSpanReporting,
    'enableIstioTags': obj.enableIstioTags,
    'match': toJson_TelemetrySpecTracingMatch(obj.match),
    'providers': obj.providers?.map(y => toJson_TelemetrySpecTracingProviders(y)),
    'randomSamplingPercentage': obj.randomSamplingPercentage,
    'useRequestIdForTraceSampling': obj.useRequestIdForTraceSampling,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional.
 *
 * @schema TelemetrySpecAccessLoggingFilter
 */
export interface TelemetrySpecAccessLoggingFilter {
  /**
   * CEL expression for selecting when requests/connections should be logged.
   *
   * @schema TelemetrySpecAccessLoggingFilter#expression
   */
  readonly expression?: string;

}

/**
 * Converts an object of type 'TelemetrySpecAccessLoggingFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecAccessLoggingFilter(obj: TelemetrySpecAccessLoggingFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Allows tailoring of logging behavior to specific conditions.
 *
 * @schema TelemetrySpecAccessLoggingMatch
 */
export interface TelemetrySpecAccessLoggingMatch {
  /**
   * This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.
   *
   * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
   *
   * @schema TelemetrySpecAccessLoggingMatch#mode
   */
  readonly mode?: TelemetrySpecAccessLoggingMatchMode;

}

/**
 * Converts an object of type 'TelemetrySpecAccessLoggingMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecAccessLoggingMatch(obj: TelemetrySpecAccessLoggingMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecAccessLoggingProviders
 */
export interface TelemetrySpecAccessLoggingProviders {
  /**
   * Required.
   *
   * @schema TelemetrySpecAccessLoggingProviders#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetrySpecAccessLoggingProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecAccessLoggingProviders(obj: TelemetrySpecAccessLoggingProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecMetricsOverrides
 */
export interface TelemetrySpecMetricsOverrides {
  /**
   * Optional.
   *
   * @schema TelemetrySpecMetricsOverrides#disabled
   */
  readonly disabled?: boolean;

  /**
   * Match allows providing the scope of the override.
   *
   * @schema TelemetrySpecMetricsOverrides#match
   */
  readonly match?: TelemetrySpecMetricsOverridesMatch;

  /**
   * Optional.
   *
   * @schema TelemetrySpecMetricsOverrides#tagOverrides
   */
  readonly tagOverrides?: { [key: string]: TelemetrySpecMetricsOverridesTagOverrides };

}

/**
 * Converts an object of type 'TelemetrySpecMetricsOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecMetricsOverrides(obj: TelemetrySpecMetricsOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'match': toJson_TelemetrySpecMetricsOverridesMatch(obj.match),
    'tagOverrides': ((obj.tagOverrides) === undefined) ? undefined : (Object.entries(obj.tagOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_TelemetrySpecMetricsOverridesTagOverrides(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecMetricsProviders
 */
export interface TelemetrySpecMetricsProviders {
  /**
   * Required.
   *
   * @schema TelemetrySpecMetricsProviders#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetrySpecMetricsProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecMetricsProviders(obj: TelemetrySpecMetricsProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecTracingCustomTags
 */
export interface TelemetrySpecTracingCustomTags {
  /**
   * Environment adds the value of an environment variable to each span.
   *
   * @schema TelemetrySpecTracingCustomTags#environment
   */
  readonly environment?: TelemetrySpecTracingCustomTagsEnvironment;

  /**
   * RequestHeader adds the value of an header from the request to each span.
   *
   * @schema TelemetrySpecTracingCustomTags#header
   */
  readonly header?: TelemetrySpecTracingCustomTagsHeader;

  /**
   * Literal adds the same, hard-coded value to each span.
   *
   * @schema TelemetrySpecTracingCustomTags#literal
   */
  readonly literal?: TelemetrySpecTracingCustomTagsLiteral;

}

/**
 * Converts an object of type 'TelemetrySpecTracingCustomTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracingCustomTags(obj: TelemetrySpecTracingCustomTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environment': toJson_TelemetrySpecTracingCustomTagsEnvironment(obj.environment),
    'header': toJson_TelemetrySpecTracingCustomTagsHeader(obj.header),
    'literal': toJson_TelemetrySpecTracingCustomTagsLiteral(obj.literal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Allows tailoring of behavior to specific conditions.
 *
 * @schema TelemetrySpecTracingMatch
 */
export interface TelemetrySpecTracingMatch {
  /**
   * This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.
   *
   * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
   *
   * @schema TelemetrySpecTracingMatch#mode
   */
  readonly mode?: TelemetrySpecTracingMatchMode;

}

/**
 * Converts an object of type 'TelemetrySpecTracingMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracingMatch(obj: TelemetrySpecTracingMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecTracingProviders
 */
export interface TelemetrySpecTracingProviders {
  /**
   * Required.
   *
   * @schema TelemetrySpecTracingProviders#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetrySpecTracingProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracingProviders(obj: TelemetrySpecTracingProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.
 *
 * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
 *
 * @schema TelemetrySpecAccessLoggingMatchMode
 */
export enum TelemetrySpecAccessLoggingMatchMode {
  /** CLIENT_AND_SERVER */
  CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER = "CLIENT_AND_SERVER",
  /** CLIENT */
  CLIENT = "CLIENT",
  /** SERVER */
  SERVER = "SERVER",
}

/**
 * Match allows providing the scope of the override.
 *
 * @schema TelemetrySpecMetricsOverridesMatch
 */
export interface TelemetrySpecMetricsOverridesMatch {
  /**
   * Allows free-form specification of a metric.
   *
   * @schema TelemetrySpecMetricsOverridesMatch#customMetric
   */
  readonly customMetric?: string;

  /**
   * One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).
   *
   * Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
   *
   * @schema TelemetrySpecMetricsOverridesMatch#metric
   */
  readonly metric?: TelemetrySpecMetricsOverridesMatchMetric;

  /**
   * Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.
   *
   * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
   *
   * @schema TelemetrySpecMetricsOverridesMatch#mode
   */
  readonly mode?: TelemetrySpecMetricsOverridesMatchMode;

}

/**
 * Converts an object of type 'TelemetrySpecMetricsOverridesMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecMetricsOverridesMatch(obj: TelemetrySpecMetricsOverridesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customMetric': obj.customMetric,
    'metric': obj.metric,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetrySpecMetricsOverridesTagOverrides
 */
export interface TelemetrySpecMetricsOverridesTagOverrides {
  /**
   * Operation controls whether or not to update/add a tag, or to remove it.
   *
   * Valid Options: UPSERT, REMOVE
   *
   * @schema TelemetrySpecMetricsOverridesTagOverrides#operation
   */
  readonly operation?: TelemetrySpecMetricsOverridesTagOverridesOperation;

  /**
   * Value is only considered if the operation is `UPSERT`.
   *
   * @schema TelemetrySpecMetricsOverridesTagOverrides#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TelemetrySpecMetricsOverridesTagOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecMetricsOverridesTagOverrides(obj: TelemetrySpecMetricsOverridesTagOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operation': obj.operation,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Environment adds the value of an environment variable to each span.
 *
 * @schema TelemetrySpecTracingCustomTagsEnvironment
 */
export interface TelemetrySpecTracingCustomTagsEnvironment {
  /**
   * Optional.
   *
   * @schema TelemetrySpecTracingCustomTagsEnvironment#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name of the environment variable from which to extract the tag value.
   *
   * @schema TelemetrySpecTracingCustomTagsEnvironment#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetrySpecTracingCustomTagsEnvironment' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracingCustomTagsEnvironment(obj: TelemetrySpecTracingCustomTagsEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestHeader adds the value of an header from the request to each span.
 *
 * @schema TelemetrySpecTracingCustomTagsHeader
 */
export interface TelemetrySpecTracingCustomTagsHeader {
  /**
   * Optional.
   *
   * @schema TelemetrySpecTracingCustomTagsHeader#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name of the header from which to extract the tag value.
   *
   * @schema TelemetrySpecTracingCustomTagsHeader#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetrySpecTracingCustomTagsHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracingCustomTagsHeader(obj: TelemetrySpecTracingCustomTagsHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Literal adds the same, hard-coded value to each span.
 *
 * @schema TelemetrySpecTracingCustomTagsLiteral
 */
export interface TelemetrySpecTracingCustomTagsLiteral {
  /**
   * The tag value to use.
   *
   * @schema TelemetrySpecTracingCustomTagsLiteral#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TelemetrySpecTracingCustomTagsLiteral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetrySpecTracingCustomTagsLiteral(obj: TelemetrySpecTracingCustomTagsLiteral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.
 *
 * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
 *
 * @schema TelemetrySpecTracingMatchMode
 */
export enum TelemetrySpecTracingMatchMode {
  /** CLIENT_AND_SERVER */
  CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER = "CLIENT_AND_SERVER",
  /** CLIENT */
  CLIENT = "CLIENT",
  /** SERVER */
  SERVER = "SERVER",
}

/**
 * One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).
 *
 * Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
 *
 * @schema TelemetrySpecMetricsOverridesMatchMetric
 */
export enum TelemetrySpecMetricsOverridesMatchMetric {
  /** ALL_METRICS */
  ALL_UNDERSCORE_METRICS = "ALL_METRICS",
  /** REQUEST_COUNT */
  REQUEST_UNDERSCORE_COUNT = "REQUEST_COUNT",
  /** REQUEST_DURATION */
  REQUEST_UNDERSCORE_DURATION = "REQUEST_DURATION",
  /** REQUEST_SIZE */
  REQUEST_UNDERSCORE_SIZE = "REQUEST_SIZE",
  /** RESPONSE_SIZE */
  RESPONSE_UNDERSCORE_SIZE = "RESPONSE_SIZE",
  /** TCP_OPENED_CONNECTIONS */
  TCP_UNDERSCORE_OPENED_UNDERSCORE_CONNECTIONS = "TCP_OPENED_CONNECTIONS",
  /** TCP_CLOSED_CONNECTIONS */
  TCP_UNDERSCORE_CLOSED_UNDERSCORE_CONNECTIONS = "TCP_CLOSED_CONNECTIONS",
  /** TCP_SENT_BYTES */
  TCP_UNDERSCORE_SENT_UNDERSCORE_BYTES = "TCP_SENT_BYTES",
  /** TCP_RECEIVED_BYTES */
  TCP_UNDERSCORE_RECEIVED_UNDERSCORE_BYTES = "TCP_RECEIVED_BYTES",
  /** GRPC_REQUEST_MESSAGES */
  GRPC_UNDERSCORE_REQUEST_UNDERSCORE_MESSAGES = "GRPC_REQUEST_MESSAGES",
  /** GRPC_RESPONSE_MESSAGES */
  GRPC_UNDERSCORE_RESPONSE_UNDERSCORE_MESSAGES = "GRPC_RESPONSE_MESSAGES",
}

/**
 * Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.
 *
 * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
 *
 * @schema TelemetrySpecMetricsOverridesMatchMode
 */
export enum TelemetrySpecMetricsOverridesMatchMode {
  /** CLIENT_AND_SERVER */
  CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER = "CLIENT_AND_SERVER",
  /** CLIENT */
  CLIENT = "CLIENT",
  /** SERVER */
  SERVER = "SERVER",
}

/**
 * Operation controls whether or not to update/add a tag, or to remove it.
 *
 * Valid Options: UPSERT, REMOVE
 *
 * @schema TelemetrySpecMetricsOverridesTagOverridesOperation
 */
export enum TelemetrySpecMetricsOverridesTagOverridesOperation {
  /** UPSERT */
  UPSERT = "UPSERT",
  /** REMOVE */
  REMOVE = "REMOVE",
}


/**
 *
 *
 * @schema TelemetryV1Alpha1
 */
export class TelemetryV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TelemetryV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'telemetry.istio.io/v1alpha1',
    kind: 'Telemetry',
  }

  /**
   * Renders a Kubernetes manifest for "TelemetryV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TelemetryV1Alpha1Props = {}): any {
    return {
      ...TelemetryV1Alpha1.GVK,
      ...toJson_TelemetryV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "TelemetryV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TelemetryV1Alpha1Props = {}) {
    super(scope, id, {
      ...TelemetryV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public override toJson(): any {
    const resolved = super.toJson();

    return {
      ...TelemetryV1Alpha1.GVK,
      ...toJson_TelemetryV1Alpha1Props(resolved),
    };
  }
}

/**
 * @schema TelemetryV1Alpha1
 */
export interface TelemetryV1Alpha1Props {
  /**
   * @schema TelemetryV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
   *
   * @schema TelemetryV1Alpha1#spec
   */
  readonly spec?: TelemetryV1Alpha1Spec;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1Props(obj: TelemetryV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TelemetryV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
 *
 * @schema TelemetryV1Alpha1Spec
 */
export interface TelemetryV1Alpha1Spec {
  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1Spec#accessLogging
   */
  readonly accessLogging?: TelemetryV1Alpha1SpecAccessLogging[];

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1Spec#metrics
   */
  readonly metrics?: TelemetryV1Alpha1SpecMetrics[];

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1Spec#selector
   */
  readonly selector?: TelemetryV1Alpha1SpecSelector;

  /**
   * @schema TelemetryV1Alpha1Spec#targetRef
   */
  readonly targetRef?: TelemetryV1Alpha1SpecTargetRef;

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1Spec#targetRefs
   */
  readonly targetRefs?: TelemetryV1Alpha1SpecTargetRefs[];

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1Spec#tracing
   */
  readonly tracing?: TelemetryV1Alpha1SpecTracing[];

}

/**
 * Converts an object of type 'TelemetryV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1Spec(obj: TelemetryV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogging': obj.accessLogging?.map(y => toJson_TelemetryV1Alpha1SpecAccessLogging(y)),
    'metrics': obj.metrics?.map(y => toJson_TelemetryV1Alpha1SpecMetrics(y)),
    'selector': toJson_TelemetryV1Alpha1SpecSelector(obj.selector),
    'targetRef': toJson_TelemetryV1Alpha1SpecTargetRef(obj.targetRef),
    'targetRefs': obj.targetRefs?.map(y => toJson_TelemetryV1Alpha1SpecTargetRefs(y)),
    'tracing': obj.tracing?.map(y => toJson_TelemetryV1Alpha1SpecTracing(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecAccessLogging
 */
export interface TelemetryV1Alpha1SpecAccessLogging {
  /**
   * Controls logging.
   *
   * @schema TelemetryV1Alpha1SpecAccessLogging#disabled
   */
  readonly disabled?: boolean;

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecAccessLogging#filter
   */
  readonly filter?: TelemetryV1Alpha1SpecAccessLoggingFilter;

  /**
   * Allows tailoring of logging behavior to specific conditions.
   *
   * @schema TelemetryV1Alpha1SpecAccessLogging#match
   */
  readonly match?: TelemetryV1Alpha1SpecAccessLoggingMatch;

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecAccessLogging#providers
   */
  readonly providers?: TelemetryV1Alpha1SpecAccessLoggingProviders[];

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecAccessLogging' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecAccessLogging(obj: TelemetryV1Alpha1SpecAccessLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'filter': toJson_TelemetryV1Alpha1SpecAccessLoggingFilter(obj.filter),
    'match': toJson_TelemetryV1Alpha1SpecAccessLoggingMatch(obj.match),
    'providers': obj.providers?.map(y => toJson_TelemetryV1Alpha1SpecAccessLoggingProviders(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecMetrics
 */
export interface TelemetryV1Alpha1SpecMetrics {
  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecMetrics#overrides
   */
  readonly overrides?: TelemetryV1Alpha1SpecMetricsOverrides[];

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecMetrics#providers
   */
  readonly providers?: TelemetryV1Alpha1SpecMetricsProviders[];

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecMetrics#reportingInterval
   */
  readonly reportingInterval?: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecMetrics' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecMetrics(obj: TelemetryV1Alpha1SpecMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'overrides': obj.overrides?.map(y => toJson_TelemetryV1Alpha1SpecMetricsOverrides(y)),
    'providers': obj.providers?.map(y => toJson_TelemetryV1Alpha1SpecMetricsProviders(y)),
    'reportingInterval': obj.reportingInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional.
 *
 * @schema TelemetryV1Alpha1SpecSelector
 */
export interface TelemetryV1Alpha1SpecSelector {
  /**
   * One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.
   *
   * @schema TelemetryV1Alpha1SpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecSelector(obj: TelemetryV1Alpha1SpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecTargetRef
 */
export interface TelemetryV1Alpha1SpecTargetRef {
  /**
   * group is the group of the target resource.
   *
   * @schema TelemetryV1Alpha1SpecTargetRef#group
   */
  readonly group?: string;

  /**
   * kind is kind of the target resource.
   *
   * @schema TelemetryV1Alpha1SpecTargetRef#kind
   */
  readonly kind: string;

  /**
   * name is the name of the target resource.
   *
   * @schema TelemetryV1Alpha1SpecTargetRef#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the referent.
   *
   * @schema TelemetryV1Alpha1SpecTargetRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTargetRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTargetRef(obj: TelemetryV1Alpha1SpecTargetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecTargetRefs
 */
export interface TelemetryV1Alpha1SpecTargetRefs {
  /**
   * group is the group of the target resource.
   *
   * @schema TelemetryV1Alpha1SpecTargetRefs#group
   */
  readonly group?: string;

  /**
   * kind is kind of the target resource.
   *
   * @schema TelemetryV1Alpha1SpecTargetRefs#kind
   */
  readonly kind: string;

  /**
   * name is the name of the target resource.
   *
   * @schema TelemetryV1Alpha1SpecTargetRefs#name
   */
  readonly name: string;

  /**
   * namespace is the namespace of the referent.
   *
   * @schema TelemetryV1Alpha1SpecTargetRefs#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTargetRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTargetRefs(obj: TelemetryV1Alpha1SpecTargetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecTracing
 */
export interface TelemetryV1Alpha1SpecTracing {
  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecTracing#customTags
   */
  readonly customTags?: { [key: string]: TelemetryV1Alpha1SpecTracingCustomTags };

  /**
   * Controls span reporting.
   *
   * @schema TelemetryV1Alpha1SpecTracing#disableSpanReporting
   */
  readonly disableSpanReporting?: boolean;

  /**
   * Determines whether or not trace spans generated by Envoy will include Istio specific tags.
   *
   * @schema TelemetryV1Alpha1SpecTracing#enableIstioTags
   */
  readonly enableIstioTags?: boolean;

  /**
   * Allows tailoring of behavior to specific conditions.
   *
   * @schema TelemetryV1Alpha1SpecTracing#match
   */
  readonly match?: TelemetryV1Alpha1SpecTracingMatch;

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecTracing#providers
   */
  readonly providers?: TelemetryV1Alpha1SpecTracingProviders[];

  /**
   * Controls the rate at which traffic will be selected for tracing if no prior sampling decision has been made.
   *
   * @schema TelemetryV1Alpha1SpecTracing#randomSamplingPercentage
   */
  readonly randomSamplingPercentage?: number;

  /**
   * @schema TelemetryV1Alpha1SpecTracing#useRequestIdForTraceSampling
   */
  readonly useRequestIdForTraceSampling?: boolean;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracing' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracing(obj: TelemetryV1Alpha1SpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customTags': ((obj.customTags) === undefined) ? undefined : (Object.entries(obj.customTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_TelemetryV1Alpha1SpecTracingCustomTags(i[1]) }), {})),
    'disableSpanReporting': obj.disableSpanReporting,
    'enableIstioTags': obj.enableIstioTags,
    'match': toJson_TelemetryV1Alpha1SpecTracingMatch(obj.match),
    'providers': obj.providers?.map(y => toJson_TelemetryV1Alpha1SpecTracingProviders(y)),
    'randomSamplingPercentage': obj.randomSamplingPercentage,
    'useRequestIdForTraceSampling': obj.useRequestIdForTraceSampling,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional.
 *
 * @schema TelemetryV1Alpha1SpecAccessLoggingFilter
 */
export interface TelemetryV1Alpha1SpecAccessLoggingFilter {
  /**
   * CEL expression for selecting when requests/connections should be logged.
   *
   * @schema TelemetryV1Alpha1SpecAccessLoggingFilter#expression
   */
  readonly expression?: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecAccessLoggingFilter' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecAccessLoggingFilter(obj: TelemetryV1Alpha1SpecAccessLoggingFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Allows tailoring of logging behavior to specific conditions.
 *
 * @schema TelemetryV1Alpha1SpecAccessLoggingMatch
 */
export interface TelemetryV1Alpha1SpecAccessLoggingMatch {
  /**
   * This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.
   *
   * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
   *
   * @schema TelemetryV1Alpha1SpecAccessLoggingMatch#mode
   */
  readonly mode?: TelemetryV1Alpha1SpecAccessLoggingMatchMode;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecAccessLoggingMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecAccessLoggingMatch(obj: TelemetryV1Alpha1SpecAccessLoggingMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecAccessLoggingProviders
 */
export interface TelemetryV1Alpha1SpecAccessLoggingProviders {
  /**
   * Required.
   *
   * @schema TelemetryV1Alpha1SpecAccessLoggingProviders#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecAccessLoggingProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecAccessLoggingProviders(obj: TelemetryV1Alpha1SpecAccessLoggingProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecMetricsOverrides
 */
export interface TelemetryV1Alpha1SpecMetricsOverrides {
  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverrides#disabled
   */
  readonly disabled?: boolean;

  /**
   * Match allows providing the scope of the override.
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverrides#match
   */
  readonly match?: TelemetryV1Alpha1SpecMetricsOverridesMatch;

  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverrides#tagOverrides
   */
  readonly tagOverrides?: { [key: string]: TelemetryV1Alpha1SpecMetricsOverridesTagOverrides };

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecMetricsOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecMetricsOverrides(obj: TelemetryV1Alpha1SpecMetricsOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disabled': obj.disabled,
    'match': toJson_TelemetryV1Alpha1SpecMetricsOverridesMatch(obj.match),
    'tagOverrides': ((obj.tagOverrides) === undefined) ? undefined : (Object.entries(obj.tagOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_TelemetryV1Alpha1SpecMetricsOverridesTagOverrides(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecMetricsProviders
 */
export interface TelemetryV1Alpha1SpecMetricsProviders {
  /**
   * Required.
   *
   * @schema TelemetryV1Alpha1SpecMetricsProviders#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecMetricsProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecMetricsProviders(obj: TelemetryV1Alpha1SpecMetricsProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecTracingCustomTags
 */
export interface TelemetryV1Alpha1SpecTracingCustomTags {
  /**
   * Environment adds the value of an environment variable to each span.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTags#environment
   */
  readonly environment?: TelemetryV1Alpha1SpecTracingCustomTagsEnvironment;

  /**
   * RequestHeader adds the value of an header from the request to each span.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTags#header
   */
  readonly header?: TelemetryV1Alpha1SpecTracingCustomTagsHeader;

  /**
   * Literal adds the same, hard-coded value to each span.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTags#literal
   */
  readonly literal?: TelemetryV1Alpha1SpecTracingCustomTagsLiteral;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracingCustomTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracingCustomTags(obj: TelemetryV1Alpha1SpecTracingCustomTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environment': toJson_TelemetryV1Alpha1SpecTracingCustomTagsEnvironment(obj.environment),
    'header': toJson_TelemetryV1Alpha1SpecTracingCustomTagsHeader(obj.header),
    'literal': toJson_TelemetryV1Alpha1SpecTracingCustomTagsLiteral(obj.literal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Allows tailoring of behavior to specific conditions.
 *
 * @schema TelemetryV1Alpha1SpecTracingMatch
 */
export interface TelemetryV1Alpha1SpecTracingMatch {
  /**
   * This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.
   *
   * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
   *
   * @schema TelemetryV1Alpha1SpecTracingMatch#mode
   */
  readonly mode?: TelemetryV1Alpha1SpecTracingMatchMode;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracingMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracingMatch(obj: TelemetryV1Alpha1SpecTracingMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecTracingProviders
 */
export interface TelemetryV1Alpha1SpecTracingProviders {
  /**
   * Required.
   *
   * @schema TelemetryV1Alpha1SpecTracingProviders#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracingProviders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracingProviders(obj: TelemetryV1Alpha1SpecTracingProviders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This determines whether or not to apply the access logging configuration based on the direction of traffic relative to the proxied workload.
 *
 * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
 *
 * @schema TelemetryV1Alpha1SpecAccessLoggingMatchMode
 */
export enum TelemetryV1Alpha1SpecAccessLoggingMatchMode {
  /** CLIENT_AND_SERVER */
  CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER = "CLIENT_AND_SERVER",
  /** CLIENT */
  CLIENT = "CLIENT",
  /** SERVER */
  SERVER = "SERVER",
}

/**
 * Match allows providing the scope of the override.
 *
 * @schema TelemetryV1Alpha1SpecMetricsOverridesMatch
 */
export interface TelemetryV1Alpha1SpecMetricsOverridesMatch {
  /**
   * Allows free-form specification of a metric.
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverridesMatch#customMetric
   */
  readonly customMetric?: string;

  /**
   * One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).
   *
   * Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverridesMatch#metric
   */
  readonly metric?: TelemetryV1Alpha1SpecMetricsOverridesMatchMetric;

  /**
   * Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.
   *
   * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverridesMatch#mode
   */
  readonly mode?: TelemetryV1Alpha1SpecMetricsOverridesMatchMode;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecMetricsOverridesMatch' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecMetricsOverridesMatch(obj: TelemetryV1Alpha1SpecMetricsOverridesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customMetric': obj.customMetric,
    'metric': obj.metric,
    'mode': obj.mode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TelemetryV1Alpha1SpecMetricsOverridesTagOverrides
 */
export interface TelemetryV1Alpha1SpecMetricsOverridesTagOverrides {
  /**
   * Operation controls whether or not to update/add a tag, or to remove it.
   *
   * Valid Options: UPSERT, REMOVE
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverridesTagOverrides#operation
   */
  readonly operation?: TelemetryV1Alpha1SpecMetricsOverridesTagOverridesOperation;

  /**
   * Value is only considered if the operation is `UPSERT`.
   *
   * @schema TelemetryV1Alpha1SpecMetricsOverridesTagOverrides#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecMetricsOverridesTagOverrides' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecMetricsOverridesTagOverrides(obj: TelemetryV1Alpha1SpecMetricsOverridesTagOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'operation': obj.operation,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Environment adds the value of an environment variable to each span.
 *
 * @schema TelemetryV1Alpha1SpecTracingCustomTagsEnvironment
 */
export interface TelemetryV1Alpha1SpecTracingCustomTagsEnvironment {
  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTagsEnvironment#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name of the environment variable from which to extract the tag value.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTagsEnvironment#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracingCustomTagsEnvironment' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracingCustomTagsEnvironment(obj: TelemetryV1Alpha1SpecTracingCustomTagsEnvironment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RequestHeader adds the value of an header from the request to each span.
 *
 * @schema TelemetryV1Alpha1SpecTracingCustomTagsHeader
 */
export interface TelemetryV1Alpha1SpecTracingCustomTagsHeader {
  /**
   * Optional.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTagsHeader#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * Name of the header from which to extract the tag value.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTagsHeader#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracingCustomTagsHeader' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracingCustomTagsHeader(obj: TelemetryV1Alpha1SpecTracingCustomTagsHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultValue': obj.defaultValue,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Literal adds the same, hard-coded value to each span.
 *
 * @schema TelemetryV1Alpha1SpecTracingCustomTagsLiteral
 */
export interface TelemetryV1Alpha1SpecTracingCustomTagsLiteral {
  /**
   * The tag value to use.
   *
   * @schema TelemetryV1Alpha1SpecTracingCustomTagsLiteral#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'TelemetryV1Alpha1SpecTracingCustomTagsLiteral' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TelemetryV1Alpha1SpecTracingCustomTagsLiteral(obj: TelemetryV1Alpha1SpecTracingCustomTagsLiteral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * This determines whether or not to apply the tracing configuration based on the direction of traffic relative to the proxied workload.
 *
 * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
 *
 * @schema TelemetryV1Alpha1SpecTracingMatchMode
 */
export enum TelemetryV1Alpha1SpecTracingMatchMode {
  /** CLIENT_AND_SERVER */
  CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER = "CLIENT_AND_SERVER",
  /** CLIENT */
  CLIENT = "CLIENT",
  /** SERVER */
  SERVER = "SERVER",
}

/**
 * One of the well-known [Istio Standard Metrics](https://istio.io/latest/docs/reference/config/metrics/).
 *
 * Valid Options: ALL_METRICS, REQUEST_COUNT, REQUEST_DURATION, REQUEST_SIZE, RESPONSE_SIZE, TCP_OPENED_CONNECTIONS, TCP_CLOSED_CONNECTIONS, TCP_SENT_BYTES, TCP_RECEIVED_BYTES, GRPC_REQUEST_MESSAGES, GRPC_RESPONSE_MESSAGES
 *
 * @schema TelemetryV1Alpha1SpecMetricsOverridesMatchMetric
 */
export enum TelemetryV1Alpha1SpecMetricsOverridesMatchMetric {
  /** ALL_METRICS */
  ALL_UNDERSCORE_METRICS = "ALL_METRICS",
  /** REQUEST_COUNT */
  REQUEST_UNDERSCORE_COUNT = "REQUEST_COUNT",
  /** REQUEST_DURATION */
  REQUEST_UNDERSCORE_DURATION = "REQUEST_DURATION",
  /** REQUEST_SIZE */
  REQUEST_UNDERSCORE_SIZE = "REQUEST_SIZE",
  /** RESPONSE_SIZE */
  RESPONSE_UNDERSCORE_SIZE = "RESPONSE_SIZE",
  /** TCP_OPENED_CONNECTIONS */
  TCP_UNDERSCORE_OPENED_UNDERSCORE_CONNECTIONS = "TCP_OPENED_CONNECTIONS",
  /** TCP_CLOSED_CONNECTIONS */
  TCP_UNDERSCORE_CLOSED_UNDERSCORE_CONNECTIONS = "TCP_CLOSED_CONNECTIONS",
  /** TCP_SENT_BYTES */
  TCP_UNDERSCORE_SENT_UNDERSCORE_BYTES = "TCP_SENT_BYTES",
  /** TCP_RECEIVED_BYTES */
  TCP_UNDERSCORE_RECEIVED_UNDERSCORE_BYTES = "TCP_RECEIVED_BYTES",
  /** GRPC_REQUEST_MESSAGES */
  GRPC_UNDERSCORE_REQUEST_UNDERSCORE_MESSAGES = "GRPC_REQUEST_MESSAGES",
  /** GRPC_RESPONSE_MESSAGES */
  GRPC_UNDERSCORE_RESPONSE_UNDERSCORE_MESSAGES = "GRPC_RESPONSE_MESSAGES",
}

/**
 * Controls which mode of metrics generation is selected: `CLIENT`, `SERVER`, or `CLIENT_AND_SERVER`.
 *
 * Valid Options: CLIENT_AND_SERVER, CLIENT, SERVER
 *
 * @schema TelemetryV1Alpha1SpecMetricsOverridesMatchMode
 */
export enum TelemetryV1Alpha1SpecMetricsOverridesMatchMode {
  /** CLIENT_AND_SERVER */
  CLIENT_UNDERSCORE_AND_UNDERSCORE_SERVER = "CLIENT_AND_SERVER",
  /** CLIENT */
  CLIENT = "CLIENT",
  /** SERVER */
  SERVER = "SERVER",
}

/**
 * Operation controls whether or not to update/add a tag, or to remove it.
 *
 * Valid Options: UPSERT, REMOVE
 *
 * @schema TelemetryV1Alpha1SpecMetricsOverridesTagOverridesOperation
 */
export enum TelemetryV1Alpha1SpecMetricsOverridesTagOverridesOperation {
  /** UPSERT */
  UPSERT = "UPSERT",
  /** REMOVE */
  REMOVE = "REMOVE",
}

