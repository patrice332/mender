// generated by cdk8s
import { Helm, HelmProps } from 'cdk8s';
import { Construct } from 'constructs';

export interface KnativeoperatorProps {
  readonly namespace?: string;
  readonly releaseName?: string;
  readonly helmExecutable?: string;
  readonly helmFlags?: string[];
  readonly values?: { [key: string]: any };
}

export class Knativeoperator extends Construct {
  public constructor(scope: Construct, id: string, props: KnativeoperatorProps = {}) {
    super(scope, id);
    let updatedProps = {};

    if (props.values) {
      const values = props.values;
      if (values) {
        const { additionalValues, ...valuesWithoutAdditionalValues } = values;
        updatedProps = {
          ...props,
          values: {
            ...this.flattenAdditionalValues(valuesWithoutAdditionalValues),
            ...additionalValues,
          },
        };
      }
    }

    const finalProps: HelmProps = {
      chart: 'knative-operator',
      repo: 'https://knative.github.io/operator',
      version: '1.19.3',
      ...(Object.keys(updatedProps).length !== 0 ? updatedProps : props),
    };

    new Helm(this, 'Helm', finalProps);
  }

  private flattenAdditionalValues(props: { [key: string]: any }): { [key: string]: any } {
    for (let prop in props) {
      if (Array.isArray(props[prop])) {
        props[prop].map((item: any) => {
          if (typeof item === 'object' && prop !== 'additionalValues') {
            return this.flattenAdditionalValues(item);
          }
          return item;
        });
      }
      else if (typeof props[prop] === 'object' && prop !== 'additionalValues') {
        props[prop] = this.flattenAdditionalValues(props[prop]);
      }
    }

    const { additionalValues, ...valuesWithoutAdditionalValues } = props;

    return {
      ...valuesWithoutAdditionalValues,
      ...additionalValues,
    };
  }
}

