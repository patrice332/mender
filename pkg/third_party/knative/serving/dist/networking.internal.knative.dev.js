// generated by cdk8s
import { ApiObject } from 'cdk8s';
/**
 * Certificate is responsible for provisioning a SSL certificate for the
given hosts. It is a Knative abstraction for various SSL certificate
provisioning solutions (such as cert-manager or self-signed SSL certificate).
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
    /**
     * Returns the apiVersion and kind for "Certificate"
     */
    static GVK = {
        apiVersion: 'networking.internal.knative.dev/v1alpha1',
        kind: 'Certificate',
    };
    /**
     * Renders a Kubernetes manifest for "Certificate".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...Certificate.GVK,
            ...toJson_CertificateProps(props),
        };
    }
    /**
     * Defines a "Certificate" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...Certificate.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...Certificate.GVK,
            ...toJson_CertificateProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CertificateProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_CertificateSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CertificateSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'dnsNames': obj.dnsNames?.map(y => y),
        'domain': obj.domain,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * ClusterDomainClaim is a cluster-wide reservation for a particular domain name.
 *
 * @schema ClusterDomainClaim
 */
export class ClusterDomainClaim extends ApiObject {
    /**
     * Returns the apiVersion and kind for "ClusterDomainClaim"
     */
    static GVK = {
        apiVersion: 'networking.internal.knative.dev/v1alpha1',
        kind: 'ClusterDomainClaim',
    };
    /**
     * Renders a Kubernetes manifest for "ClusterDomainClaim".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...ClusterDomainClaim.GVK,
            ...toJson_ClusterDomainClaimProps(props),
        };
    }
    /**
     * Defines a "ClusterDomainClaim" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...ClusterDomainClaim.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...ClusterDomainClaim.GVK,
            ...toJson_ClusterDomainClaimProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'ClusterDomainClaimProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterDomainClaimProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_ClusterDomainClaimSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'ClusterDomainClaimSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterDomainClaimSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Ingress is a collection of rules that allow inbound connections to reach the endpoints defined
by a backend. An Ingress can be configured to give services externally-reachable URLs, load
balance traffic, offer name based virtual hosting, etc.

This is heavily based on K8s Ingress https://godoc.org/k8s.io/api/networking/v1beta1#Ingress
which some highlighted modifications.
 *
 * @schema Ingress
 */
export class Ingress extends ApiObject {
    /**
     * Returns the apiVersion and kind for "Ingress"
     */
    static GVK = {
        apiVersion: 'networking.internal.knative.dev/v1alpha1',
        kind: 'Ingress',
    };
    /**
     * Renders a Kubernetes manifest for "Ingress".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...Ingress.GVK,
            ...toJson_IngressProps(props),
        };
    }
    /**
     * Defines a "Ingress" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...Ingress.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...Ingress.GVK,
            ...toJson_IngressProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'IngressProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_IngressSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'httpOption': obj.httpOption,
        'rules': obj.rules?.map(y => toJson_IngressSpecRules(y)),
        'tls': obj.tls?.map(y => toJson_IngressSpecTls(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpecRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpecRules(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hosts': obj.hosts?.map(y => y),
        'http': toJson_IngressSpecRulesHttp(obj.http),
        'visibility': obj.visibility,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpecTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpecTls(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hosts': obj.hosts?.map(y => y),
        'secretName': obj.secretName,
        'secretNamespace': obj.secretNamespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpecRulesHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpecRulesHttp(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'paths': obj.paths?.map(y => toJson_IngressSpecRulesHttpPaths(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpecRulesHttpPaths' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpecRulesHttpPaths(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'appendHeaders': ((obj.appendHeaders) === undefined) ? undefined : (Object.entries(obj.appendHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_IngressSpecRulesHttpPathsHeaders(i[1]) }), {})),
        'path': obj.path,
        'rewriteHost': obj.rewriteHost,
        'splits': obj.splits?.map(y => toJson_IngressSpecRulesHttpPathsSplits(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpecRulesHttpPathsHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpecRulesHttpPathsHeaders(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'exact': obj.exact,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'IngressSpecRulesHttpPathsSplits' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_IngressSpecRulesHttpPathsSplits(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'appendHeaders': ((obj.appendHeaders) === undefined) ? undefined : (Object.entries(obj.appendHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'percent': obj.percent,
        'serviceName': obj.serviceName,
        'serviceNamespace': obj.serviceNamespace,
        'servicePort': obj.servicePort?.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Specifies the port of the referenced service.
 *
 * @schema IngressSpecRulesHttpPathsSplitsServicePort
 */
export class IngressSpecRulesHttpPathsSplitsServicePort {
    value;
    static fromNumber(value) {
        return new IngressSpecRulesHttpPathsSplitsServicePort(value);
    }
    static fromString(value) {
        return new IngressSpecRulesHttpPathsSplitsServicePort(value);
    }
    constructor(value) {
        this.value = value;
    }
}
/**
 * ServerlessService is a proxy for the K8s service objects containing the
endpoints for the revision, whether those are endpoints of the activator or
revision pods.
See: https://knative.page.link/naxz for details.
 *
 * @schema ServerlessService
 */
export class ServerlessService extends ApiObject {
    /**
     * Returns the apiVersion and kind for "ServerlessService"
     */
    static GVK = {
        apiVersion: 'networking.internal.knative.dev/v1alpha1',
        kind: 'ServerlessService',
    };
    /**
     * Renders a Kubernetes manifest for "ServerlessService".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...ServerlessService.GVK,
            ...toJson_ServerlessServiceProps(props),
        };
    }
    /**
     * Defines a "ServerlessService" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...ServerlessService.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...ServerlessService.GVK,
            ...toJson_ServerlessServiceProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'ServerlessServiceProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServerlessServiceProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_ServerlessServiceSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'ServerlessServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServerlessServiceSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'mode': obj.mode,
        'numActivators': obj.numActivators,
        'objectRef': toJson_ServerlessServiceSpecObjectRef(obj.objectRef),
        'protocolType': obj.protocolType,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'ServerlessServiceSpecObjectRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ServerlessServiceSpecObjectRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'apiVersion': obj.apiVersion,
        'fieldPath': obj.fieldPath,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'resourceVersion': obj.resourceVersion,
        'uid': obj.uid,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
