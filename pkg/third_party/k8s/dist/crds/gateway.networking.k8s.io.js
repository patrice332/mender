// generated by cdk8s
import { ApiObject } from 'cdk8s';
/**
 * Gateway represents an instance of a service-traffic handling infrastructure
by binding Listeners to a set of IP addresses.
 *
 * @schema Gateway
 */
export class Gateway extends ApiObject {
    /**
     * Returns the apiVersion and kind for "Gateway"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1',
        kind: 'Gateway',
    };
    /**
     * Renders a Kubernetes manifest for "Gateway".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...Gateway.GVK,
            ...toJson_GatewayProps(props),
        };
    }
    /**
     * Defines a "Gateway" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...Gateway.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...Gateway.GVK,
            ...toJson_GatewayProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'GatewayProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_GatewaySpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addresses': obj.addresses?.map(y => toJson_GatewaySpecAddresses(y)),
        'gatewayClassName': obj.gatewayClassName,
        'infrastructure': toJson_GatewaySpecInfrastructure(obj.infrastructure),
        'listeners': obj.listeners?.map(y => toJson_GatewaySpecListeners(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecAddresses' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecAddresses(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecInfrastructure' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecInfrastructure(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'parametersRef': toJson_GatewaySpecInfrastructureParametersRef(obj.parametersRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListeners(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowedRoutes': toJson_GatewaySpecListenersAllowedRoutes(obj.allowedRoutes),
        'hostname': obj.hostname,
        'name': obj.name,
        'port': obj.port,
        'protocol': obj.protocol,
        'tls': toJson_GatewaySpecListenersTls(obj.tls),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecInfrastructureParametersRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecInfrastructureParametersRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListenersAllowedRoutes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersAllowedRoutes(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'kinds': obj.kinds?.map(y => toJson_GatewaySpecListenersAllowedRoutesKinds(y)),
        'namespaces': toJson_GatewaySpecListenersAllowedRoutesNamespaces(obj.namespaces),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListenersTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersTls(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'certificateRefs': obj.certificateRefs?.map(y => toJson_GatewaySpecListenersTlsCertificateRefs(y)),
        'mode': obj.mode,
        'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListenersAllowedRoutesKinds' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersAllowedRoutesKinds(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListenersAllowedRoutesNamespaces' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersAllowedRoutesNamespaces(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'from': obj.from,
        'selector': toJson_GatewaySpecListenersAllowedRoutesNamespacesSelector(obj.selector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListenersTlsCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersTlsCertificateRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Mode defines the TLS behavior for the TLS session initiated by the client.
 * There are two possible modes:
 *
 * - Terminate: The TLS session between the downstream client and the
 * Gateway is terminated at the Gateway. This mode requires certificates
 * to be specified in some way, such as populating the certificateRefs
 * field.
 * - Passthrough: The TLS session is NOT terminated by the Gateway. This
 * implies that the Gateway can't decipher the TLS stream except for
 * the ClientHello message of the TLS protocol. The certificateRefs field
 * is ignored in this mode.
 *
 * Support: Core
 *
 * @schema GatewaySpecListenersTlsMode
 */
export var GatewaySpecListenersTlsMode;
(function (GatewaySpecListenersTlsMode) {
    /** Terminate */
    GatewaySpecListenersTlsMode["TERMINATE"] = "Terminate";
    /** Passthrough */
    GatewaySpecListenersTlsMode["PASSTHROUGH"] = "Passthrough";
})(GatewaySpecListenersTlsMode || (GatewaySpecListenersTlsMode = {}));
/**
 * From indicates where Routes will be selected for this Gateway. Possible
 * values are:
 *
 * * All: Routes in all namespaces may be used by this Gateway.
 * * Selector: Routes in namespaces selected by the selector may be used by
 * this Gateway.
 * * Same: Only Routes in the same namespace may be used by this Gateway.
 *
 * Support: Core
 *
 * @schema GatewaySpecListenersAllowedRoutesNamespacesFrom
 */
export var GatewaySpecListenersAllowedRoutesNamespacesFrom;
(function (GatewaySpecListenersAllowedRoutesNamespacesFrom) {
    /** All */
    GatewaySpecListenersAllowedRoutesNamespacesFrom["ALL"] = "All";
    /** Selector */
    GatewaySpecListenersAllowedRoutesNamespacesFrom["SELECTOR"] = "Selector";
    /** Same */
    GatewaySpecListenersAllowedRoutesNamespacesFrom["SAME"] = "Same";
})(GatewaySpecListenersAllowedRoutesNamespacesFrom || (GatewaySpecListenersAllowedRoutesNamespacesFrom = {}));
/**
 * Converts an object of type 'GatewaySpecListenersAllowedRoutesNamespacesSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersAllowedRoutesNamespacesSelector(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(y)),
        'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewaySpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Gateway represents an instance of a service-traffic handling infrastructure
by binding Listeners to a set of IP addresses.
 *
 * @schema GatewayV1Beta1
 */
export class GatewayV1Beta1 extends ApiObject {
    /**
     * Returns the apiVersion and kind for "GatewayV1Beta1"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1beta1',
        kind: 'Gateway',
    };
    /**
     * Renders a Kubernetes manifest for "GatewayV1Beta1".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...GatewayV1Beta1.GVK,
            ...toJson_GatewayV1Beta1Props(props),
        };
    }
    /**
     * Defines a "GatewayV1Beta1" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...GatewayV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...GatewayV1Beta1.GVK,
            ...toJson_GatewayV1Beta1Props(resolved),
        };
    }
}
/**
 * Converts an object of type 'GatewayV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_GatewayV1Beta1Spec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1Spec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'addresses': obj.addresses?.map(y => toJson_GatewayV1Beta1SpecAddresses(y)),
        'gatewayClassName': obj.gatewayClassName,
        'infrastructure': toJson_GatewayV1Beta1SpecInfrastructure(obj.infrastructure),
        'listeners': obj.listeners?.map(y => toJson_GatewayV1Beta1SpecListeners(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecAddresses' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecAddresses(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecInfrastructure' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecInfrastructure(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
        'parametersRef': toJson_GatewayV1Beta1SpecInfrastructureParametersRef(obj.parametersRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListeners' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListeners(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowedRoutes': toJson_GatewayV1Beta1SpecListenersAllowedRoutes(obj.allowedRoutes),
        'hostname': obj.hostname,
        'name': obj.name,
        'port': obj.port,
        'protocol': obj.protocol,
        'tls': toJson_GatewayV1Beta1SpecListenersTls(obj.tls),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecInfrastructureParametersRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecInfrastructureParametersRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersAllowedRoutes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersAllowedRoutes(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'kinds': obj.kinds?.map(y => toJson_GatewayV1Beta1SpecListenersAllowedRoutesKinds(y)),
        'namespaces': toJson_GatewayV1Beta1SpecListenersAllowedRoutesNamespaces(obj.namespaces),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersTls' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersTls(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'certificateRefs': obj.certificateRefs?.map(y => toJson_GatewayV1Beta1SpecListenersTlsCertificateRefs(y)),
        'mode': obj.mode,
        'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersAllowedRoutesKinds' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersAllowedRoutesKinds(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersAllowedRoutesNamespaces' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersAllowedRoutesNamespaces(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'from': obj.from,
        'selector': toJson_GatewayV1Beta1SpecListenersAllowedRoutesNamespacesSelector(obj.selector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersTlsCertificateRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersTlsCertificateRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Mode defines the TLS behavior for the TLS session initiated by the client.
 * There are two possible modes:
 *
 * - Terminate: The TLS session between the downstream client and the
 * Gateway is terminated at the Gateway. This mode requires certificates
 * to be specified in some way, such as populating the certificateRefs
 * field.
 * - Passthrough: The TLS session is NOT terminated by the Gateway. This
 * implies that the Gateway can't decipher the TLS stream except for
 * the ClientHello message of the TLS protocol. The certificateRefs field
 * is ignored in this mode.
 *
 * Support: Core
 *
 * @schema GatewayV1Beta1SpecListenersTlsMode
 */
export var GatewayV1Beta1SpecListenersTlsMode;
(function (GatewayV1Beta1SpecListenersTlsMode) {
    /** Terminate */
    GatewayV1Beta1SpecListenersTlsMode["TERMINATE"] = "Terminate";
    /** Passthrough */
    GatewayV1Beta1SpecListenersTlsMode["PASSTHROUGH"] = "Passthrough";
})(GatewayV1Beta1SpecListenersTlsMode || (GatewayV1Beta1SpecListenersTlsMode = {}));
/**
 * From indicates where Routes will be selected for this Gateway. Possible
 * values are:
 *
 * * All: Routes in all namespaces may be used by this Gateway.
 * * Selector: Routes in namespaces selected by the selector may be used by
 * this Gateway.
 * * Same: Only Routes in the same namespace may be used by this Gateway.
 *
 * Support: Core
 *
 * @schema GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom
 */
export var GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom;
(function (GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom) {
    /** All */
    GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom["ALL"] = "All";
    /** Selector */
    GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom["SELECTOR"] = "Selector";
    /** Same */
    GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom["SAME"] = "Same";
})(GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom || (GatewayV1Beta1SpecListenersAllowedRoutesNamespacesFrom = {}));
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersAllowedRoutesNamespacesSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersAllowedRoutesNamespacesSelector(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_GatewayV1Beta1SpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(y)),
        'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayV1Beta1SpecListenersAllowedRoutesNamespacesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayV1Beta1SpecListenersAllowedRoutesNamespacesSelectorMatchExpressions(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * GatewayClass describes a class of Gateways available to the user for creating
Gateway resources.

It is recommended that this resource be used as a template for Gateways. This
means that a Gateway is based on the state of the GatewayClass at the time it
was created and changes to the GatewayClass or associated parameters are not
propagated down to existing Gateways. This recommendation is intended to
limit the blast radius of changes to GatewayClass or associated parameters.
If implementations choose to propagate GatewayClass changes to existing
Gateways, that MUST be clearly documented by the implementation.

Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
associated GatewayClass. This ensures that a GatewayClass associated with a
Gateway is not deleted while in use.

GatewayClass is a Cluster level resource.
 *
 * @schema GatewayClass
 */
export class GatewayClass extends ApiObject {
    /**
     * Returns the apiVersion and kind for "GatewayClass"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1',
        kind: 'GatewayClass',
    };
    /**
     * Renders a Kubernetes manifest for "GatewayClass".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...GatewayClass.GVK,
            ...toJson_GatewayClassProps(props),
        };
    }
    /**
     * Defines a "GatewayClass" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...GatewayClass.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...GatewayClass.GVK,
            ...toJson_GatewayClassProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'GatewayClassProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayClassProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_GatewayClassSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayClassSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayClassSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'controllerName': obj.controllerName,
        'description': obj.description,
        'parametersRef': toJson_GatewayClassSpecParametersRef(obj.parametersRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayClassSpecParametersRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayClassSpecParametersRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * GatewayClass describes a class of Gateways available to the user for creating
Gateway resources.

It is recommended that this resource be used as a template for Gateways. This
means that a Gateway is based on the state of the GatewayClass at the time it
was created and changes to the GatewayClass or associated parameters are not
propagated down to existing Gateways. This recommendation is intended to
limit the blast radius of changes to GatewayClass or associated parameters.
If implementations choose to propagate GatewayClass changes to existing
Gateways, that MUST be clearly documented by the implementation.

Whenever one or more Gateways are using a GatewayClass, implementations SHOULD
add the `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the
associated GatewayClass. This ensures that a GatewayClass associated with a
Gateway is not deleted while in use.

GatewayClass is a Cluster level resource.
 *
 * @schema GatewayClassV1Beta1
 */
export class GatewayClassV1Beta1 extends ApiObject {
    /**
     * Returns the apiVersion and kind for "GatewayClassV1Beta1"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1beta1',
        kind: 'GatewayClass',
    };
    /**
     * Renders a Kubernetes manifest for "GatewayClassV1Beta1".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...GatewayClassV1Beta1.GVK,
            ...toJson_GatewayClassV1Beta1Props(props),
        };
    }
    /**
     * Defines a "GatewayClassV1Beta1" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...GatewayClassV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...GatewayClassV1Beta1.GVK,
            ...toJson_GatewayClassV1Beta1Props(resolved),
        };
    }
}
/**
 * Converts an object of type 'GatewayClassV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayClassV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_GatewayClassV1Beta1Spec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayClassV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayClassV1Beta1Spec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'controllerName': obj.controllerName,
        'description': obj.description,
        'parametersRef': toJson_GatewayClassV1Beta1SpecParametersRef(obj.parametersRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GatewayClassV1Beta1SpecParametersRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GatewayClassV1Beta1SpecParametersRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * GRPCRoute provides a way to route gRPC requests. This includes the capability
to match requests by hostname, gRPC service, gRPC method, or HTTP/2 header.
Filters can be used to specify additional processing steps. Backends specify
where matching requests will be routed.

GRPCRoute falls under extended support within the Gateway API. Within the
following specification, the word "MUST" indicates that an implementation
supporting GRPCRoute must conform to the indicated requirement, but an
implementation not supporting this route type need not follow the requirement
unless explicitly indicated.

Implementations supporting `GRPCRoute` with the `HTTPS` `ProtocolType` MUST
accept HTTP/2 connections without an initial upgrade from HTTP/1.1, i.e. via
ALPN. If the implementation does not support this, then it MUST set the
"Accepted" condition to "False" for the affected listener with a reason of
"UnsupportedProtocol".  Implementations MAY also accept HTTP/2 connections
with an upgrade from HTTP/1.

Implementations supporting `GRPCRoute` with the `HTTP` `ProtocolType` MUST
support HTTP/2 over cleartext TCP (h2c,
https://www.rfc-editor.org/rfc/rfc7540#section-3.1) without an initial
upgrade from HTTP/1.1, i.e. with prior knowledge
(https://www.rfc-editor.org/rfc/rfc7540#section-3.4). If the implementation
does not support this, then it MUST set the "Accepted" condition to "False"
for the affected listener with a reason of "UnsupportedProtocol".
Implementations MAY also accept HTTP/2 connections with an upgrade from
HTTP/1, i.e. without prior knowledge.
 *
 * @schema GRPCRoute
 */
export class GrpcRoute extends ApiObject {
    /**
     * Returns the apiVersion and kind for "GRPCRoute"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1',
        kind: 'GRPCRoute',
    };
    /**
     * Renders a Kubernetes manifest for "GRPCRoute".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...GrpcRoute.GVK,
            ...toJson_GrpcRouteProps(props),
        };
    }
    /**
     * Defines a "GRPCRoute" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...GrpcRoute.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...GrpcRoute.GVK,
            ...toJson_GrpcRouteProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'GrpcRouteProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_GrpcRouteSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'parentRefs': obj.parentRefs?.map(y => toJson_GrpcRouteSpecParentRefs(y)),
        'rules': obj.rules?.map(y => toJson_GrpcRouteSpecRules(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecParentRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecParentRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
        'sectionName': obj.sectionName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRules(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRefs': obj.backendRefs?.map(y => toJson_GrpcRouteSpecRulesBackendRefs(y)),
        'filters': obj.filters?.map(y => toJson_GrpcRouteSpecRulesFilters(y)),
        'matches': obj.matches?.map(y => toJson_GrpcRouteSpecRulesMatches(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'filters': obj.filters?.map(y => toJson_GrpcRouteSpecRulesBackendRefsFilters(y)),
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFilters(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extensionRef': toJson_GrpcRouteSpecRulesFiltersExtensionRef(obj.extensionRef),
        'requestHeaderModifier': toJson_GrpcRouteSpecRulesFiltersRequestHeaderModifier(obj.requestHeaderModifier),
        'requestMirror': toJson_GrpcRouteSpecRulesFiltersRequestMirror(obj.requestMirror),
        'responseHeaderModifier': toJson_GrpcRouteSpecRulesFiltersResponseHeaderModifier(obj.responseHeaderModifier),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesMatches(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'headers': obj.headers?.map(y => toJson_GrpcRouteSpecRulesMatchesHeaders(y)),
        'method': toJson_GrpcRouteSpecRulesMatchesMethod(obj.method),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFilters(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extensionRef': toJson_GrpcRouteSpecRulesBackendRefsFiltersExtensionRef(obj.extensionRef),
        'requestHeaderModifier': toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifier(obj.requestHeaderModifier),
        'requestMirror': toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestMirror(obj.requestMirror),
        'responseHeaderModifier': toJson_GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifier(obj.responseHeaderModifier),
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersExtensionRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersRequestHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_GrpcRouteSpecRulesFiltersRequestHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_GrpcRouteSpecRulesFiltersRequestHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersRequestMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersRequestMirror(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRef': toJson_GrpcRouteSpecRulesFiltersRequestMirrorBackendRef(obj.backendRef),
        'fraction': toJson_GrpcRouteSpecRulesFiltersRequestMirrorFraction(obj.fraction),
        'percent': obj.percent,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersResponseHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_GrpcRouteSpecRulesFiltersResponseHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_GrpcRouteSpecRulesFiltersResponseHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 * "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 * implementations supporting GRPCRoute MUST support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 * "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 * are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by specific vendors.
 * In the future, filters showing convergence in behavior across multiple
 * implementations will be considered for inclusion in extended or core
 * conformance levels. Filter-specific configuration for such filters
 * is specified using the ExtensionRef field. `Type` MUST be set to
 * "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * @schema GrpcRouteSpecRulesFiltersType
 */
export var GrpcRouteSpecRulesFiltersType;
(function (GrpcRouteSpecRulesFiltersType) {
    /** ResponseHeaderModifier */
    GrpcRouteSpecRulesFiltersType["RESPONSE_HEADER_MODIFIER"] = "ResponseHeaderModifier";
    /** RequestHeaderModifier */
    GrpcRouteSpecRulesFiltersType["REQUEST_HEADER_MODIFIER"] = "RequestHeaderModifier";
    /** RequestMirror */
    GrpcRouteSpecRulesFiltersType["REQUEST_MIRROR"] = "RequestMirror";
    /** ExtensionRef */
    GrpcRouteSpecRulesFiltersType["EXTENSION_REF"] = "ExtensionRef";
})(GrpcRouteSpecRulesFiltersType || (GrpcRouteSpecRulesFiltersType = {}));
/**
 * Converts an object of type 'GrpcRouteSpecRulesMatchesHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesMatchesHeaders(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesMatchesMethod' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesMatchesMethod(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'method': obj.method,
        'service': obj.service,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersExtensionRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersRequestMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestMirror(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRef': toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef(obj.backendRef),
        'fraction': toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestMirrorFraction(obj.fraction),
        'percent': obj.percent,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 * "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 * implementations supporting GRPCRoute MUST support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 * "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 * are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by specific vendors.
 * In the future, filters showing convergence in behavior across multiple
 * implementations will be considered for inclusion in extended or core
 * conformance levels. Filter-specific configuration for such filters
 * is specified using the ExtensionRef field. `Type` MUST be set to
 * "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * @schema GrpcRouteSpecRulesBackendRefsFiltersType
 */
export var GrpcRouteSpecRulesBackendRefsFiltersType;
(function (GrpcRouteSpecRulesBackendRefsFiltersType) {
    /** ResponseHeaderModifier */
    GrpcRouteSpecRulesBackendRefsFiltersType["RESPONSE_HEADER_MODIFIER"] = "ResponseHeaderModifier";
    /** RequestHeaderModifier */
    GrpcRouteSpecRulesBackendRefsFiltersType["REQUEST_HEADER_MODIFIER"] = "RequestHeaderModifier";
    /** RequestMirror */
    GrpcRouteSpecRulesBackendRefsFiltersType["REQUEST_MIRROR"] = "RequestMirror";
    /** ExtensionRef */
    GrpcRouteSpecRulesBackendRefsFiltersType["EXTENSION_REF"] = "ExtensionRef";
})(GrpcRouteSpecRulesBackendRefsFiltersType || (GrpcRouteSpecRulesBackendRefsFiltersType = {}));
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersRequestHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersRequestHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersRequestHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersRequestHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersRequestMirrorBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersRequestMirrorBackendRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersRequestMirrorFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersRequestMirrorFraction(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'denominator': obj.denominator,
        'numerator': obj.numerator,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersResponseHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersResponseHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesFiltersResponseHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesFiltersResponseHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type specifies how to match against the value of the header.
 *
 * @schema GrpcRouteSpecRulesMatchesHeadersType
 */
export var GrpcRouteSpecRulesMatchesHeadersType;
(function (GrpcRouteSpecRulesMatchesHeadersType) {
    /** Exact */
    GrpcRouteSpecRulesMatchesHeadersType["EXACT"] = "Exact";
    /** RegularExpression */
    GrpcRouteSpecRulesMatchesHeadersType["REGULAR_EXPRESSION"] = "RegularExpression";
})(GrpcRouteSpecRulesMatchesHeadersType || (GrpcRouteSpecRulesMatchesHeadersType = {}));
/**
 * Type specifies how to match against the service and/or method.
 * Support: Core (Exact with service and method specified)
 *
 * Support: Implementation-specific (Exact with method specified but no service specified)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * @schema GrpcRouteSpecRulesMatchesMethodType
 */
export var GrpcRouteSpecRulesMatchesMethodType;
(function (GrpcRouteSpecRulesMatchesMethodType) {
    /** Exact */
    GrpcRouteSpecRulesMatchesMethodType["EXACT"] = "Exact";
    /** RegularExpression */
    GrpcRouteSpecRulesMatchesMethodType["REGULAR_EXPRESSION"] = "RegularExpression";
})(GrpcRouteSpecRulesMatchesMethodType || (GrpcRouteSpecRulesMatchesMethodType = {}));
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersRequestMirrorFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersRequestMirrorFraction(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'denominator': obj.denominator,
        'numerator': obj.numerator,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GrpcRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * HTTPRoute provides a way to route HTTP requests. This includes the capability
to match requests by hostname, path, header, or query param. Filters can be
used to specify additional processing steps. Backends specify where matching
requests should be routed.
 *
 * @schema HTTPRoute
 */
export class HttpRoute extends ApiObject {
    /**
     * Returns the apiVersion and kind for "HTTPRoute"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1',
        kind: 'HTTPRoute',
    };
    /**
     * Renders a Kubernetes manifest for "HTTPRoute".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...HttpRoute.GVK,
            ...toJson_HttpRouteProps(props),
        };
    }
    /**
     * Defines a "HTTPRoute" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...HttpRoute.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...HttpRoute.GVK,
            ...toJson_HttpRouteProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'HttpRouteProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_HttpRouteSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'parentRefs': obj.parentRefs?.map(y => toJson_HttpRouteSpecParentRefs(y)),
        'rules': obj.rules?.map(y => toJson_HttpRouteSpecRules(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecParentRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecParentRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
        'sectionName': obj.sectionName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRules(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRefs': obj.backendRefs?.map(y => toJson_HttpRouteSpecRulesBackendRefs(y)),
        'filters': obj.filters?.map(y => toJson_HttpRouteSpecRulesFilters(y)),
        'matches': obj.matches?.map(y => toJson_HttpRouteSpecRulesMatches(y)),
        'timeouts': toJson_HttpRouteSpecRulesTimeouts(obj.timeouts),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'filters': obj.filters?.map(y => toJson_HttpRouteSpecRulesBackendRefsFilters(y)),
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFilters(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extensionRef': toJson_HttpRouteSpecRulesFiltersExtensionRef(obj.extensionRef),
        'requestHeaderModifier': toJson_HttpRouteSpecRulesFiltersRequestHeaderModifier(obj.requestHeaderModifier),
        'requestMirror': toJson_HttpRouteSpecRulesFiltersRequestMirror(obj.requestMirror),
        'requestRedirect': toJson_HttpRouteSpecRulesFiltersRequestRedirect(obj.requestRedirect),
        'responseHeaderModifier': toJson_HttpRouteSpecRulesFiltersResponseHeaderModifier(obj.responseHeaderModifier),
        'type': obj.type,
        'urlRewrite': toJson_HttpRouteSpecRulesFiltersUrlRewrite(obj.urlRewrite),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesMatches(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'headers': obj.headers?.map(y => toJson_HttpRouteSpecRulesMatchesHeaders(y)),
        'method': obj.method,
        'path': toJson_HttpRouteSpecRulesMatchesPath(obj.path),
        'queryParams': obj.queryParams?.map(y => toJson_HttpRouteSpecRulesMatchesQueryParams(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesTimeouts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesTimeouts(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRequest': obj.backendRequest,
        'request': obj.request,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFilters(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extensionRef': toJson_HttpRouteSpecRulesBackendRefsFiltersExtensionRef(obj.extensionRef),
        'requestHeaderModifier': toJson_HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifier(obj.requestHeaderModifier),
        'requestMirror': toJson_HttpRouteSpecRulesBackendRefsFiltersRequestMirror(obj.requestMirror),
        'requestRedirect': toJson_HttpRouteSpecRulesBackendRefsFiltersRequestRedirect(obj.requestRedirect),
        'responseHeaderModifier': toJson_HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifier(obj.responseHeaderModifier),
        'type': obj.type,
        'urlRewrite': toJson_HttpRouteSpecRulesBackendRefsFiltersUrlRewrite(obj.urlRewrite),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersExtensionRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteSpecRulesFiltersRequestHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteSpecRulesFiltersRequestHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestMirror(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRef': toJson_HttpRouteSpecRulesFiltersRequestMirrorBackendRef(obj.backendRef),
        'fraction': toJson_HttpRouteSpecRulesFiltersRequestMirrorFraction(obj.fraction),
        'percent': obj.percent,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestRedirect(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteSpecRulesFiltersRequestRedirectPath(obj.path),
        'port': obj.port,
        'scheme': obj.scheme,
        'statusCode': obj.statusCode,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersResponseHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteSpecRulesFiltersResponseHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteSpecRulesFiltersResponseHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 * "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 * implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 * "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 * are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 * specific vendors.
 * In the future, filters showing convergence in behavior across multiple
 * implementations will be considered for inclusion in extended or core
 * conformance levels. Filter-specific configuration for such filters
 * is specified using the ExtensionRef field. `Type` should be set to
 * "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteSpecRulesFiltersType
 */
export var HttpRouteSpecRulesFiltersType;
(function (HttpRouteSpecRulesFiltersType) {
    /** RequestHeaderModifier */
    HttpRouteSpecRulesFiltersType["REQUEST_HEADER_MODIFIER"] = "RequestHeaderModifier";
    /** ResponseHeaderModifier */
    HttpRouteSpecRulesFiltersType["RESPONSE_HEADER_MODIFIER"] = "ResponseHeaderModifier";
    /** RequestMirror */
    HttpRouteSpecRulesFiltersType["REQUEST_MIRROR"] = "RequestMirror";
    /** RequestRedirect */
    HttpRouteSpecRulesFiltersType["REQUEST_REDIRECT"] = "RequestRedirect";
    /** URLRewrite */
    HttpRouteSpecRulesFiltersType["URL_REWRITE"] = "URLRewrite";
    /** ExtensionRef */
    HttpRouteSpecRulesFiltersType["EXTENSION_REF"] = "ExtensionRef";
})(HttpRouteSpecRulesFiltersType || (HttpRouteSpecRulesFiltersType = {}));
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersUrlRewrite(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteSpecRulesFiltersUrlRewritePath(obj.path),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesMatchesHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesMatchesHeaders(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Method specifies HTTP method matcher.
 * When specified, this route will be matched only if the request has the
 * specified method.
 *
 * Support: Extended
 *
 * @schema HttpRouteSpecRulesMatchesMethod
 */
export var HttpRouteSpecRulesMatchesMethod;
(function (HttpRouteSpecRulesMatchesMethod) {
    /** GET */
    HttpRouteSpecRulesMatchesMethod["GET"] = "GET";
    /** HEAD */
    HttpRouteSpecRulesMatchesMethod["HEAD"] = "HEAD";
    /** POST */
    HttpRouteSpecRulesMatchesMethod["POST"] = "POST";
    /** PUT */
    HttpRouteSpecRulesMatchesMethod["PUT"] = "PUT";
    /** DELETE */
    HttpRouteSpecRulesMatchesMethod["DELETE"] = "DELETE";
    /** CONNECT */
    HttpRouteSpecRulesMatchesMethod["CONNECT"] = "CONNECT";
    /** OPTIONS */
    HttpRouteSpecRulesMatchesMethod["OPTIONS"] = "OPTIONS";
    /** TRACE */
    HttpRouteSpecRulesMatchesMethod["TRACE"] = "TRACE";
    /** PATCH */
    HttpRouteSpecRulesMatchesMethod["PATCH"] = "PATCH";
})(HttpRouteSpecRulesMatchesMethod || (HttpRouteSpecRulesMatchesMethod = {}));
/**
 * Converts an object of type 'HttpRouteSpecRulesMatchesPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesMatchesPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesMatchesQueryParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesMatchesQueryParams(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersExtensionRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestMirror(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRef': toJson_HttpRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef(obj.backendRef),
        'fraction': toJson_HttpRouteSpecRulesBackendRefsFiltersRequestMirrorFraction(obj.fraction),
        'percent': obj.percent,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestRedirect(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPath(obj.path),
        'port': obj.port,
        'scheme': obj.scheme,
        'statusCode': obj.statusCode,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 * "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 * implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 * "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 * are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 * specific vendors.
 * In the future, filters showing convergence in behavior across multiple
 * implementations will be considered for inclusion in extended or core
 * conformance levels. Filter-specific configuration for such filters
 * is specified using the ExtensionRef field. `Type` should be set to
 * "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteSpecRulesBackendRefsFiltersType
 */
export var HttpRouteSpecRulesBackendRefsFiltersType;
(function (HttpRouteSpecRulesBackendRefsFiltersType) {
    /** RequestHeaderModifier */
    HttpRouteSpecRulesBackendRefsFiltersType["REQUEST_HEADER_MODIFIER"] = "RequestHeaderModifier";
    /** ResponseHeaderModifier */
    HttpRouteSpecRulesBackendRefsFiltersType["RESPONSE_HEADER_MODIFIER"] = "ResponseHeaderModifier";
    /** RequestMirror */
    HttpRouteSpecRulesBackendRefsFiltersType["REQUEST_MIRROR"] = "RequestMirror";
    /** RequestRedirect */
    HttpRouteSpecRulesBackendRefsFiltersType["REQUEST_REDIRECT"] = "RequestRedirect";
    /** URLRewrite */
    HttpRouteSpecRulesBackendRefsFiltersType["URL_REWRITE"] = "URLRewrite";
    /** ExtensionRef */
    HttpRouteSpecRulesBackendRefsFiltersType["EXTENSION_REF"] = "ExtensionRef";
})(HttpRouteSpecRulesBackendRefsFiltersType || (HttpRouteSpecRulesBackendRefsFiltersType = {}));
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersUrlRewrite(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteSpecRulesBackendRefsFiltersUrlRewritePath(obj.path),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestMirrorBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestMirrorBackendRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestMirrorFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestMirrorFraction(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'denominator': obj.denominator,
        'numerator': obj.numerator,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersRequestRedirectPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersRequestRedirectPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 *
 * @schema HttpRouteSpecRulesFiltersRequestRedirectScheme
 */
export var HttpRouteSpecRulesFiltersRequestRedirectScheme;
(function (HttpRouteSpecRulesFiltersRequestRedirectScheme) {
    /** http */
    HttpRouteSpecRulesFiltersRequestRedirectScheme["HTTP"] = "http";
    /** https */
    HttpRouteSpecRulesFiltersRequestRedirectScheme["HTTPS"] = "https";
})(HttpRouteSpecRulesFiltersRequestRedirectScheme || (HttpRouteSpecRulesFiltersRequestRedirectScheme = {}));
/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 *
 * @schema HttpRouteSpecRulesFiltersRequestRedirectStatusCode
 */
export var HttpRouteSpecRulesFiltersRequestRedirectStatusCode;
(function (HttpRouteSpecRulesFiltersRequestRedirectStatusCode) {
    /** 301 */
    HttpRouteSpecRulesFiltersRequestRedirectStatusCode[HttpRouteSpecRulesFiltersRequestRedirectStatusCode["VALUE_301"] = 301] = "VALUE_301";
    /** 302 */
    HttpRouteSpecRulesFiltersRequestRedirectStatusCode[HttpRouteSpecRulesFiltersRequestRedirectStatusCode["VALUE_302"] = 302] = "VALUE_302";
})(HttpRouteSpecRulesFiltersRequestRedirectStatusCode || (HttpRouteSpecRulesFiltersRequestRedirectStatusCode = {}));
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersResponseHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersResponseHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersResponseHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersResponseHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesFiltersUrlRewritePath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesFiltersUrlRewritePath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type specifies how to match against the value of the header.
 *
 * Support: Core (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression HeaderMatchType has implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other dialects
 * of regular expressions. Please read the implementation's documentation to
 * determine the supported dialect.
 *
 * @schema HttpRouteSpecRulesMatchesHeadersType
 */
export var HttpRouteSpecRulesMatchesHeadersType;
(function (HttpRouteSpecRulesMatchesHeadersType) {
    /** Exact */
    HttpRouteSpecRulesMatchesHeadersType["EXACT"] = "Exact";
    /** RegularExpression */
    HttpRouteSpecRulesMatchesHeadersType["REGULAR_EXPRESSION"] = "RegularExpression";
})(HttpRouteSpecRulesMatchesHeadersType || (HttpRouteSpecRulesMatchesHeadersType = {}));
/**
 * Type specifies how to match against the path Value.
 *
 * Support: Core (Exact, PathPrefix)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * @schema HttpRouteSpecRulesMatchesPathType
 */
export var HttpRouteSpecRulesMatchesPathType;
(function (HttpRouteSpecRulesMatchesPathType) {
    /** Exact */
    HttpRouteSpecRulesMatchesPathType["EXACT"] = "Exact";
    /** PathPrefix */
    HttpRouteSpecRulesMatchesPathType["PATH_PREFIX"] = "PathPrefix";
    /** RegularExpression */
    HttpRouteSpecRulesMatchesPathType["REGULAR_EXPRESSION"] = "RegularExpression";
})(HttpRouteSpecRulesMatchesPathType || (HttpRouteSpecRulesMatchesPathType = {}));
/**
 * Type specifies how to match against the value of the query parameter.
 *
 * Support: Extended (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression QueryParamMatchType has Implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other
 * dialects of regular expressions. Please read the implementation's
 * documentation to determine the supported dialect.
 *
 * @schema HttpRouteSpecRulesMatchesQueryParamsType
 */
export var HttpRouteSpecRulesMatchesQueryParamsType;
(function (HttpRouteSpecRulesMatchesQueryParamsType) {
    /** Exact */
    HttpRouteSpecRulesMatchesQueryParamsType["EXACT"] = "Exact";
    /** RegularExpression */
    HttpRouteSpecRulesMatchesQueryParamsType["REGULAR_EXPRESSION"] = "RegularExpression";
})(HttpRouteSpecRulesMatchesQueryParamsType || (HttpRouteSpecRulesMatchesQueryParamsType = {}));
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestMirrorBackendRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestMirrorFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestMirrorFraction(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'denominator': obj.denominator,
        'numerator': obj.numerator,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 *
 * @schema HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme
 */
export var HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme;
(function (HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme) {
    /** http */
    HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme["HTTP"] = "http";
    /** https */
    HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme["HTTPS"] = "https";
})(HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme || (HttpRouteSpecRulesBackendRefsFiltersRequestRedirectScheme = {}));
/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 *
 * @schema HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode
 */
export var HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode;
(function (HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode) {
    /** 301 */
    HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode[HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode["VALUE_301"] = 301] = "VALUE_301";
    /** 302 */
    HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode[HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode["VALUE_302"] = 302] = "VALUE_302";
})(HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode || (HttpRouteSpecRulesBackendRefsFiltersRequestRedirectStatusCode = {}));
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersResponseHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteSpecRulesBackendRefsFiltersUrlRewritePath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteSpecRulesBackendRefsFiltersUrlRewritePath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteSpecRulesFiltersRequestRedirectPathType
 */
export var HttpRouteSpecRulesFiltersRequestRedirectPathType;
(function (HttpRouteSpecRulesFiltersRequestRedirectPathType) {
    /** ReplaceFullPath */
    HttpRouteSpecRulesFiltersRequestRedirectPathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteSpecRulesFiltersRequestRedirectPathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteSpecRulesFiltersRequestRedirectPathType || (HttpRouteSpecRulesFiltersRequestRedirectPathType = {}));
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteSpecRulesFiltersUrlRewritePathType
 */
export var HttpRouteSpecRulesFiltersUrlRewritePathType;
(function (HttpRouteSpecRulesFiltersUrlRewritePathType) {
    /** ReplaceFullPath */
    HttpRouteSpecRulesFiltersUrlRewritePathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteSpecRulesFiltersUrlRewritePathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteSpecRulesFiltersUrlRewritePathType || (HttpRouteSpecRulesFiltersUrlRewritePathType = {}));
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType
 */
export var HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType;
(function (HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType) {
    /** ReplaceFullPath */
    HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType || (HttpRouteSpecRulesBackendRefsFiltersRequestRedirectPathType = {}));
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType
 */
export var HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType;
(function (HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType) {
    /** ReplaceFullPath */
    HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType || (HttpRouteSpecRulesBackendRefsFiltersUrlRewritePathType = {}));
/**
 * HTTPRoute provides a way to route HTTP requests. This includes the capability
to match requests by hostname, path, header, or query param. Filters can be
used to specify additional processing steps. Backends specify where matching
requests should be routed.
 *
 * @schema HTTPRouteV1Beta1
 */
export class HttpRouteV1Beta1 extends ApiObject {
    /**
     * Returns the apiVersion and kind for "HTTPRouteV1Beta1"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1beta1',
        kind: 'HTTPRoute',
    };
    /**
     * Renders a Kubernetes manifest for "HTTPRouteV1Beta1".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props) {
        return {
            ...HttpRouteV1Beta1.GVK,
            ...toJson_HttpRouteV1Beta1Props(props),
        };
    }
    /**
     * Defines a "HTTPRouteV1Beta1" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props) {
        super(scope, id, {
            ...HttpRouteV1Beta1.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...HttpRouteV1Beta1.GVK,
            ...toJson_HttpRouteV1Beta1Props(resolved),
        };
    }
}
/**
 * Converts an object of type 'HttpRouteV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1Props(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_HttpRouteV1Beta1Spec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1Spec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'parentRefs': obj.parentRefs?.map(y => toJson_HttpRouteV1Beta1SpecParentRefs(y)),
        'rules': obj.rules?.map(y => toJson_HttpRouteV1Beta1SpecRules(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecParentRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecParentRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
        'sectionName': obj.sectionName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRules' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRules(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRefs': obj.backendRefs?.map(y => toJson_HttpRouteV1Beta1SpecRulesBackendRefs(y)),
        'filters': obj.filters?.map(y => toJson_HttpRouteV1Beta1SpecRulesFilters(y)),
        'matches': obj.matches?.map(y => toJson_HttpRouteV1Beta1SpecRulesMatches(y)),
        'timeouts': toJson_HttpRouteV1Beta1SpecRulesTimeouts(obj.timeouts),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefs(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'filters': obj.filters?.map(y => toJson_HttpRouteV1Beta1SpecRulesBackendRefsFilters(y)),
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFilters(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extensionRef': toJson_HttpRouteV1Beta1SpecRulesFiltersExtensionRef(obj.extensionRef),
        'requestHeaderModifier': toJson_HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifier(obj.requestHeaderModifier),
        'requestMirror': toJson_HttpRouteV1Beta1SpecRulesFiltersRequestMirror(obj.requestMirror),
        'requestRedirect': toJson_HttpRouteV1Beta1SpecRulesFiltersRequestRedirect(obj.requestRedirect),
        'responseHeaderModifier': toJson_HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifier(obj.responseHeaderModifier),
        'type': obj.type,
        'urlRewrite': toJson_HttpRouteV1Beta1SpecRulesFiltersUrlRewrite(obj.urlRewrite),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesMatches' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesMatches(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'headers': obj.headers?.map(y => toJson_HttpRouteV1Beta1SpecRulesMatchesHeaders(y)),
        'method': obj.method,
        'path': toJson_HttpRouteV1Beta1SpecRulesMatchesPath(obj.path),
        'queryParams': obj.queryParams?.map(y => toJson_HttpRouteV1Beta1SpecRulesMatchesQueryParams(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesTimeouts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesTimeouts(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRequest': obj.backendRequest,
        'request': obj.request,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFilters' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFilters(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'extensionRef': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersExtensionRef(obj.extensionRef),
        'requestHeaderModifier': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifier(obj.requestHeaderModifier),
        'requestMirror': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirror(obj.requestMirror),
        'requestRedirect': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirect(obj.requestRedirect),
        'responseHeaderModifier': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifier(obj.responseHeaderModifier),
        'type': obj.type,
        'urlRewrite': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewrite(obj.urlRewrite),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersExtensionRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestMirror(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRef': toJson_HttpRouteV1Beta1SpecRulesFiltersRequestMirrorBackendRef(obj.backendRef),
        'fraction': toJson_HttpRouteV1Beta1SpecRulesFiltersRequestMirrorFraction(obj.fraction),
        'percent': obj.percent,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestRedirect(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPath(obj.path),
        'port': obj.port,
        'scheme': obj.scheme,
        'statusCode': obj.statusCode,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 * "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 * implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 * "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 * are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 * specific vendors.
 * In the future, filters showing convergence in behavior across multiple
 * implementations will be considered for inclusion in extended or core
 * conformance levels. Filter-specific configuration for such filters
 * is specified using the ExtensionRef field. `Type` should be set to
 * "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteV1Beta1SpecRulesFiltersType
 */
export var HttpRouteV1Beta1SpecRulesFiltersType;
(function (HttpRouteV1Beta1SpecRulesFiltersType) {
    /** RequestHeaderModifier */
    HttpRouteV1Beta1SpecRulesFiltersType["REQUEST_HEADER_MODIFIER"] = "RequestHeaderModifier";
    /** ResponseHeaderModifier */
    HttpRouteV1Beta1SpecRulesFiltersType["RESPONSE_HEADER_MODIFIER"] = "ResponseHeaderModifier";
    /** RequestMirror */
    HttpRouteV1Beta1SpecRulesFiltersType["REQUEST_MIRROR"] = "RequestMirror";
    /** RequestRedirect */
    HttpRouteV1Beta1SpecRulesFiltersType["REQUEST_REDIRECT"] = "RequestRedirect";
    /** URLRewrite */
    HttpRouteV1Beta1SpecRulesFiltersType["URL_REWRITE"] = "URLRewrite";
    /** ExtensionRef */
    HttpRouteV1Beta1SpecRulesFiltersType["EXTENSION_REF"] = "ExtensionRef";
})(HttpRouteV1Beta1SpecRulesFiltersType || (HttpRouteV1Beta1SpecRulesFiltersType = {}));
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersUrlRewrite(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteV1Beta1SpecRulesFiltersUrlRewritePath(obj.path),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesMatchesHeaders' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesMatchesHeaders(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Method specifies HTTP method matcher.
 * When specified, this route will be matched only if the request has the
 * specified method.
 *
 * Support: Extended
 *
 * @schema HttpRouteV1Beta1SpecRulesMatchesMethod
 */
export var HttpRouteV1Beta1SpecRulesMatchesMethod;
(function (HttpRouteV1Beta1SpecRulesMatchesMethod) {
    /** GET */
    HttpRouteV1Beta1SpecRulesMatchesMethod["GET"] = "GET";
    /** HEAD */
    HttpRouteV1Beta1SpecRulesMatchesMethod["HEAD"] = "HEAD";
    /** POST */
    HttpRouteV1Beta1SpecRulesMatchesMethod["POST"] = "POST";
    /** PUT */
    HttpRouteV1Beta1SpecRulesMatchesMethod["PUT"] = "PUT";
    /** DELETE */
    HttpRouteV1Beta1SpecRulesMatchesMethod["DELETE"] = "DELETE";
    /** CONNECT */
    HttpRouteV1Beta1SpecRulesMatchesMethod["CONNECT"] = "CONNECT";
    /** OPTIONS */
    HttpRouteV1Beta1SpecRulesMatchesMethod["OPTIONS"] = "OPTIONS";
    /** TRACE */
    HttpRouteV1Beta1SpecRulesMatchesMethod["TRACE"] = "TRACE";
    /** PATCH */
    HttpRouteV1Beta1SpecRulesMatchesMethod["PATCH"] = "PATCH";
})(HttpRouteV1Beta1SpecRulesMatchesMethod || (HttpRouteV1Beta1SpecRulesMatchesMethod = {}));
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesMatchesPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesMatchesPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesMatchesQueryParams' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesMatchesQueryParams(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'type': obj.type,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersExtensionRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersExtensionRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirror' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirror(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'backendRef': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirrorBackendRef(obj.backendRef),
        'fraction': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirrorFraction(obj.fraction),
        'percent': obj.percent,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirect' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirect(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPath(obj.path),
        'port': obj.port,
        'scheme': obj.scheme,
        'statusCode': obj.statusCode,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifier' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifier(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifierAdd(y)),
        'remove': obj.remove?.map(y => y),
        'set': obj.set?.map(y => toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifierSet(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type identifies the type of filter to apply. As with other API fields,
 * types are classified into three conformance levels:
 *
 * - Core: Filter types and their corresponding configuration defined by
 * "Support: Core" in this package, e.g. "RequestHeaderModifier". All
 * implementations must support core filters.
 *
 * - Extended: Filter types and their corresponding configuration defined by
 * "Support: Extended" in this package, e.g. "RequestMirror". Implementers
 * are encouraged to support extended filters.
 *
 * - Implementation-specific: Filters that are defined and supported by
 * specific vendors.
 * In the future, filters showing convergence in behavior across multiple
 * implementations will be considered for inclusion in extended or core
 * conformance levels. Filter-specific configuration for such filters
 * is specified using the ExtensionRef field. `Type` should be set to
 * "ExtensionRef" for custom filters.
 *
 * Implementers are encouraged to define custom implementation types to
 * extend the core API with implementation-specific behavior.
 *
 * If a reference to a custom filter type cannot be resolved, the filter
 * MUST NOT be skipped. Instead, requests that would have been processed by
 * that filter MUST receive a HTTP error response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteV1Beta1SpecRulesBackendRefsFiltersType
 */
export var HttpRouteV1Beta1SpecRulesBackendRefsFiltersType;
(function (HttpRouteV1Beta1SpecRulesBackendRefsFiltersType) {
    /** RequestHeaderModifier */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersType["REQUEST_HEADER_MODIFIER"] = "RequestHeaderModifier";
    /** ResponseHeaderModifier */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersType["RESPONSE_HEADER_MODIFIER"] = "ResponseHeaderModifier";
    /** RequestMirror */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersType["REQUEST_MIRROR"] = "RequestMirror";
    /** RequestRedirect */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersType["REQUEST_REDIRECT"] = "RequestRedirect";
    /** URLRewrite */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersType["URL_REWRITE"] = "URLRewrite";
    /** ExtensionRef */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersType["EXTENSION_REF"] = "ExtensionRef";
})(HttpRouteV1Beta1SpecRulesBackendRefsFiltersType || (HttpRouteV1Beta1SpecRulesBackendRefsFiltersType = {}));
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewrite(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostname': obj.hostname,
        'path': toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePath(obj.path),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestMirrorBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestMirrorBackendRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestMirrorFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestMirrorFraction(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'denominator': obj.denominator,
        'numerator': obj.numerator,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 *
 * @schema HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme
 */
export var HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme;
(function (HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme) {
    /** http */
    HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme["HTTP"] = "http";
    /** https */
    HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme["HTTPS"] = "https";
})(HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme || (HttpRouteV1Beta1SpecRulesFiltersRequestRedirectScheme = {}));
/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 *
 * @schema HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode
 */
export var HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode;
(function (HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode) {
    /** 301 */
    HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode[HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode["VALUE_301"] = 301] = "VALUE_301";
    /** 302 */
    HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode[HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode["VALUE_302"] = 302] = "VALUE_302";
})(HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode || (HttpRouteV1Beta1SpecRulesFiltersRequestRedirectStatusCode = {}));
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersResponseHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesFiltersUrlRewritePath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesFiltersUrlRewritePath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type specifies how to match against the value of the header.
 *
 * Support: Core (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression HeaderMatchType has implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other dialects
 * of regular expressions. Please read the implementation's documentation to
 * determine the supported dialect.
 *
 * @schema HttpRouteV1Beta1SpecRulesMatchesHeadersType
 */
export var HttpRouteV1Beta1SpecRulesMatchesHeadersType;
(function (HttpRouteV1Beta1SpecRulesMatchesHeadersType) {
    /** Exact */
    HttpRouteV1Beta1SpecRulesMatchesHeadersType["EXACT"] = "Exact";
    /** RegularExpression */
    HttpRouteV1Beta1SpecRulesMatchesHeadersType["REGULAR_EXPRESSION"] = "RegularExpression";
})(HttpRouteV1Beta1SpecRulesMatchesHeadersType || (HttpRouteV1Beta1SpecRulesMatchesHeadersType = {}));
/**
 * Type specifies how to match against the path Value.
 *
 * Support: Core (Exact, PathPrefix)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * @schema HttpRouteV1Beta1SpecRulesMatchesPathType
 */
export var HttpRouteV1Beta1SpecRulesMatchesPathType;
(function (HttpRouteV1Beta1SpecRulesMatchesPathType) {
    /** Exact */
    HttpRouteV1Beta1SpecRulesMatchesPathType["EXACT"] = "Exact";
    /** PathPrefix */
    HttpRouteV1Beta1SpecRulesMatchesPathType["PATH_PREFIX"] = "PathPrefix";
    /** RegularExpression */
    HttpRouteV1Beta1SpecRulesMatchesPathType["REGULAR_EXPRESSION"] = "RegularExpression";
})(HttpRouteV1Beta1SpecRulesMatchesPathType || (HttpRouteV1Beta1SpecRulesMatchesPathType = {}));
/**
 * Type specifies how to match against the value of the query parameter.
 *
 * Support: Extended (Exact)
 *
 * Support: Implementation-specific (RegularExpression)
 *
 * Since RegularExpression QueryParamMatchType has Implementation-specific
 * conformance, implementations can support POSIX, PCRE or any other
 * dialects of regular expressions. Please read the implementation's
 * documentation to determine the supported dialect.
 *
 * @schema HttpRouteV1Beta1SpecRulesMatchesQueryParamsType
 */
export var HttpRouteV1Beta1SpecRulesMatchesQueryParamsType;
(function (HttpRouteV1Beta1SpecRulesMatchesQueryParamsType) {
    /** Exact */
    HttpRouteV1Beta1SpecRulesMatchesQueryParamsType["EXACT"] = "Exact";
    /** RegularExpression */
    HttpRouteV1Beta1SpecRulesMatchesQueryParamsType["REGULAR_EXPRESSION"] = "RegularExpression";
})(HttpRouteV1Beta1SpecRulesMatchesQueryParamsType || (HttpRouteV1Beta1SpecRulesMatchesQueryParamsType = {}));
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirrorBackendRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirrorBackendRef(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
        'namespace': obj.namespace,
        'port': obj.port,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirrorFraction' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestMirrorFraction(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'denominator': obj.denominator,
        'numerator': obj.numerator,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Scheme is the scheme to be used in the value of the `Location` header in
 * the response. When empty, the scheme of the request is used.
 *
 * Scheme redirects can affect the port of the redirect, for more information,
 * refer to the documentation for the port field of this filter.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Extended
 *
 * @schema HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme
 */
export var HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme;
(function (HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme) {
    /** http */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme["HTTP"] = "http";
    /** https */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme["HTTPS"] = "https";
})(HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme || (HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectScheme = {}));
/**
 * StatusCode is the HTTP status code to be used in response.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * Support: Core
 *
 * @schema HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode
 */
export var HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode;
(function (HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode) {
    /** 301 */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode[HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode["VALUE_301"] = 301] = "VALUE_301";
    /** 302 */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode[HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode["VALUE_302"] = 302] = "VALUE_302";
})(HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode || (HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectStatusCode = {}));
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifierAdd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifierAdd(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifierSet' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersResponseHeaderModifierSet(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePath' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePath(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replaceFullPath': obj.replaceFullPath,
        'replacePrefixMatch': obj.replacePrefixMatch,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType
 */
export var HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType;
(function (HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType) {
    /** ReplaceFullPath */
    HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType || (HttpRouteV1Beta1SpecRulesFiltersRequestRedirectPathType = {}));
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType
 */
export var HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType;
(function (HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType) {
    /** ReplaceFullPath */
    HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType || (HttpRouteV1Beta1SpecRulesFiltersUrlRewritePathType = {}));
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType
 */
export var HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType;
(function (HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType) {
    /** ReplaceFullPath */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType || (HttpRouteV1Beta1SpecRulesBackendRefsFiltersRequestRedirectPathType = {}));
/**
 * Type defines the type of path modifier. Additional types may be
 * added in a future release of the API.
 *
 * Note that values may be added to this enum, implementations
 * must ensure that unknown values will not cause a crash.
 *
 * Unknown values here must result in the implementation setting the
 * Accepted Condition for the Route to `status: False`, with a
 * Reason of `UnsupportedValue`.
 *
 * @schema HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType
 */
export var HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType;
(function (HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType) {
    /** ReplaceFullPath */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType["REPLACE_FULL_PATH"] = "ReplaceFullPath";
    /** ReplacePrefixMatch */
    HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType["REPLACE_PREFIX_MATCH"] = "ReplacePrefixMatch";
})(HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType || (HttpRouteV1Beta1SpecRulesBackendRefsFiltersUrlRewritePathType = {}));
/**
 * ReferenceGrant identifies kinds of resources in other namespaces that are
trusted to reference the specified kinds of resources in the same namespace
as the policy.

Each ReferenceGrant can be used to represent a unique trust relationship.
Additional Reference Grants can be used to add to the set of trusted
sources of inbound references for the namespace they are defined within.

All cross-namespace references in Gateway API (with the exception of cross-namespace
Gateway-route attachment) require a ReferenceGrant.

ReferenceGrant is a form of runtime verification allowing users to assert
which cross-namespace object references are permitted. Implementations that
support ReferenceGrant MUST NOT permit cross-namespace references which have
no grant, and MUST respond to the removal of a grant by revoking the access
that the grant allowed.
 *
 * @schema ReferenceGrant
 */
export class ReferenceGrant extends ApiObject {
    /**
     * Returns the apiVersion and kind for "ReferenceGrant"
     */
    static GVK = {
        apiVersion: 'gateway.networking.k8s.io/v1beta1',
        kind: 'ReferenceGrant',
    };
    /**
     * Renders a Kubernetes manifest for "ReferenceGrant".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    static manifest(props = {}) {
        return {
            ...ReferenceGrant.GVK,
            ...toJson_ReferenceGrantProps(props),
        };
    }
    /**
     * Defines a "ReferenceGrant" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    constructor(scope, id, props = {}) {
        super(scope, id, {
            ...ReferenceGrant.GVK,
            ...props,
        });
    }
    /**
     * Renders the object to Kubernetes JSON.
     */
    toJson() {
        const resolved = super.toJson();
        return {
            ...ReferenceGrant.GVK,
            ...toJson_ReferenceGrantProps(resolved),
        };
    }
}
/**
 * Converts an object of type 'ReferenceGrantProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReferenceGrantProps(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_ReferenceGrantSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'ReferenceGrantSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReferenceGrantSpec(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'from': obj.from?.map(y => toJson_ReferenceGrantSpecFrom(y)),
        'to': obj.to?.map(y => toJson_ReferenceGrantSpecTo(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'ReferenceGrantSpecFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReferenceGrantSpecFrom(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'namespace': obj.namespace,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/**
 * Converts an object of type 'ReferenceGrantSpecTo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ReferenceGrantSpecTo(obj) {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'group': obj.group,
        'kind': obj.kind,
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
